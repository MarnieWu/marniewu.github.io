[{"id":"d644caf05d644047d4c92cde0f070d6e","title":"å¹¶å‘ Concurrency","content":"Concurrency in Ruståœ¨ Rust ä¸­ï¼Œå¹¶å‘ï¼ˆConcurrencyï¼‰æ˜¯ä¸€é¡¹æ ¸å¿ƒåŠŸèƒ½ï¼Œæ—¨åœ¨å®‰å…¨é«˜æ•ˆçš„åŒæ—¶æ‰§è¡Œå¤šä¸ªä»»åŠ¡ã€‚\nSpawning Threadé»˜è®¤ä»£ç ä¸­çš„ä»»åŠ¡éƒ½æ˜¯åœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡Œçš„ï¼ŒRust åœ¨æ ‡å‡†åº“ä¸­æä¾›äº† thread æ¨¡å—ï¼Œæä¾›äº†æ“ä½œçº¿ç¨‹çš„èƒ½åŠ›ã€‚\nCreating new thread123456789101112131415161718192021222324252627282930use std::thread::spawn;fn main() &#123;  spawn_thread();&#125;pub fn spawn_thread() &#123;    let thread_fn = || &#123;        let mut x = 0u128;        for i in 1..50_000_000 &#123;            x += i;        &#125;        println!(&quot;worker get x = &#123;&#125;&quot;, x);    &#125;;      println!(&quot;Starting new worker thread...&quot;);    let handle = spawn(thread_fn);    let handle2 = spawn(thread_fn);   loop &#123;        if handle.is_finished() &amp;&amp; handle2.is_finished() &#123;            println!(&quot;Worker 1,2 are completed...&quot;);            break;        &#125;    &#125;      println!(&quot;Worker threads are all finished...&quot;);    println!(&quot;Main thread has finished...&quot;);&#125;\n\nstd::thread::spawn(closure)std::thread::spawn æ–¹æ³•ç”¨äºåˆ›å»ºå·¥ä½œçº¿ç¨‹ï¼Œæ¥å—ä¸€ä¸ªé—­åŒ…ï¼Œé—­åŒ…å†…å†™éœ€è¦åœ¨è¯¥çº¿ç¨‹å†…æ‰§è¡Œçš„ä»»åŠ¡ï¼Œè¯¥æ–¹æ³•è¿”å›ä¸€ä¸ª JoinHandle ç»“æ„ä½“ã€‚é»˜è®¤ä¸»çº¿ç¨‹ä¸Šçš„ä»»åŠ¡å’Œå·¥ä½œçº¿ç¨‹æ˜¯éšæœºæ‰§è¡Œçš„ï¼Œæ— æ³•å›ºå®šæ‰§è¡Œé¡ºåºï¼Œå·¥ä½œçº¿ç¨‹ä¾èµ–äºä¸»çº¿ç¨‹åˆ›å»ºï¼Œä¸»çº¿ç¨‹ä¸€æ—¦é€€å‡ºåï¼Œå³ä½¿æœ‰æœªæ‰§è¡Œå®Œçš„å·¥ä½œçº¿ç¨‹ä¸Šçš„ä»»åŠ¡ï¼Œä¹Ÿä¼šç›´æ¥ç»“æŸã€‚\nJoinHandle ç»“æ„ä½“æä¾›äº†ä¸€äº›æ–¹æ³•ï¼Œå…¶ä¸­å°±æœ‰é˜»æ­¢ä¸»çº¿ç¨‹ç»ˆç»“çš„ join æ–¹æ³•ï¼Œè°ƒç”¨è¯¥æ–¹æ³•å¯ä»¥é˜»æ­¢ä¸»çº¿ç¨‹çš„ç»“æŸï¼Œå®ƒä¼šç­‰åˆ°è¯¥å·¥ä½œçº¿ç¨‹æ‰€æœ‰ä»»åŠ¡å®Œæˆåå†é€€å‡ºã€‚\njoin æ–¹æ³•ä¸Šé¢çš„ä¾‹å­æˆ‘ä»¬åœ¨ä¸»çº¿ç¨‹å†™äº†ä¸€ä¸ª loop å‡½æ•°æ¥ä¸€ç›´æ‰§è¡Œï¼Œç›´åˆ° worker threadï¼ˆhandle+handle2ï¼‰ æ‰§è¡Œå®Œæ¯•ã€‚is_finished() æ–¹æ³•æ˜¯ JoinHandle æä¾›çš„ç”¨äºæŸ¥è¯¢å·¥ä½œçº¿ç¨‹æ˜¯å¦ç»“æŸçš„æ–¹æ³•ã€‚é™¤æ­¤ä¹‹å¤–ç”¨ join èƒ½è®©ä¸»çº¿ç¨‹ç­‰å¾…å·¥ä½œçº¿ç¨‹çš„æ‰§è¡Œã€‚\n12345let handle = spawn(thread_fn);let handle2 = spawn(thread_fn);handle.join();handle2.join();\n\n\n\nThread variables çº¿ç¨‹å˜é‡spawn æ–¹æ³•æ¥æ”¶ä¸€ä¸ªé—­åŒ…ï¼Œæˆ‘ä»¬åœ¨å­¦é—­åŒ…éƒ¨åˆ†çš„æ—¶å€™æœ‰æè¿‡ï¼Œé—­åŒ…çš„ç‰¹æ€§å°±æ˜¯å¯ä»¥è®¿é—®çˆ¶çº§ä½œç”¨åŸŸå†…å®šä¹‰çš„å˜é‡ï¼Œè¢«ç§°ä¸º capturing variablesï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨æ–°çº¿ç¨‹é—­åŒ…å‡½æ•°å†…æ˜¯å¯ä»¥è®¿é—®çˆ¶çº§ä½œç”¨åŸŸçš„å˜é‡çš„ã€‚æ¯”å¦‚ä¸‹å›¾ä¾‹å­ï¼š\n\nprint_age é—­åŒ…å†…ä½¿ç”¨äº†çˆ¶çº§ä½œç”¨åŸŸçš„ user å˜é‡ï¼Œè¿™æ—¶ Rust ä¼šå°è¯•åƒçˆ¶çº§ä½œç”¨åŸŸå€Ÿç”¨ userï¼Œç„¶è€Œå°±ä¼šå‡ºç°æŠ¥é”™ä¸Šçš„è¿™ä¸ªé—®é¢˜ï¼šRust å¹¶ä¸çŸ¥é“è¿™ä¸ªé—­åŒ…ä¼šå­˜æ´»å¤šä¹…æˆ–è€…æ›´è¿›ä¸€æ­¥ï¼Œå› ä¸ºè¿™ä¸ªé—­åŒ…æ˜¯ä¼ å…¥ spawn æ–¹æ³•åˆ›å»ºæ–°çº¿ç¨‹æ—¶ç”¨çš„ï¼ŒRust å¹¶ä¸çŸ¥é“è¿™ä¸ªæ–°çº¿ç¨‹ä¼šå­˜æ´»å¤šä¹…ï¼Œæ‰€ä»¥å®ƒæ— æ³•ç¡®è®¤è¢«å€Ÿç”¨çš„ user ä¸€å®šæ˜¯å­˜åœ¨çš„ï¼ˆæ¯”å¦‚å­çº¿ç¨‹å€Ÿç”¨å˜é‡ï¼Œä¸»çº¿ç¨‹é”€æ¯äº†å˜é‡ï¼‰ï¼Œä¾¿å¾—åˆ°äº†ä¸Šé¢çš„æŠ¥é”™ã€‚\næ‰€ä»¥å…³äºçº¿ç¨‹ä¸­ä½¿ç”¨å¤–éƒ¨å˜é‡æœ‰ä¸¤ç§è§£å†³æ–¹æ¡ˆï¼š\nmove closure ä½¿ç”¨ move å…³é”®å­—å°†å˜é‡çš„æ•°æ®æ‰€æœ‰æƒè½¬ç§»åˆ°é—­åŒ…å†…è¿™ç›¸å½“äºå‘Šè¯‰ç¼–è¯‘å™¨å°†å˜é‡è½¬ç§»åˆ°çº¿ç¨‹å†…ä½œç”¨åŸŸï¼Œçº¿ç¨‹ç»“æŸåä¼šè‡ªåŠ¨ drop å˜é‡ã€‚\n123456789use std::thread::spawn;let mut m = 10;let thread_fn = move || &#123;  m += 1;  println!(&quot;m = &#123;&#125;&quot;, m);&#125;;spawn(thread_fn);\n\nä¸Šé¢çš„ move closure åªé€‚ç”¨äºåªéœ€è¦åœ¨å­çº¿ç¨‹å†…ä½¿ç”¨çš„å˜é‡ï¼Œè‹¥åœ¨å­çº¿ç¨‹ç»“æŸåè¿˜éœ€è¦ä½¿ç”¨çš„å˜é‡æˆ‘ä»¬å°±éœ€è¦æ”¹ç”¨ thread::scope æ–¹æ³•ã€‚\nstd::thread::scopeæ™®é€šçš„ threads æ˜¯ non-scoped threadsï¼Œä½¿ç”¨ thread::scope æä¾›ä¸€ä¸ª Scope å¯¹è±¡ï¼Œç”¨è¯¥å¯¹è±¡æä¾›çš„ spawn æ–¹æ³•æ”¯æŒåˆ›å»ºå¸¦ä½œç”¨åŸŸçš„çº¿ç¨‹ï¼Œå®ƒä¼šç¡®ä¿ç­‰å¾…è¿™ä¸ª scope å†…åˆ›å»ºçš„æ‰€æœ‰çº¿ç¨‹çš„ä»»åŠ¡éƒ½æ‰§è¡Œå®Œæ¯•åæ‰ä¼šç¦»å¼€å½“å‰ä½œç”¨åŸŸï¼Œè¿™ç§è‡ªåŠ¨ç­‰å¾…çš„æœºåˆ¶ä¾¿è®©ç¼–è¯‘å™¨å¯ä»¥æ¨æ–­å˜é‡å€Ÿç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¸éœ€è¦å†æ‰‹åŠ¨è½¬ç§»å˜é‡æ‰€æœ‰æƒã€‚\n1234567891011121314use std::thread::scope;let user = Person &#123;  name: String::from(&quot;Mark&quot;),  age: 20,&#125;;let print_name = || &#123;  println!(&quot;My name is &#123;&#125;.&quot;, user.name);&#125;;scope(|s| &#123;  s.spawn(print_name);&#125;);\n\n\n\n\n\nMessage Passing with MPSC channelsçº¿ç¨‹é—´çš„é€šä¿¡æ–¹å¼ä¸ºï¼šMessage Passing æ¶ˆæ¯ä¼ é€’ã€‚æ¶ˆæ¯ä¼ é€’çš„è½½ä½“æ˜¯ channel ï¼Œchannel åˆ†ä¸ºä¸€ä¸ªå‘é€æ–¹ï¼ˆtransmitterï¼‰ä¸€ä¸ªæ¥æ”¶æ–¹ï¼ˆreceiverï¼‰ã€‚\nä½¿ç”¨ mpsc::channel å‡½æ•°åˆ›å»º channelï¼Œmpsc meanings multiple producer single consumerï¼ˆå¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…ï¼‰ã€‚\né€šä¿¡åŸåˆ™é»˜è®¤æƒ…å†µï¼Œchannel é—´æ¶ˆæ¯é€šä¿¡éƒ½éœ€è¦éµå®ˆå¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…çš„åŸåˆ™ï¼Œè¿™æ˜¯ä¸ºäº†é˜²æ­¢æ•°æ®ç«äº‰ï¼ˆdata racingï¼‰ï¼Œå¯ä»¥æœ‰å¤šä¸ªçº¿ç¨‹è¿›è¡Œç”Ÿäº§æ¶ˆæ¯ï¼Œä½†æ˜¯æ¶ˆè´¹æˆ–è€…è¯´æ¥æ”¶ã€å¤„ç†æ¶ˆæ¯çš„çº¿ç¨‹åªèƒ½æœ‰ä¸€ä¸ªã€‚\n12345use std::sync::mpsc;// åˆ›å»ºä¸€ä¸ª channellet (tx, rx) = mpsc::channel();// txï¼šå‘é€æ–¹ï¼Œrxï¼šæ¥æ”¶æ–¹\n\n\n\nå¤šä¸ªç”Ÿäº§è€… multiple producersåˆ›å»º channel åï¼Œé»˜è®¤å¾—åˆ°ä¸€ä¸ªç”Ÿäº§è€…ä¸€ä¸ªæ¶ˆè´¹è€…ï¼Œå¦‚æœéœ€è¦ä½¿ç”¨å¤šä¸ªçº¿ç¨‹è¿›è¡Œæ¶ˆæ¯ç”Ÿäº§çš„åœºæ™¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ clone() æ–¹æ³•å…‹éš†åŸç”Ÿäº§è€…ï¼Œæ¥åˆ›å»ºè¯¥ channel å¤šä¸ªç”Ÿäº§è€…ã€‚\n123456789use std::sync::mpsc;// åˆ›å»ºä¸€ä¸ª channellet (tx, rx) = mpsc::channel();// ä½¿ç”¨ Sender::clone æ–¹æ³•ï¼Œcloneä¸€ä¸ªç”Ÿäº§è€…ï¼ˆç¬¦åˆchannelå¤šä¸ªç”Ÿäº§è€…çš„ä¸»æ—¨ï¼‰let tx2 = mpsc::Sender::clone(&amp;tx);// æˆ–è€… clone trait æ–¹æ³•let tx3 = tx.clone();\n\n\n\nçº¿ç¨‹é—´é€šè¿‡åˆ›å»º Channel è¿›è¡Œé€šä¿¡ï¼Œé€šä¿¡æœŸé—´å¯ä»¥ä¼ é€’ state å®ç°å†…å­˜å…±äº«ã€‚ä½† Channel æ˜¯å•æ‰€æœ‰æƒï¼Œä¸€æ—¦é€šè¿‡ Channel ä¼ å…¥æŸä¸ªçº¿ç¨‹çš„ state ï¼Œæ‰€æœ‰æƒå°±è½¬ç§»åˆ°äº†æ¥æ”¶çº¿ç¨‹ä¸­ï¼Œå°±æ— æ³•è¢«å…¶ä»–çº¿ç¨‹å†ä½¿ç”¨äº†ã€‚è€Œå…±äº«å†…å­˜æ˜¯ç±»ä¼¼å¤šæ‰€æœ‰æƒçš„æ¦‚å¿µï¼Œå¤šä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®åŒä¸€ä¸ªå†…å­˜ï¼Œä¸‹é¢å°±æ¥è®¤è¯†ä¸€ä¸‹ï¼Œå¦‚ä½•åœ¨å¤šä¸ªçº¿ç¨‹é—´å…±äº«æ•°æ®ã€‚\nSharing data within multiple threadså¦‚ä¸Šæ®µç»“å°¾æåˆ°çš„ä¸€æ ·ï¼Œä¸ºäº†æ•°æ®å®‰å…¨æ€§çš„è€ƒè™‘ï¼Œæˆ‘ä»¬éœ€è¦éµå®ˆåªèƒ½å­˜åœ¨ä¸€ä¸ªçº¿ç¨‹æ¶ˆè´¹ï¼ˆè¯»å–ï¼‰æ¶ˆæ¯çš„åŸåˆ™ï¼ˆå•æ‰€æœ‰æƒï¼‰ã€‚ä½†å¦‚æœå°±æ˜¯é‡åˆ°äº†éœ€è¦å¤šä¸ªçº¿ç¨‹é‡Œéƒ½å¯èƒ½ä½¿ç”¨ä¸€ä¸ªæ¶ˆæ¯çš„åœºæ™¯ï¼Œå³å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…ï¼ˆå¤šæ‰€æœ‰æƒï¼‰ï¼Œæˆ‘ä»¬ä¹Ÿæ˜¯å¯ä»¥æ”¯æŒçš„ï¼Œä½†å§‹ç»ˆéµå®ˆåŒä¸€æ—¶é—´åªèƒ½å­˜åœ¨ä¸€ä¸ªçœŸå®æ¶ˆè´¹æ¶ˆæ¯çš„çº¿ç¨‹ã€‚éœ€è¦ä½¿ç”¨ Mutex äº’æ–¥é” + Arc æ™ºèƒ½æŒ‡é’ˆ  ï¼š\nMutex ç”¨æ¥é˜²æ­¢å¤šçº¿ç¨‹ä¸‹çš„æ•°æ®ç«äº‰ï¼ŒArc æ™ºèƒ½æŒ‡é’ˆç”¨æ¥å®ç°æ•°æ®å…±äº«åŠå¤šçº¿ç¨‹ä¸‹éœ€è¦å…±äº«çš„æ•°æ®çš„å®‰å…¨æ€§ã€‚\nMutex äº’æ–¥é” æ˜¯ä»€ä¹ˆMutex è®©å¤šä¸ªçº¿ç¨‹å¹¶å‘çš„è®¿é—®åŒä¸€ä¸ªå€¼å˜æˆäº†æ’é˜Ÿè®¿é—®ï¼šåŒä¸€æ—¶é—´ï¼Œåªå…è®¸ä¸€ä¸ªçº¿ç¨‹Aè®¿é—®è¯¥å€¼ï¼Œå…¶å®ƒçº¿ç¨‹éœ€è¦ç­‰å¾…Aè®¿é—®å®Œæˆåæ‰èƒ½ç»§ç»­ã€‚\nè¿™å°±å¾ˆç¬¦åˆæˆ‘ä»¬ mpsc çš„åŸåˆ™ï¼Œä¸€èˆ¬å•çº¿ç¨‹ä¸­æˆ‘ä»¬å¹¶ä¸éœ€è¦ä½¿ç”¨äº’æ–¥é”ï¼Œå•çº¿ç¨‹ä¸­æœ¬æ¥å°±éœ€è¦éµå®ˆæ‰€æœ‰æƒçš„é™åˆ¶ï¼Œå¾ˆå¤§ç¨‹åº¦çš„é¿å…äº†åŒæ—¶è¯»å†™çš„åœºæ™¯ã€‚æ‰€ä»¥äº’æ–¥é”çš„åœºæ™¯ä¸€èˆ¬éƒ½æ˜¯ç”¨äºå¤šçº¿ç¨‹è®¿é—®åŒä¸€ä¸ªå€¼ã€‚\nMutex æ€ä¹ˆä½¿ç”¨åˆ›å»º12// åˆ›å»ºä¸€ä¸ª Mutex ç»“æ„ä½“å˜é‡let m = Mutex::new(5);\n\nMutex æ˜¯ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œå®ƒä¼šç±»ä¼¼ Box æ™ºèƒ½æŒ‡é’ˆä¸€æ ·æŒæœ‰æ•°æ®ã€‚\nè®¿é—®è®¿é—®å†…éƒ¨çš„æ•°æ®éœ€è¦ä½¿ç”¨ lock() æ–¹æ³•å‘ Mutex å˜é‡ç”³è¯·ä¸€ä¸ªé”ï¼Œè¯¥æ–¹æ³•ä¼šæŒ‚èµ·å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°è·å–åˆ°é”ï¼Œä¸€æ—¦æœ‰æŸä¸€æ¡çº¿ç¨‹è·å–åˆ°äº†é”ï¼Œå…¶ä»–çº¿ç¨‹è·å–é”ä¾¿ä¼šè¢«é˜»å¡ï¼Œç›´åˆ°å·²ç»è·å–é”çš„çº¿ç¨‹å°†é”é‡Šæ”¾ï¼Œè¿™æ ·ä¾¿å¯ä»¥ä¿è¯ï¼ŒåŒæ—¶åªä¼šæœ‰ä¸€æ¡çº¿ç¨‹åœ¨æ“ä½œæ•°æ®ã€‚\nlock() æ–¹æ³•è¿”å›ç±»å‹ä¸º LockResult&lt;MutexGuard&gt;ï¼Œä¸€ä¸ªç”¨ Result åŒ…è£¹çš„ MutexGuard æ™ºèƒ½æŒ‡é’ˆï¼Œæ‰€ä»¥è¦è®¿é—®å†…éƒ¨æ•°æ®éœ€è¦å…ˆä½¿ç”¨ unwarp() å¾—åˆ°æ™ºèƒ½æŒ‡é’ˆï¼Œå†æŒ‰ç…§å…·ä½“ç±»å‹æ“ä½œå†…éƒ¨æ•°æ®ã€‚\n1234567891011// åˆ›å»ºäº†ä¸€ä¸ªMutexlet score = Mutex::new(100);// lock()å¾—åˆ°Resultlet unlocked_data = score.lock();// unwrap()å¾—åˆ°MutexGuardlet mut data = unlocked_data.unwrap();// æ“ä½œdatadata.add_assign(20);println!(&quot;My score is &#123;&#125;.&quot;, data);\n\n\n\né‚£ä¹ˆï¼Œå¦‚æœåŒæ—¶æœ‰ä¸¤ä¸ªçº¿ç¨‹éƒ½åœ¨ç”³è¯·é”ï¼Œå“ªä¸ªçº¿ç¨‹ä¼šæˆåŠŸå‘¢ï¼Ÿæˆ‘ä»¬å°è¯•ç”¨ä»£ç è¿˜åŸä¸€ä¸‹åœºæ™¯ï¼š\n12345678910111213141516171819202122232425262728293031323334353637383940414243use std::&#123;ops::AddAssign, sync::Mutex, thread::scope&#125;;pub fn test_mutex() &#123;    // åˆ›å»ºäº†ä¸€ä¸ª Mutex    let score = Mutex::new(100);    // è¿™é‡Œç”³è¯·äº†é”    let unlocked_data = score.lock();    let mut data = unlocked_data.unwrap();    data.add_assign(20);    println!(&quot;My score is &#123;&#125;.&quot;, data);    // é‡Šæ”¾ä¸Šä¸€ä¸ªé”ï¼Œâœ¨ è¿™é‡Œå¦‚æœä¸é‡Šæ”¾é‚£ä¹ˆä¸‹é¢çš„çº¿ç¨‹é‡Œæ˜¯æ— æ³•ç”³è¯·åˆ°é”çš„    drop(data);    let my_func = || &#123;        println!(&quot;Thread 1 is waiting for mutex lock.&quot;);        let mut data = score.lock().unwrap();        for i in 1..=10 &#123;            data.add_assign(i);            println!(&quot;Thread 1 is adding &#123;&#125; and score is &#123;&#125;&quot;, i, data);        &#125;    &#125;;    let my_func2 = || &#123;        println!(&quot;Thread 2 is waiting for mutex lock.&quot;);        let mut data = score.lock().unwrap();        for i in 1..=10 &#123;            data.add_assign(i);            println!(&quot;Thread 2 is adding &#123;&#125; and score is &#123;&#125;&quot;, i, data);        &#125;    &#125;;    scope(|s| &#123;        s.spawn(my_func);        s.spawn(my_func2);    &#125;);    println!(&quot;The score is &#123;&#125;.&quot;, score.lock().unwrap());&#125;\n\nè¿è¡Œç»“æœå¦‚ä¸‹ï¼š\n\nå¯ä»¥çœ‹åˆ°ï¼Œä¸¤ä¸ªçº¿ç¨‹éƒ½åœ¨ç”³è¯·é”ï¼Œä½†æ‰§è¡Œé¡ºåºä¸€å®šæ˜¯ä¸€ä¸ªé”ç”¨å®Œäº†é‡Šæ”¾äº†ä¹‹åä¸‹ä¸€ä¸ªé”æ‰ä¼šç»§ç»­ã€‚\næˆ‘ä»¬çš„ç›®æ ‡æ˜¯åœ¨å¤šçº¿ç¨‹ä¸‹å®ç°å…±äº«ä¸€ä¸ªæ¶ˆè´¹è€…æ•°æ®ï¼Œé™¤äº†ä½¿ç”¨ Mutex äº’æ–¥é”ä¿è¯å¤šçº¿ç¨‹ä¸‹æ•°æ®çš„åŒæ­¥è®¿é—®ï¼Œé˜²æ­¢æ•°æ®ç«äº‰ï¼ˆdata racingï¼‰å¤–ï¼Œè¿˜éœ€è¦ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆå®ç°æ•°æ®å…±äº«ï¼Œå‰é¢å­¦ä¹ è¿‡åœ¨ä¸€æ¡çº¿ç¨‹é‡Œæˆ‘ä»¬ä½¿ç”¨ Rc æ™ºèƒ½æŒ‡é’ˆæ¥å®ç°ä¸€ä¸ªèµ„æºæ‹¥æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼Œåœ¨å¤šçº¿ç¨‹ä¸‹æ˜¯ä½¿ç”¨ Arc æ™ºèƒ½æŒ‡é’ˆï¼Œå…·ä½“ç”¨æ³•æˆ‘ä»¬åœ¨ç»ƒä¹ éƒ¨åˆ†å†è¿›è¡Œåº”ç”¨ã€‚\nç»ƒä¹ 1\n\nprocess_file å‡½æ•°ï¼šæ¥æ”¶ file_pathï¼Œæ‰“å° file_content\n\nä¸»çº¿ç¨‹ï¼štxï¼ˆå‘é€æ–¹ï¼‰ï¼Œå‡è®¾æœ‰ 10 ä¸ª file_path è¦å¤„ç†ï¼Œéå†å®ƒä»¬è°ƒç”¨ clone æ¥åˆ›å»ºå¤šä¸ªç”Ÿäº§è€…ï¼Œæ¨¡æ‹Ÿå¹¶å‘æ€§çš„å‘é€ file_path\n\nå­çº¿ç¨‹ï¼ˆå·¥ä½œçº¿ç¨‹ï¼‰ï¼šrxï¼ˆæ¥æ”¶æ–¹&#x2F;æ¶ˆè´¹è€…ï¼‰ï¼Œè°ƒç”¨ process_file å‡½æ•°ï¼ŒæŒ‰ç…§é¢˜æ„éœ€è¦åˆ›å»ºå¤šä¸ªå·¥ä½œçº¿ç¨‹å»æ¥å—æ¶ˆæ¯ï¼Œå³ä¼šæœ‰å¤šä¸ªçº¿ç¨‹éœ€è¦å€Ÿç”¨æ¶ˆè´¹è€…ã€‚åœ¨å·¥ä½œçº¿ç¨‹å†… loop è®¿é—®æ¥æ”¶æ–¹ï¼Œæ ¹æ®æ¥æ”¶æ–¹ç»“æœå¤„ç†æ¶ˆæ¯ï¼Œç›´åˆ°æ²¡æœ‰å¯è·å–çš„æ¶ˆæ¯ä¸ºæ­¢\n\næœ€å¤šåŒæ—¶å¤„ç† 4 ä¸ªæ–‡ä»¶ï¼šä¸»çº¿ç¨‹ä¸­åŒæ—¶åˆ›å»º4ä¸ªå·¥ä½œçº¿ç¨‹ï¼Œæ¯ä¸ªå·¥ä½œçº¿ç¨‹éƒ½å»è®¿é—®æ¶ˆè´¹è€…ï¼Œå¤„ç†æ¶ˆè´¹è€…æ¥æ”¶åˆ°çš„æ¶ˆæ¯\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788fn process_file(path: &amp;str) &#123;    let mut file_name = String::from(path);    file_name.push_str(&quot;.txt&quot;);    println!(&quot;ğŸ“” Processing file: &#123;&#125;&quot;, file_name);&#125;fn practice() &#123;    let (tx, rx) = mpsc::channel();    // âœ¨åˆ›å»ºå¤šçº¿ç¨‹ä¸‹å…±äº«çš„rx    let rx = Arc::new(Mutex::new(rx));    // åˆ›å»º10ä¸ªfile_path    let mut file_paths = vec![];    for i in 1..=10 &#123;        file_paths.push(format!(&quot;&#123;&#125;&quot;, i));    &#125;    // main thread ä¸­ clone å¤šä¸ª transmitterï¼ˆsenderï¼‰    for path in file_paths &#123;        // âœ¨æŒ‰ç…§é¢˜æ„ï¼šä½¿ç”¨å¤šçº¿ç¨‹å®ç°æ–‡ä»¶å¤„ç†çš„å¹¶å‘æ€§ï¼Œä¸»çº¿ç¨‹ä½œä¸ºç”Ÿäº§è€…å‘é€šé“å‘é€æ–‡ä»¶è·¯å¾„        let cloned_tx = tx.clone();        // å¤šç”Ÿäº§è€… multiple transmitter        cloned_tx.send(path.clone()).unwrap();        // åŠ ç‚¹å»¶æ—¶ï¼Œçœ‹èµ·æ¥æœ‰æ•ˆæœçš„æ ·å­        thread::sleep(Duration::from_millis(100));    &#125;    // åˆ›å»ºå¤šä¸ªå­çº¿ç¨‹ï¼ˆå·¥ä½œçº¿ç¨‹ï¼‰æ¥å¤„ç†æ¶ˆæ¯    // å¤„ç†æ¶ˆæ¯ï¼šè°ƒç”¨ process_file å‡½æ•°    // rxæ˜¯æ¥æ”¶æ–¹ï¼Œæ˜¯Arcæ™ºèƒ½æŒ‡é’ˆåŒ…è£¹çš„Mutexäº’æ–¥é”    // å…±äº«rxï¼šArc::clone(&amp;rx)    // âœ¨æŒ‰ç…§é¢˜æ„æˆ‘ä»¬éœ€è¦åˆ›å»ºå¤šä¸ªçº¿ç¨‹å»ä½¿ç”¨rx    // æœ€å¤šåŒæ—¶å¤„ç†4ä¸ªæ–‡ä»¶    // handlesç”¨æ¥å­˜å‚¨åˆ›å»ºåçš„çº¿ç¨‹    let mut handles = vec![];    // åŒæ—¶åˆ›å»º4ä¸ªçº¿ç¨‹    for i in 0..4 &#123;        println!(&quot;ğŸ”‹ Worker thread &#123;&#125; get starting ...&quot;, i + 1);        // åˆ›å»ºå…±äº«çš„æ¥æ”¶æ–¹ï¼ŒReference count +1        let shared_receiver = Arc::clone(&amp;rx);        let consumer = move || &#123;            loop &#123;                // ç”³è¯·é”-&gt;è®¿é—®receiver                let unlocked_receiver = shared_receiver.lock();                // æ‹¿åˆ°ç”¨Mutexå­˜å‚¨çš„receiver                let receiver = unlocked_receiver.unwrap();                println!(&quot;ğŸ”„ Attempting to receive message from channel ...&quot;);                // æ‹¿åˆ°receiverçš„ç»“æœ                let receive_result = receiver.try_recv();                match receive_result &#123;                    Ok(msg) =&gt; &#123;                        // æ‹¿æ¶ˆæ¯å¯¹è±¡ä¸­çš„å†…éƒ¨æ•°æ®                        println!(&quot;âœ… Consumer received: &#123;&#125;&quot;, msg);                        process_file(&amp;msg);                        // åŠ ç‚¹å»¶æ—¶ï¼Œçœ‹èµ·æ¥æœ‰æ•ˆæœçš„æ ·å­                        thread::sleep(Duration::from_millis(300));                    &#125;                    Err(mpsc::TryRecvError::Empty) =&gt; &#123;                        // No message received within the timeout                        println!(&quot;â“ Consumer: No message available immediately.&quot;);                        break;                    &#125;                    Err(mpsc::TryRecvError::Disconnected) =&gt; &#123;                        // Channel is disconnected, meaning all senders are dropped                        println!(&quot;â Consumer: Channel disconnected, exiting.&quot;);                        break;                    &#125;                &#125;            &#125;        &#125;;        // å› ä¸ºæˆ‘ä»¬éœ€è¦å€Ÿç”¨variablesï¼Œæˆ‘ä»¬ä½¿ç”¨scopeæ–¹æ³•å¤„ç†ç”Ÿå‘½å‘¨æœŸçš„é—®é¢˜        let handle = spawn(consumer);        handles.push(handle);    &#125;    // blocking main thread to wait for worker thread    // éå†handlesï¼Œæ‰‹åŠ¨è°ƒç”¨join()æ¥é˜»å¡ä¸»çº¿ç¨‹çš„ç»ˆç»“ç­‰å¾…å·¥ä½œçº¿ç¨‹ä»»åŠ¡å®Œæˆ    for handle in handles &#123;        handle.join().unwrap();        println!(&quot;ğŸª« Worker thread is finished.&quot;);    &#125;    println!(&quot;âœ… All files have processed.&quot;);&#125;\n\n\n\n\n\nç»ƒä¹ 2\n\né”™è¯¯æç¤º â€”â€” å½“å‰ç±»å‹ï¼ˆ TaskSign ï¼‰éœ€è¦æ˜¯å®ç°äº† Send trait çš„ç±»å‹ã€‚Send trait æ˜¯ä¸€ç§æ ‡è®°ï¼ˆmarkerï¼‰ç‰¹å¾ï¼Œå®ç°äº†è¯¥ç‰¹å¾çš„ç±»å‹ä¼šè¢«ç¼–è¯‘å™¨è¯†åˆ«ä¸º â€œçº¿ç¨‹å®‰å…¨çš„â€ï¼ˆthread-safeï¼‰ï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬å°†æ ‡å‡†çš„ â€œä¸€ä¸ª receiverâ€ å…±äº«åœ¨å¤šä¸ªçº¿ç¨‹ä¹‹é—´ï¼Œè¿™ä¸ªè¡Œä¸ºä¼šè¢«è®¤ä¸ºæ˜¯ä¸å®‰å…¨çš„ï¼ˆunsafeï¼‰ã€‚æ®æŸ¥è¯¢ï¼Œå¤§éƒ¨åˆ†å†…ç½®ç±»å‹éƒ½è‡ªåŠ¨å®ç°äº† Send ç‰¹å¾ï¼Œéƒ¨åˆ†ç±»å‹æˆ–è€…è‡ªå®šä¹‰ç±»å‹éœ€è¦æ‰‹åŠ¨åŠ ä¸Š Send ç‰¹å¾ã€‚\nSend Traitä¸€ä¸ªæ ‡è®°ç‰¹å¾ï¼Œè¡¨ç¤ºå…è®¸çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒï¼ŒåŸºæœ¬ä¸Šæ‰€æœ‰ç±»å‹éƒ½å®ç°äº†è¿™ä¸ªç‰¹å¾ï¼Œé™¤å¦‚ Rc æ™ºèƒ½æŒ‡é’ˆç­‰çš„å•çº¿ç¨‹ç±»å‹é™¤å¤–ï¼Œè‡ªå®šä¹‰ç±»å‹å¯ä»¥é€šè¿‡æ´¾ç”Ÿå®ç° Send ç‰¹å¾ã€‚\nSync TraitåŒä¸Šï¼Œä¹Ÿæ˜¯ä¸€ä¸ªæ ‡è®°ç‰¹å¾ï¼Œè¡¨ç¤ºå…è®¸ç”±å¤šçº¿ç¨‹è®¿é—®ï¼Œå’Œ Send ä¸€æ ·åŸºæœ¬æ‰€æœ‰ç±»å‹éƒ½å®ç°äº†è¿™ä¸ªç‰¹å¾ã€‚å¦‚æœ T å®ç°äº† Sync ï¼Œé‚£ä¹ˆ &amp;T  è‚¯è¿ªå®ç°äº† Send ï¼Œæˆ–è€…è¯´ T å®ç°äº† Sync åªæœ‰æ˜¯ &amp;T å®ç°äº† Send çš„æƒ…å†µä¸‹ã€‚å› ä¸º T å¯ä»¥è¢«å¤šçº¿ç¨‹è®¿é—®é‚£å®ƒä¸€å®šéœ€è¦å…±äº«ç»™å¤šä¸ªçº¿ç¨‹ï¼Œå®ƒå¿…é¡»æ˜¯å¯ä»¥è¢«ä¼ é€’åˆ°å¤šä¸ªçº¿ç¨‹é—´çš„ï¼Œä¸€å®šæ˜¯å…è®¸è½¬ç§»æ‰€æœ‰æƒçš„ã€‚\nSync å’Œ Send éƒ½æ˜¯ä¸ºäº†ä¿è¯æ•°æ®å®‰å…¨ã€é˜²æ­¢æ•°æ®ç«äº‰æ‰€å®šä¹‰çš„ä¸€äº›è§„åˆ™ã€‚\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118use std::&#123;    sync::&#123;        mpsc::&#123;self, Receiver, Sender&#125;,        Arc, Mutex,    &#125;,    thread::&#123;sleep, spawn, JoinHandle&#125;,    time::Duration,&#125;;struct Task &#123;    id: usize,&#125;impl Task &#123;    fn new(id: usize) -&gt; Self &#123;        Task &#123; id &#125;    &#125;    fn run(&amp;self) &#123;        println!(&quot;âœ… Executing task &#123;&#125;&quot;, self.id);        sleep(Duration::from_secs(1));    &#125;&#125;struct Worker &#123;    id: usize,    // JoinHandle&lt;T&gt;, T refers to return value type of spawn()    handle: JoinHandle&lt;()&gt;,&#125;enum TaskSign &#123;    Task(Task),    End,&#125;type SharedReceiver = Arc&lt;Mutex&lt;Receiver&lt;TaskSign&gt;&gt;&gt;;// å·¥ä½œçº¿ç¨‹æ± // æ§åˆ¶å†…éƒ¨å·¥ä½œçº¿ç¨‹çš„å·¥ä½œå’Œåœæ­¢struct WorkerThreads &#123;    threads: Vec&lt;Worker&gt;,&#125;impl Worker &#123;    fn new(id: usize, handle: JoinHandle&lt;()&gt;) -&gt; Self &#123;        Worker &#123; id, handle &#125;    &#125;&#125;impl WorkerThreads &#123;    fn new() -&gt; Self &#123;        WorkerThreads &#123; threads: vec![] &#125;    &#125;    // æ–°å¢ä¸€ä¸ªå·¥ä½œçº¿ç¨‹ï¼Œæ¯ä¸ªå·¥ä½œçº¿ç¨‹çš„ä»»åŠ¡æ˜¯æŒç»­æŸ¥è¯¢ receiver    fn add_worker(&amp;mut self, receiver: SharedReceiver) -&gt; usize &#123;        let index = self.threads.len();        println!(&quot;ğŸ”‘ New worker thread &#123;&#125;&quot;, index + 1);        let handle = spawn(move || loop &#123;            match receiver.lock().unwrap().recv() &#123;                Ok(TaskSign::End) =&gt; &#123;                    println!(&quot;ğŸš¦ Worker thread &#123;&#125; getting end signal.&quot;, index + 1);                    // æ¥æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œç»ˆç»“å¾ªç¯                    break;                &#125;                Ok(TaskSign::Task(task)) =&gt; &#123;                    println!(                        &quot;â© Worker thread &#123;&#125; is processing the task &#123;&#125;.&quot;,                        index + 1,                        task.id                    );                    task.run();                                  &#125;                Err(e) =&gt; &#123;                    eprintln!(&quot;âŒ Worker thread &#123;&#125; error: &#123;&#125;&quot;, index + 1, e);                &#125;            &#125;        &#125;);        let worker = Worker::new(index, handle);        self.threads.push(worker);        index    &#125;    // åœæ­¢æ‰€æœ‰å·¥ä½œçº¿ç¨‹ï¼Œå‘æ‰€æœ‰å·¥ä½œçº¿ç¨‹å‘é€åœæ­¢æ ‡å¿—    fn stop(&amp;self, transmitter: &amp;Sender&lt;TaskSign&gt;) -&gt; () &#123;        for _ in 0..self.threads.len() &#123;            transmitter.send(TaskSign::End).unwrap();        &#125;    &#125;&#125;pub fn main() &#123;    // å·¥ä½œçº¿ç¨‹æ±     let mut worker_thread_pool = WorkerThreads::new();    let (send_tx, send_rx) = mpsc::channel::&lt;TaskSign&gt;();    let shared_rx = Arc::new(Mutex::new(send_rx));    for _ in 0..4 &#123;        // create worker threads        worker_thread_pool.add_worker(Arc::clone(&amp;shared_rx));    &#125;    for i in 0..10 &#123;        let id = i + 1;        if id == 6 &#123;            WorkerThreads::stop(&amp;worker_thread_pool, &amp;send_tx);            println!(&quot;ğŸ¯ Main thread has sended end signal on task &#123;&#125;.&quot;, id);        &#125; else &#123;            let task = Task::new(id);            send_tx.send(TaskSign::Task(task)).unwrap();            println!(&quot;ğŸ§± Main thread has sended task &#123;&#125;.&quot;, id);        &#125;    &#125;    for worker in worker_thread_pool.threads &#123;        worker.handle.join().unwrap();    &#125;    println!(&quot;âœ… All tasks are finished !!&quot;);&#125;\n\n\n\né‡ç‚¹å®ç°åˆ†æï¼š\n\nåˆ›å»ºäº†ä¸€ä¸ªå·¥ä½œçº¿ç¨‹æ± ç»“æ„ä½“ï¼Œæ¥ç®¡ç†å­çº¿ç¨‹çš„åˆ›å»ºå’Œåœæ­¢ï¼Œåœæ­¢æ„å‘³ç€å‘æ‰€æœ‰å­çº¿ç¨‹å‘é€åœæ­¢ä¿¡å·ã€‚\nå­çº¿ç¨‹è´Ÿè´£æŒç»­å‘ receiver æŸ¥è¯¢ä»»åŠ¡ï¼Œå½“å­çº¿ç¨‹æ¥æ”¶åˆ°åœæ­¢ä¿¡å·æ—¶ï¼Œåˆ™ç»ˆç»“å¾ªç¯ã€‚\næ”¶é›†æ‰€æœ‰å­çº¿ç¨‹è¿”å›çš„ joinHandleï¼Œåˆ†åˆ«è°ƒç”¨ join() æ–¹æ³•ä»¥é˜»å¡ä¸»çº¿ç¨‹ï¼Œç­‰å¾…å­çº¿ç¨‹çš„æ‰§è¡Œã€‚\nä¼˜é›…åœæ­¢çš„ç§˜è¯€ï¼šåœ¨å­çº¿ç¨‹çš„loopå¾ªç¯ä¸­åˆ¤æ–­æ˜¯å¦è¿˜èƒ½æ¥ç»­æ¥æ”¶ä»»åŠ¡ï¼Œè‹¥ä¸è¡Œåˆ™è·³å‡ºå¾ªç¯ï¼Œä¸å†æ¥æ”¶æ–°ä»»åŠ¡ã€‚\n\n","slug":"concurrency","date":"2025-01-28T13:38:22.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"acc0e87b34830b962966d84f538705e6","title":"Rust Test","content":"Unit Testå•å…ƒæµ‹è¯•\n1234567891011121314151617181920212223242526272829303132333435363738394041pub fn add(left: u64, right: u64) -&gt; u64 &#123;    left + right&#125;#[cfg(test)]mod tests &#123;    // å¯¼å…¥å½“å‰åŒ…æ‰€æœ‰çš„å†…å®¹    use super::*;    #[test] // å±æ€§å®ï¼šè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå•å…ƒæµ‹è¯•    fn it_works() &#123;        let result = add(2, 2);        assert_eq!(result, 4, &quot;result is &#123;&#125;&quot;, result);    &#125;    #[test]    fn feature_sum2() &#123;        let result = add(2, 2);        assert_eq!(result, 4, &quot;âœ¨âœ¨âœ¨ result is &#123;&#125;&quot;, result);    &#125;    #[test]    fn feature() -&gt; Result&lt;(), ()&gt; &#123;        Err(())    &#125;    #[test]    // ğŸ“Œ æ˜¾å¼çš„æ ‡è®°ä¸‹é¢çš„å•æµ‹æ˜¯ä¼šå‘ç”Ÿpanicçš„ï¼Œpanicä¸ä¼šå½±å“å•æµ‹é€šè¿‡    // expectedè®¾ç½®æœŸå¾…çš„panic messageï¼Œè‹¥ä¸åŒ¹é…åˆ™å•æµ‹å¤±è´¥    #[should_panic(expected = &quot;error2&quot;)]    fn test_todo() &#123;        panic!(&quot;error2&quot;);    &#125;    #[test]    #[ignore] // æ˜¾å¼çš„å¿½ç•¥æŸä¸ªå•å…ƒæµ‹è¯•    fn test_3() &#123;        unimplemented!();    &#125;&#125;\n\n\n\nIntegration Testé›†æˆæµ‹è¯•\nåœ¨ä¸ src ç›®å½•åŒçº§ä¸‹åˆ›å»º tests ç›®å½•ï¼Œå­˜æ”¾é›†æˆæµ‹è¯•ï¼ˆintegration testï¼‰çš„æ–‡ä»¶ã€‚test ç›®å½•ä¸‹çš„æ¯ä¸€ä¸ªæ–‡ä»¶éƒ½ä¼šè¢«ç¼–è¯‘æˆä¸€ä¸ªå•ç‹¬çš„ crateï¼Œcrate åå°±æ˜¯æ–‡ä»¶åã€‚è¿è¡Œå‘½ä»¤ cargo test ä¼šæ‰§è¡Œå½“å‰ package ä¸‹æ‰€æœ‰çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ã€‚\ncargo testcargo test --test [TEST_CRATE_NAME] ç”¨äºæ‰§è¡Œå•ä¸ªé›†æˆæµ‹è¯•æ–‡ä»¶ã€‚\ncargo test [TESTNAME] ç”¨äºæ‰§è¡ŒæŸä¸ªå•å…ƒæµ‹è¯•ï¼ˆæä¾›å‡½æ•°åï¼‰ã€‚\ncargo test -- --ignored ç”¨äºæ‰§è¡Œæ‰€æœ‰æ ‡è®° ignore çš„å•å…ƒæµ‹è¯•ã€‚\ncargo test --doc ç”¨äºæ‰§è¡Œæ‰€æœ‰æ–‡æ¡£æµ‹è¯•ã€‚\ncargo test --examples [TESTNAME] ç”¨äºæ‰§è¡Œæ‰€æœ‰&#x2F;æŒ‡å®š Examples æµ‹è¯•ã€‚\nåœ¨é›†æˆæµ‹è¯•ç›®å½•ä¸‹ï¼Œå¦‚æœéœ€è¦æŠ½å…¬å…±æ¨¡å—ï¼Œéœ€è¦å•ç‹¬å†å»ºä¸€ä¸ªç›®å½•å¦‚ commonï¼Œåœ¨æ–°å»ºç›®å½•ä¸‹åˆ›å»ºæ–‡ä»¶ã€‚\nDoc Testsæ–‡æ¡£æµ‹è¯•\n/// ä¸ºå‡½æ•°æ ‡æ³¨æ–‡æ¡£æµ‹è¯•çš„æ³¨é‡Šã€‚\n123456789101112/// Add to number/// # Examples/// ```rust/// assert_eq!(rust_lib::add(1,1),2)/// ```/// # Panic/// # Errorspub fn add(left: u64, right: u64) -&gt; u64 &#123;    left + right&#125;// rust_lib ä¸ºå½“å‰ cargo é…ç½®æ–‡ä»¶ä¸‹çš„ package nameï¼Œéœ€è¦æŠŠ â€œ-â€ è½¬æ¢æˆ â€œ_â€\n\n\n\n//! ä¸ºæ¨¡å—æ ‡æ³¨æ–‡æ¡£æµ‹è¯•çš„æ³¨é‡Šï¼Œæ¨¡å—æ³¨é‡Šåªèƒ½å†™åœ¨æ–‡ä»¶å¤´éƒ¨ã€‚é€šå¸¸æ˜¯ç”¨æ¥å†™æ¨¡å—è¯´æ˜çš„\n12345678910//! #utils//! A module helper you//! ```rust//! assert_eq!(rust_lib::utils::sum(1,1),2)//! ```pub mod utils &#123;    pub fn sum(a: u8, b: u8) -&gt; u8 &#123;        a + b    &#125;&#125;\n\n\n\n\n\nBenches [unstable __ TODO]åŸºå‡†æµ‹è¯•ï¼ˆæ€§èƒ½æµ‹è¯•ï¼‰**unstable **çŠ¶æ€\nExampleså½“æˆ‘ä»¬éœ€è¦ä¸ºå½“å‰ rust ä»£ç æä¾›ä¸€äº› demo æ—¶ï¼Œå¯ä»¥ä¸ src åŒçº§åˆ›å»º examples ç›®å½•ï¼Œä¸‹é¢å¯ä»¥æ”¾å¤šä¸ª demo æ–‡ä»¶ï¼Œæ¯ä¸ªæ–‡ä»¶é‡Œå¯ä»¥æä¾›ä¸€äº›è‡ªå·±çš„å•å…ƒæµ‹è¯•ä»£ç ã€‚\n12345678910111213141516171819// examples/a.rsuse rust_lib::add;fn main() &#123;    let sum = add(1, 1);    assert_eq!(sum, 2);&#125;#[test]fn feature_a() &#123;    //&#125;#[test]fn feature_b() &#123;    //&#125;\n\n\n\ncargo test --examples a ç”¨äºæ‰§è¡Œ a æ–‡ä»¶ä¸‹çš„æ‰€æœ‰å•å…ƒæµ‹è¯•ã€‚\ncargo test --examples feature_a ç”¨äºæ‰§è¡Œ examples ç›®å½•ä¸‹æœ€åä¸€ä¸ªåä¸º feature_a çš„å•å…ƒæµ‹è¯•ã€‚\n#[cfg(test)]å±æ€§å®ï¼Œç”¨äºå‘Šè¯‰ç¼–è¯‘å™¨è¿™éƒ¨åˆ†ä»£ç æ˜¯æµ‹è¯•ä»£ç ï¼Œæµ‹è¯•ä»£ç æ˜¯åªæœ‰è¿è¡Œ cargo test æ‰ä¼šè¢«æ‰§è¡Œçš„ä»£ç ï¼Œcargo build æ—¶ä¸ä¼šæ‰§è¡Œã€‚\nEngineering Spec å·¥ç¨‹è§„èŒƒ\nç»ƒä¹ \né…ç½® github\n\n\n\n\n\n\n\n\nGithub Actions å‚è€ƒ:  https://docs.github.com/en/actions/writing-workflows/using-workflow-templates\nåœ¨ github ä¸Šæ–°å»ºä¸€ä¸ªä»“åº“ï¼Œå°†æœ¬åœ°ä»“åº“ä¸ä¹‹å…³è”ï¼Œç‚¹å‡» Actions é€‰æ‹©ä¸€ä¸ªæ¨¡æ¿ï¼ŒæŒ‰ç…§ publish crate æ­¥éª¤å¯¹æ¨¡æ¿è¿›è¡Œä¿®æ”¹ã€‚\nPuiblishing on crates.ioBefore your first publish: Need Login!!\néœ€è¦ç™»å½•æ‰èƒ½å¤Ÿå‘å¸ƒåˆ°å®˜æ–¹å¸‚åœºã€‚æˆ‘ä»¬è¿™é‡Œç”¨ Github Actions è‡ªåŠ¨å‘å¸ƒçš„è¯ï¼Œå°±éœ€è¦å» crates.io ä¸Šæ‹¿ä¸€ä¸ª tokenï¼ˆç™»å½•å‡­è¯ï¼‰å­˜åˆ° github ä»“åº“çš„ settings ä¸­ï¼Œç„¶ååœ¨ ci è„šæœ¬é‡Œå¯ä»¥ä½¿ç”¨ã€‚\ncrates.io é¦–æ¬¡ç”¨ github ç™»å½•åï¼Œä¼šè‡ªåŠ¨å¾€å¯¹åº”é‚®ç®±å‘é€éªŒè¯é‚®ä»¶ï¼Œåªæœ‰é€šè¿‡é‚®ç®±æ ¡éªŒæ‰èƒ½ç”¨è„šæœ¬è¿›è¡Œå‘å¸ƒã€‚éªŒè¯å®Œæˆå https://crates.io/settings/tokens åœ¨è¿™ä¸ªé¡µé¢ç”Ÿæˆ tokenã€‚\n\nå°†ç”Ÿæˆçš„ token å¤åˆ¶ï¼Œå†åˆ° Github ä»“åº“ä¸‹ &gt; Settings &gt; Secrets and variables &gt; Actions é€‰æ‹© New repository secretï¼Œå°† token å­˜å…¥ã€‚\n\n\nè¿™é‡Œå¡«å†™çš„ secrets name å°±æ˜¯ä¹‹ååœ¨ ci æ–‡ä»¶é‡Œä¼šç”¨åˆ°çš„å˜é‡åã€‚\nPublish a crate\n\n\n\n\n\n\n\n\næ–‡æ¡£å‚è€ƒï¼šhttps://doc.rust-lang.org/cargo/reference/publishing.html#packaging-a-crate\nKeep in mind: \ncrate ååœ¨å¸‚åœºä¸Šä¸èƒ½é‡å¤ï¼Œå·²ç»å­˜åœ¨çš„åŒ…åå‘å¸ƒä¼šå¤±è´¥ã€‚åŒ…åæŒ‡çš„æ˜¯ Cargo.toml é…ç½®æ–‡ä»¶ä¸­è®¾ç½®çš„ package nameã€‚\nMake sure you have filled the following fields:\n\nè¡¥å……ç›¸å…³å­—æ®µï¼Œåˆ›å»º README.md\n12345678910111213// Cargo.toml[package]name = &quot;publish-crate-with-github-actions-demo&quot;version = &quot;0.1.0&quot;edition = &quot;2021&quot;license = &quot;MIT&quot;description = &quot;This package is used for test publish a crate with github actions&quot;homepage = &quot;https://marniewu.github.io/post/rust-test&quot;repository = &quot;https://github.com/MarnieWu/publish-crate-demo&quot;readme = &quot;README.md&quot;[dependencies]\n\n123// README.md# Publish a crate with Github Actions\n\n\n\nPackaging a crateæ‰“åŒ…\ncargo publish åŒ…å«ä»¥ä¸‹æ­¥éª¤ï¼š\n\nå¯¹ä½ çš„ package è¿›è¡Œä¸€äº›æ ¡éªŒæ£€æŸ¥ã€‚\nå‹ç¼©ä½ çš„æºä»£ç ä¸ºä¸€ä¸ª .crate æ–‡ä»¶ã€‚\næå– .crate æ–‡ä»¶åˆ°ä¸€ä¸ªäºŒè¿›åˆ¶ç›®å½•ä¸‹å¹¶éªŒè¯å®ƒæ˜¯å¦å¯ä»¥ç¼–è¯‘ã€‚\nä¸Šä¼  .crate æ–‡ä»¶è‡³ crate.ioã€‚\nåœ¨æ·»åŠ ä¹‹å‰ï¼Œæ³¨å†Œè¡¨ä¼šå¯¹ä¸Šä¼ çš„åŒ…åšä¸€äº›é¢å¤–çš„æ£€æŸ¥ã€‚\n\næ³¨å†Œè¡¨ï¼šæŒ‡çš„æ˜¯å¹³å°æä¾›çš„ä¸€ä¸ªå¯è¢«ä¸‹è½½çš„åŒ…çš„æ¸…å• listï¼Œå®ƒç»´æŠ¤äº†æ‰€æœ‰å¹³å°ä¸Šå¯ç”¨çš„åŒ…ä»¥åŠå®ƒä»¬çš„ç‰ˆæœ¬ã€ä¾èµ–å’Œæè¿°ç­‰ç­‰ä¿¡æ¯ã€‚\nè¿è¡Œ cargo publish --dry-run  åœ¨å‘å¸ƒå‰æ£€æŸ¥æ˜¯å¦å­˜åœ¨ warnings å’Œ errorsï¼Œå¦‚æœæœ‰é…ç½® Cargo é•œåƒçš„éœ€è¦æ³¨é‡Šæ‰ç”¨å®˜æ–¹çš„æºæ‰èƒ½å‘å¸ƒã€‚\n\næŒ‰æç¤ºåº”è¯¥æ˜¯æ–‡ä»¶æœªæäº¤ï¼Œæˆ‘ä»¬å…ˆæäº¤ä¸‹å¹¶åŒæ­¥åˆ° githubã€‚å†æ¬¡è¿è¡Œï¼Œé€šè¿‡æ£€æŸ¥ âœ…ã€‚\nä¸‹é¢æˆ‘ä»¬æŠŠå‘½ä»¤è¡Œé…ç½®åˆ° ci æ–‡ä»¶ä¸­ï¼Œè®©å®ƒé€šè¿‡ Github Actions çš„ CI ç»“åˆï¼Œè¿›è¡Œè‡ªåŠ¨å‘å¸ƒã€‚\n123456789101112131415161718192021222324252627282930313233343536373839404142434445# This is a basic workflow to help you get started with Actionsname: PUBLISHING ON crates.io# Controls when the workflow will runon:  # Triggers the workflow on push or pull request events but only for the &quot;main&quot; branch  push:    branches: [&quot;main&quot;]  pull_request:    branches: [&quot;main&quot;]  # Allows you to run this workflow manually from the Actions tab  workflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:  # This workflow contains a single job called &quot;publish&quot;  publish:    name: Publish    # The type of runner that the job will run on    runs-on: ubuntu-latest    env:      # âœ¨ è¿™é‡Œæ˜¯æˆ‘ä»¬å‰é¢åœ¨ä»“åº“è®¾ç½®çš„ token      CRATES_TOKEN: $&#123;&#123; secrets.CRATES_TOKEN &#125;&#125;      RUST_CHANNEL: &quot;stable&quot;    # Steps represent a sequence of tasks that will be executed as part of the job    steps:      - uses: actions/checkout@v4      # Install Rust toolchain      - name: Install Rust toolchain        run: |          rustup update --no-self-update $&#123;&#123; env.RUST_CHANNEL &#125;&#125;          rustup component add --toolchain $&#123;&#123; env.RUST_CHANNEL &#125;&#125; rustfmt rust-src          rustup default $&#123;&#123; env.RUST_CHANNEL &#125;&#125;      # Before publishing check warnings and errors      - name: Publishing check        run: cargo publish --dry-run      # Publish to crates.io      - name: Publish to crates.io        run: cargo publish --token $&#123;CRATES_TOKEN&#125;\n\n\nè¿™å°±æ˜¯æ²¡æœ‰æ ¡éªŒé‚®ç®±ä¼šæŠ¥çš„é”™è¯¯ï¼ŒéªŒè¯åæ‰‹åŠ¨ re-run ciã€‚\n\nci æˆåŠŸï¼Œæˆ‘ä»¬å» crates.io ä¸ŠæŸ¥æ‰¾ä¸€ä¸‹æœ‰æ²¡æœ‰å¯¹åº”çš„åŒ…ï¼Œæœç´¢ package_name åŒ…åã€‚\n\n\næˆåŠŸæœåˆ°ï¼Œå®Œæˆ âœ…\nï¼ˆTODOï¼šåç»­è¿˜å¯ä»¥æŒ‰éœ€åŠ ä¸Š version bumping, git tagging ç­‰åŠŸèƒ½ï¼‰\n","slug":"rust-test","date":"2025-01-27T02:12:05.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"dffe4aa96c5d22cd6989d498cd57fa66","title":"è¿­ä»£å™¨ Iterators","content":"What are iterators?è¿­ä»£å™¨æ˜¯ Rust ä¸­ç”¨æ¥å¤„ç†é›†åˆçš„æ–¹å¼ï¼Œå…è®¸éå†å’Œæ“ä½œåºåˆ—å€¼ã€‚\nIterator TraitIterator Trait ä¼šæä¾› next() æ–¹æ³•ï¼Œç”¨äºè¿”å›ç”¨ Option åŒ…è£¹çš„åºåˆ—çš„ä¸‹ä¸€ä¸ª itemï¼Œç›´åˆ°æ²¡æœ‰å…ƒç´ å¯ä»¥è¿”å›äº†ï¼Œå³è¿”å› Noneã€‚Trait å†…éƒ¨è®¾ç½®äº†å…³è”ç±»å‹ï¼Œå®ç°æ—¶å£°æ˜å…·ä½“ç±»å‹ã€‚\n1234trait Iterator &#123;  type Item;  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;&#125;\n\n\n\nLaziness æƒ°æ€§çš„è¿­ä»£å™¨åˆ†ä¸ºåˆ›å»ºå’Œæ¶ˆè´¹ä¸¤éƒ¨åˆ†\n1234let numbers = vec![1, 2, 3, 4, 5];// è¿™æ—¢æ˜¯åˆ›å»ºäº†ä¸€ä¸ªè¿­ä»£å™¨let nums_iter = numbers.iter();\n\n\n\nè¿­ä»£å™¨æ˜¯æ‡’æƒ°çš„ï¼Œåœ¨æ²¡æœ‰æ¶ˆè´¹è¿­ä»£å™¨ä¹‹å‰ï¼Œä¸ä¼šäº§ç”Ÿä»»ä½•çš„æ¶ˆè€—ï¼Œå³åˆ›å»ºè¯­å¥å¹¶ä¸ä¼šçœŸå®è¢«æ‰§è¡Œã€‚\n1234// ä¸‹é¢æ˜¯åˆ›å»ºäº†ä¸€ä¸ªè¿­ä»£å™¨let nums_iter = numbers.iter();// ä¸‹é¢æ˜¯æ¶ˆè´¹äº†ä¸€ä¸ªè¿­ä»£å™¨let nums: Vec&lt;_&gt; = nums_iter.collect();\n\n\n\nTypes of Iteratorsè¿­ä»£å™¨åˆ†ä¸ºä¸‰ç§ç±»å‹ï¼š\n\nè¿­ä»£å™¨æœ¬èº«ï¼šå®ç°äº† Iterator Trait çš„è¿­ä»£å™¨éƒ½è¢«ç§°ä¸ºæ™®é€šè¿­ä»£å™¨ï¼Œå®ƒä»¬èƒ½ä½¿ç”¨ next() æ–¹æ³•å¯¹åºåˆ—éå†ç›´åˆ°è¿”å› None ã€‚\nè¿­ä»£å™¨é€‚é…å™¨ï¼šä¼šåˆ›å»ºå¹¶è¿”å›ä¸€ä¸ªæ–°çš„è¿­ä»£å™¨çš„æ–¹æ³•ï¼Œè¢«ç§°ä¸ºè¿­ä»£å™¨é€‚é…å™¨ã€‚å¦‚ mapã€filterã€take ç­‰ã€‚\næ¶ˆè€—é€‚é…å™¨ï¼šå°†ä¸€ä¸ªè¿­ä»£å™¨è½¬æ¢æˆé›†åˆå¹¶è¿”å›çš„æ–¹æ³•ï¼Œè¢«ç§°ä¸ºæ¶ˆè€—é€‚é…å™¨ã€‚å¦‚ collectã€sumã€fold ç­‰ã€‚\n\nAssociated Methodså¸¸ç”¨çš„åˆ›å»ºè¿­ä»£å™¨çš„ä¸‰ç§æ–¹æ³•\niter()ï¼šåˆ›å»ºä¸€ä¸ªå€Ÿç”¨é›†åˆä¸­æ¯ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ï¼ŒåŸé›†åˆå¯ä»¥ç»§ç»­ä½¿ç”¨1234let vec = vec![1, 2, 3];for item in vec.iter() &#123;    println!(&quot;&#123;&#125;&quot;, item);&#125;\n\n\n\ninto_inter()ï¼šåˆ›å»ºä¼šè½¬ç§»é›†åˆä¸­æ¯ä¸ªå…ƒç´ æ‰€æœ‰æƒçš„è¿­ä»£å™¨ï¼ŒåŸé›†åˆä¸èƒ½å†ç»§ç»­ä½¿ç”¨1234let vec = vec![1, 2, 3];for item in vec.into_iter() &#123;    println!(&quot;&#123;&#125;&quot;, item);&#125;\n\n\n\niter_mut()ï¼šåˆ›å»ºä¸€ä¸ªå¯å˜å€Ÿç”¨æ¯ä¸ªå…ƒç´ çš„ï¼Œè¿­ä»£è¿‡ç¨‹ä¸­æ¯ä¸ªå…ƒç´ éƒ½æ”¯æŒä¿®æ”¹ï¼ŒåŸé›†åˆå¯ä»¥ç»§ç»­ä½¿ç”¨1234let mut vec = vec![1, 2, 3];for item in vec.iter_mut() &#123;    *item += 1; // Increment each element&#125;\n\n\n\nExampleswhile loop1234567let my_vec = vec![1, 2, 3, 4, 5];let mut my_iter = my_vec.iter();// while loopwhile let Some(next) = my_iter.next() &#123;  println!(&quot;&#123;&#125;&quot;, next);&#125;\n\nå½“ä½¿ç”¨  while loop æ—¶ï¼Œå› ä¸ºæ¯æ¬¡éƒ½æ˜¯å¤–éƒ¨è°ƒç”¨çš„ .next() æ§åˆ¶è¿­ä»£å™¨çš„éå†ï¼Œæ‰€ä»¥éœ€è¦å°† iterator å£°æ˜æˆå¯å˜çš„ï¼Œæ‰èƒ½æ“ä½œå†…éƒ¨çŠ¶æ€ã€‚\nfor...in1234567let my_vec = vec![1, 2, 3, 4, 5];let my_iter = my_vec.iter();// for loopfor v in my_iter &#123;  println!(&quot;&#123;&#125;&quot;, v);&#125;\n\nfor...in  éå†è¿­ä»£å™¨æ˜¯ç”±å¾ªç¯å†…éƒ¨æ§åˆ¶çš„è¿­ä»£å™¨çŠ¶æ€ï¼Œæ‰€ä»¥æ— éœ€å¤–éƒ¨çš„å¯å˜å£°æ˜ã€‚\nç»ƒä¹ \n1234567891011121314151617181920212223242526272829303132333435363738394041424344fn main() &#123;    let fib = Fibonacci::new();    let first_ten: Vec&lt;u32&gt; = fib.take(10).collect();    println!(&quot;First 10 Fibonacci numbers: &#123;:?&#125;&quot;, first_ten);&#125;#[derive(Debug)]struct Fibonacci &#123;    prev: u32,    curr: u32,&#125;/** * å®ç°ä¸€ä¸ªç»“æ„ä½“ Fibonacciï¼Œå¹¶ä¸ºå®ƒå®ç° Iterator traitã€‚ * åœ¨ next æ–¹æ³•ä¸­ç”Ÿæˆä¸‹ä¸€ä¸ªæ–æ³¢é‚£å¥‘æ•°ã€‚ * ç¼–å†™ä¸€ä¸ªæµ‹è¯•å‡½æ•°ï¼Œè¾“å‡ºå‰ 10 ä¸ªæ–æ³¢é‚£å¥‘æ•°ã€‚ * take æ–¹æ³•æ˜¯ä¸€ä¸ªè¿­ä»£é€‚é…å™¨ï¼Œç”¨äºé™åˆ¶ç”Ÿæˆçš„æ•°é‡ã€‚ */impl Fibonacci &#123;    fn new() -&gt; Fibonacci &#123;        Fibonacci &#123; curr: 0, prev: 0 &#125;    &#125;&#125;impl Iterator for Fibonacci &#123;    type Item = u32;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;        if self.prev == 0 &amp;&amp; self.curr == 0 &#123;            // first one number            self.curr = 1;        &#125; else if self.prev == 0 &amp;&amp; self.curr == 1 &#123;            // first two number            self.prev = 1;        &#125; else &#123;            // normally            let prev = self.prev;            self.prev = self.curr;            self.curr += prev;        &#125;        Some(self.curr)    &#125;&#125;\n\n","slug":"iterators","date":"2025-01-21T10:15:44.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"eb08d875d225f31121fe8b5a6e855210","title":"é¡¹ç›®å’ŒåŒ… Packages and Crates","content":"TODO â€¦","slug":"packages_and_crates","date":"2025-01-20T06:25:41.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"b174df949a1c3f84910009414c4b737f","title":"npm_and_pnpm","content":"TODO â€¦","slug":"npm-and-pnpm","date":"2025-01-17T16:47:09.000Z","categories_index":"","tags_index":"","author_index":"Marnie"},{"id":"0e16d47ce0f8c7e02c11662ec70d0b06","title":"é—­åŒ… Closures","content":"What are Closures?Rust ä¸­çš„é—­åŒ…æœ¬è´¨æ˜¯ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œå®ƒæœ‰ä¸‰ä¸ªç‰¹ç‚¹ï¼š\n\nå¯ä»¥è¢«å­˜å‚¨åœ¨å˜é‡ä¸­\nå¯ä»¥å½“åšå‚æ•°ä¼ ç»™æŸä¸ªå‡½æ•°\nå¯ä»¥å½“åšæŸä¸ªå‡½æ•°çš„è¿”å›å€¼\n\nè¿™éƒ½æ˜¯æ™®é€šå‡½æ•°ä¸èƒ½åšåˆ°çš„ï¼Œä¸€ä¼šå„¿æˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªå¯¹æ¯”çš„ä¾‹å­ï¼Œå…ˆæ¥çœ‹ä¸‹é—­åŒ…çš„è¯­æ³•å’Œä½¿ç”¨ã€‚\nClosure Syntax1|parameters| body\n\n\nParametersï¼šå‚æ•°éœ€è¦ç”¨ç«–çº¿åŒ…è£¹ï¼Œå¯ä»¥ä¸ºç©º ||\nBodyï¼šé—­åŒ…ä¸»ä½“ï¼Œé»˜è®¤éœ€è¦ç”¨ &#123;&#125; åŒ…è£¹ |...| &#123; ... &#125;ï¼Œå¦‚æœåªæœ‰ä¸€å¥è¡¨è¾¾å¼ï¼ˆexpressionï¼‰ï¼Œå¯ä»¥çœç•¥æ‹¬å· |...| println!(&quot;test&quot;)\n\nExamplesSimple Closure123let add = |a: i32, b: i32| -&gt; i32 &#123; a + b &#125;;let result = add(2, 3);println!(&quot;The sum is &#123;&#125;.&quot;, result); // Output: The sum is 5.\n\nç®€å•çš„é—­åŒ…å°±å’Œæ™®é€šå‡½æ•°è¡¨ç°ä¸€è‡´ï¼Œæˆ‘ä»¬å®šä¹‰æ—¶ä¹Ÿå¯ä»¥ä¸å£°æ˜ç±»å‹ï¼ŒæŒ‰ç…§ç¬¬ä¸€ä¸ªè°ƒç”¨çš„é—­åŒ…ä¼šäº§ç”Ÿè‡ªåŠ¨çš„ç±»å‹æ¨æ–­ã€‚\nNo Parameters, one line body12let greet = || println!(&quot;Hello, world!&quot;);greet(); // Outputs: Hello, world!\n\n\n\nCapturing Variables12345let x = 10;let add_to_x = |y: i32| -&gt; i32 &#123; y + x &#125;;let result = add_to_x(5);println!(&quot;The result of adding 5 to &#123;&#125; is: &#123;&#125;&quot;, x, result); // Outputs: The result of adding 5 to 10 is: 15\n\n\n\nMulti Lines1234567let squared_sum = |x: i32, y: i32| -&gt; i32 &#123;  \tlet sum = x * y;  \tsum * sum&#125;;let result = squared_sum(2, 3);println!(&quot;Result = &#123;&#125;&quot;, result); // Outputs: Result = 64\n\n\n\nCompared to standard functionsDonâ€™t have to sepcify data types of the closureâ€™s argumentså¯ä»¥ä¸å®šä¹‰é—­åŒ…çš„å‚æ•°ç±»å‹ï¼Œå®ƒä¼šæ ¹æ®å®é™…è°ƒç”¨ï¼ˆinvokeï¼‰ä¼ å…¥çš„å‚æ•°ç±»å‹è¿›è¡Œç±»å‹æ¨æ–­ï¼ˆdata type inferingï¼‰ã€‚\nAs same as, the returning type also can be empty, complier will infer the data type through its invoking.åŒæ ·çš„ï¼Œè¿”å›ç±»å‹ä¹Ÿå¯ä»¥ä¸å®šä¹‰ï¼Œç¼–è¯‘å™¨ä¼šé€šè¿‡å…¶è°ƒç”¨æ¨æ–­æ•°æ®ç±»å‹ã€‚\nCapturing Variablesé—­åŒ…å’Œå‡½æ•°è¿˜æœ‰ä¸€ä¸ªå¤§å·®å¼‚ â€”â€” é—­åŒ…å¯ä»¥è®¿é—®å…¶æ‰€åœ¨ä½œç”¨åŸŸå†…çš„å˜é‡ã€‚Standard functions can not access the varibales which are defined out of this function.\n12345678910pub fn test_closures() &#123;    let add = |x: i32, y: i32| x + y;    let number = 5;    fn test_standard_function() &#123;        println!(&quot;&#123;&#125;&quot;, number); // âŒ get error    &#125;    add(number, 10);&#125;\n\n\nè€Œé—­åŒ…ä¸åŒäºæ ‡å‡†å‡½æ•°ï¼Œå®ƒæä¾›äº† inheritï¼ˆç»§æ‰¿ï¼‰çš„èƒ½åŠ›ï¼Œåœ¨é—­åŒ…å†…å¯ä»¥è®¿é—®çˆ¶çº§ä½œç”¨åŸŸï¼ˆparent scopeï¼‰ç”¨å†…å®šä¹‰çš„å˜é‡ï¼Œè¿™ä¹Ÿè¢«ç§°ä¸ºå˜é‡æ•è·ï¼ˆcapturing variablesï¼‰ï¼Œæ•è·æœ‰ä¸‰ç§å½¢å¼ï¼š\n\nå¼•ç”¨æ•è·ï¼ˆé»˜è®¤ï¼‰ï¼šé—­åŒ…å¯¹å˜é‡è¿›è¡Œå€Ÿç”¨\nå¯å˜å¼•ç”¨æ•è·ï¼šé—­åŒ…å¯¹å˜é‡è¿›è¡Œå¯å˜çš„å€Ÿç”¨\næŒ‰å€¼ï¼šä¸Šä¸¤ç§éƒ½æ˜¯å¯¹å˜é‡çš„å€Ÿç”¨ï¼Œå¦‚æœæƒ³ç›´æ¥æ‹¥æœ‰æ•°æ®çš„æ‰€æœ‰æƒï¼Œéœ€è¦ä½¿ç”¨ move å…³é”®å­—è½¬ç§»æ‰€æœ‰æƒï¼Œæ‰€æœ‰æƒè½¬ç§»åçš„å˜é‡ä¸èƒ½å†åç»­è¢«ä½¿ç”¨\n\nExamplesCapturing By Referenceï¼ˆDefault)12345let x = 10;let add_to_x = |y: i32| -&gt; i32 &#123; y + x &#125;;let result = add_to_x(5);println!(&quot;The result of adding 5 to &#123;&#125; is: &#123;&#125;&quot;, x, result); // Outputs: The result of adding 5 to 10 is: 15\n\n\n\nCapturing By Mutable Referenceå¯å˜å€Ÿç”¨çš„å‰ææ˜¯è¢«å€Ÿç”¨çš„å˜é‡ä¹Ÿå¾—æ˜¯ mutable çš„ï¼Œé—­åŒ…ä¹Ÿå®šä¹‰æˆ mutable\n12345678let mut x = 10;let mut add_to_x = |y: i32| -&gt; i32 &#123;  \tx += 5; // mutation  \tx + y&#125;;let result = add_to_x(5);println!(&quot;x = &#123;&#125;&quot;, x); // Outputs: x = 15\n\n\n\nCapturing By Valueï¼ˆmoveï¼‰å¯¹äºå®ç°äº† Copy trait çš„æ•°æ®ç±»å‹å˜é‡çš„ç§»åŠ¨å’Œèµ‹å€¼éƒ½ä¸ä¼šå‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»ï¼Œæ˜¯å€¼çš„å¤åˆ¶ã€‚æ‰€ä»¥æµ‹è¯• move éœ€è¦ä½¿ç”¨æ²¡æœ‰å®ç° Copy trait çš„æ•°æ®ç±»å‹\n1234let x = String::from(&quot;Test&quot;); // no implements Copy traitlet foo = move || println!(&quot;&#123;&#125; is moved&quot;, x);foo();println!(&quot;&#123;&#125;&quot;, x);\n\n\nmove äº†ä»€ä¹ˆä¸œè¥¿ï¼Ÿä½¿ç”¨ move é—­åŒ…çš„ç›®çš„æ˜¯ä¸ºäº†å°†é—­åŒ…å†…æ•è·çš„å˜é‡çš„å€¼çš„æ‰€æœ‰æƒè½¬ç§»åˆ°é—­åŒ…å†…éƒ¨ï¼Œéœ€è¦è½¬ç§»æ‰€æœ‰æƒçš„åŸå› æ˜¯å› ä¸ºåœ¨ä¸åŒä½œç”¨åŸŸå†…å®šä¹‰çš„å˜é‡æœ‰ç€ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸï¼Œè‹¥æ˜¯å†æ›´é•¿çš„ç”Ÿå‘½å‘¨æœŸå†…å€Ÿç”¨äº†çŸ­ç”Ÿå‘½å‘¨æœŸçš„å˜é‡ï¼Œä¼šå¯¼è‡´æŠ¥é”™ï¼Œä¸ºäº†é¿å…é”™è¯¯æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ move é—­åŒ…ç›´æ¥å°†æ‰€æœ‰æƒè½¬ç§»åˆ°é—­åŒ…å†…ï¼Œä¸€ç»è½¬ç§»å¤–éƒ¨åˆ™ä¸èƒ½å†ä½¿ç”¨ã€‚\nTypes of the closuresé—­åŒ…é€‚ç”¨çš„åœºæ™¯ä¸€èˆ¬æ˜¯å½“åš callback functions æˆ–è€…ç”¨äº iterators ä¸­ï¼Œåœ¨å°†é—­åŒ…ä½œä¸ºå‚æ•°æ—¶æˆ‘ä»¬éœ€è¦å®šä¹‰é—­åŒ…çš„ç±»å‹ã€‚æŒ‰ç…§â€œä½ ä½¿ç”¨é—­åŒ…éœ€è¦å¹²ä»€ä¹ˆâ€å¯ä»¥å°†é—­åŒ…çš„ç±»å‹åˆ†ä¸ºä¸‰ç§ï¼Œitâ€™s matched the three ways of ğŸ‘†ğŸ»Capturing Varibales.\nFnï¼ˆReference capturingï¼‰æ™®é€šé—­åŒ…ï¼Œå¯ä»¥è°ƒç”¨ä¸€æ¬¡æˆ–å¤šæ¬¡ï¼Œä½†ä¸ä¿®æ”¹å˜é‡\n\nFnMutï¼ˆMutable reference capturingï¼‰ä½ ä¼šåœ¨é—­åŒ…å†…ä¿®æ”¹ä¸€ä¸ªå®šä¹‰åœ¨é—­åŒ…å¤–éƒ¨çš„å˜é‡ï¼Œå¯ä»¥è°ƒç”¨ä¸€æ¬¡æˆ–å¤šæ¬¡ï¼Œå°±ç”¨ FnMut\n123456789101112131415struct Person &#123;  first_name: String,  last_name: String,&#125;fn main() &#123;  let mut p1 = Person &#123;    first_name: &quot;Wu&quot;.to_string(),    last_name: &quot;Marnie&quot;.to_string(),  &#125;;  // âœ¨ å¦‚æœä½ éœ€è¦åœ¨é—­åŒ…ä¸­ä¿®æ”¹æŸä¸ªå¤–éƒ¨å˜é‡ï¼Œé‚£ä¹ˆè¿™ä¸ªé—­åŒ…ä¹Ÿéœ€è¦å®šä¹‰æˆ mutable  let mut change_name = |new_last_name: &amp;str| p1.last_name = new_last_name.to_string();  change_name(&quot;Marnieeee&quot;);  println!(&quot;After changed: &#123;&#125;&quot;, p1.last_name);&#125;\n\n\n\nå¦‚ä¸Šæ˜¯æ­£ç¡®è¾“å‡ºï¼Œæˆ‘ä»¬ç°åœ¨ä¿®æ”¹ä¸‹ä¾‹å­ï¼Œæˆ‘ä»¬å†è°ƒç”¨ä¸€æ¬¡ change_name ä¼šå‘ç°æœ‰å¦‚ä¸‹æŠ¥é”™ï¼š\n\ncannot borrow p1.last_name as immutable because it is also borrowed\nè¿™æ˜¯ä½¿ç”¨é—­åŒ…æ—¶éœ€è¦éµå®ˆçš„ä¸€ä¸ªè§„åˆ™ï¼Œå› ä¸ºæˆ‘ä»¬ä¸Šæ–‡è¯´è¿‡ï¼Œé—­åŒ…æœ‰æƒæ•è·å…¶ç¯å¢ƒå†…çš„å˜é‡ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨å¦‚æœå‘ç°è¿˜å­˜åœ¨é—­åŒ…è°ƒç”¨ï¼Œç›¸å½“äºé—­åŒ…è¿˜å­˜åœ¨å¯¹æŸä¸ªå˜é‡çš„å€Ÿç”¨ï¼Œé‚£åœ¨æœ€åä¸€ä¸ªé—­åŒ…è°ƒç”¨ç»“æŸå‰ï¼Œè¿™ä¸ªè¢«å€Ÿç”¨çš„å˜é‡éƒ½ä¸èƒ½è¢«å…¶ä»–åœ°æ–¹å€Ÿç”¨ã€‚\næˆ‘ä»¬å¯ä»¥å°†é—­åŒ…çš„æ“ä½œæ”¾ä¸€èµ·ï¼Œæœ€åè¿›è¡Œè¾“å‡ºå°±éµå¾ªäº†è§„åˆ™ï¼š\n\n\nFnOnceåªèƒ½è°ƒç”¨ä¸€æ¬¡çš„é—­åŒ…ï¼Œè¿™ä¸ªç±»å‹å’Œ FnMut çš„åŒºåˆ«åœ¨äºè°ƒç”¨æ¬¡æ•°ï¼Œå®ƒä»¬éƒ½å¯ä»¥åœ¨å†…éƒ¨ä¿®æ”¹å˜é‡ï¼Œä½† FnOnce åªå…è®¸è°ƒç”¨ä¸€æ¬¡ï¼Œè¿™ä¸ªç±»å‹ä¸€èˆ¬æ˜¯ç»“åˆæˆ‘ä»¬ä¸Šé¢æåˆ°çš„ move è½¬ç§»æ‰€æœ‰æƒçš„åœºæ™¯ï¼Œå› ä¸ºè¢«é—­åŒ…æ•è·çš„å˜é‡çš„æ‰€æœ‰æƒï¼Œéšç€é—­åŒ…çš„æ‰§è¡Œè¢«è½¬ç§»äº†ï¼Œåœ¨é—­åŒ…è°ƒç”¨åä¸å¯è¢«è®¿é—®ï¼Œè€Œæ‰€æœ‰æƒä¹Ÿå°±åªèƒ½è¢«è½¬ç§»ä¸€æ¬¡ï¼Œæ‰€ä»¥éœ€è¦è½¬ç§»æ‰€æœ‰æƒçš„é—­åŒ…éœ€è¦å®šä¹‰ä¸º FnOnceã€‚\nç»ƒä¹ \n\n\n\nnewåˆå§‹åŒ–æ–¹æ³•ï¼Œå°†ä¼ å…¥çš„å›è°ƒå‡½æ•°ï¼ˆå³é—­åŒ…ï¼‰å­˜å…¥ç»“æ„ä½“ä»¥åè°ƒç”¨ï¼Œå¹¶åˆå§‹åŒ–å„å­—æ®µ\nget_pageæ¥æ”¶ user_id å’Œ article_idï¼Œè°ƒç”¨ is_rendered_page åˆ¤æ–­æ˜¯å¦å­˜åœ¨è¿‡\n\nè‹¥å­˜åœ¨ï¼šè¿”å›å­˜ä¸‹æ¥çš„ page_content\nè‹¥ä¸å­˜åœ¨ï¼šè°ƒç”¨ fetch_query æ¸²æŸ“ï¼Œå¹¶æ›´æ–° page_content\n\nis_rendered_pageæ¯”è¾ƒå­˜ä¸‹æ¥çš„ user_id + article_id å’Œ å½“å‰è¯·æ±‚çš„æ˜¯å¦ä¸€è‡´\nrender_pageè°ƒç”¨åˆå§‹åŒ–çš„é—­åŒ…ï¼Œä¼ å…¥ user_id å’Œ article_idï¼Œå¾—åˆ° page_contentï¼Œå¹¶æ›´æ–°æ‰€æœ‰å­—æ®µ\nå®Œæ•´ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576pub fn home_work() &#123;    let mut page_cache = PageCache::new(|user_id: &amp;str, article_id: u32| -&gt; String &#123;        println!(            &quot;Rendering page for user &#123;&#125; and article &#123;&#125;&quot;,            user_id, article_id        );        format!(            &quot;Rendered HTML for user &#123;&#125; and article &#123;&#125;&quot;,            user_id, article_id        )    &#125;);    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user1&quot;, 42));    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user1&quot;, 42));    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user2&quot;, 42));&#125;// éœ€è¦ä½¿ç”¨â€œæ¯”è¾ƒâ€åŠŸèƒ½ï¼Œæ´¾ç”Ÿâ€œæ¯”è¾ƒâ€ç‰¹å¾#[derive(PartialEq)]struct PageCache&lt;T&gt;where    T: Fn(&amp;str, u32) -&gt; String,&#123;    fetch_page: T,    value: Option&lt;String&gt;,    user_id: Option&lt;String&gt;,    article_id: Option&lt;u32&gt;,&#125;/** * é—­åŒ…èƒ½å¹²ä»€ä¹ˆï¼Ÿ * 1. as callback function * 2. capturing surrounding variables (important!!) */impl&lt;T&gt; PageCache&lt;T&gt;where    T: Fn(&amp;str, u32) -&gt; String,&#123;    fn new(fetch_page: T) -&gt; PageCache&lt;T&gt; &#123;        // åˆå§‹åŒ–æ—¶ï¼Œå…ˆå°†ä¼ å…¥çš„é—­åŒ…å­˜ä¸‹æ¥å½“åš fetch_page æ–¹æ³•        // é—­åŒ…æ¥æ”¶ user_id and article_id, è¿”å› page_content        PageCache &#123;            fetch_page,            value: None,            article_id: None,            user_id: None,        &#125;    &#125;    fn is_rendered_page(&amp;self, user_id: &amp;str, article_id: u32) -&gt; bool &#123;        self.article_id.is_some_and(|id| id == article_id)            &amp;&amp; self.user_id.as_deref().is_some_and(|id| id == user_id)    &#125;    fn render_page(&amp;mut self, user_id: &amp;str, article_id: u32) &#123;        self.user_id = Some(user_id.to_string());        self.article_id = Some(article_id);        // self.fetch_page æ˜¯ä¸€ä¸ªé—­åŒ… å³ä¸€ä¸ª function        let page_content = (self.fetch_page)(user_id, article_id);        // println!(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, user_id, article_id, page_content);        self.value = Some(page_content);    &#125;    fn get_page(&amp;mut self, user_id: &amp;str, article_id: u32) -&gt; String &#123;        if !self.is_rendered_page(user_id, article_id) &#123;            self.render_page(user_id, article_id);        &#125;        // unwrap è·å– Option çš„ inner valueï¼Œä½†æ˜¯ä¼šè½¬ç§»æ‰€æœ‰æƒ        // self æ˜¯ mutable çš„ï¼Œmutable ç»“æ„ä½“å†…éƒ¨çš„ fields ä¸å…è®¸è½¬ç§»æ‰€æœ‰æƒ        // æ‰€ä»¥å…ˆ as_ref() å˜æˆæ™®é€šå€Ÿç”¨åè°ƒç”¨ unwrapï¼Œæ­¤æ—¶ å€Ÿç”¨çš„å˜é‡è°ƒç”¨ unwrap è¿”å›çš„è¿˜æ˜¯ä¸ªå€Ÿç”¨çš„å€¼        // å› æ­¤å†ç”¨ clone() å°†å€¼å¤åˆ¶è¿”å›        self.value.as_ref().unwrap().clone()    &#125;&#125;\n\n\n\n\n","slug":"closures","date":"2025-01-16T12:15:31.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"764bca6314ff5edd2be26b3adc313bc1","title":"å® Marcos","content":"Declarative macrosWhat is macro_rules!?macro_rules! ç”¨äºå®šä¹‰å£°æ˜å¼å®ï¼ˆdeclarative macrosï¼‰ï¼Œå®ƒä¸»è¦åŒ…å«ä¸¤ä¸ªéƒ¨åˆ† â€”â€” æ¨¡å¼ + æ‹“å±•çš„ä»£ç \næ¨¡å¼æŒ‡çš„æ˜¯ï¼Œå®ƒå…è®¸å®šä¹‰æŒ‡å®šçš„æ ‡è¯†ï¼ˆtokenï¼‰ï¼Œå½“è°ƒç”¨è€…è¾“å…¥äº†ä¸æŒ‡å®šæ ‡è¯†ç›¸åŒ¹é…çš„å†…å®¹ï¼Œåˆ™å‘½ä¸­è¯¥æ¨¡å¼ã€‚\næ¯ä¸ªæ¨¡å¼å…è®¸å®šä¹‰ä¸ä¹‹åŒ¹é…çš„å¯æ‰§è¡Œä»£ç ï¼Œè¿™è¢«ç§°ä¸ºæ‹“å±•çš„ä»£ç ï¼Œå½“æ¨¡å¼è¢«å‘½ä¸­ä¹‹ååˆ™ä¼šæ‰§è¡Œå…¶æ‹“å±•çš„ä»£ç ã€‚\nè¿™æ˜¯ macro_rules! çš„å·¥ä½œæ¨¡å¼ï¼Œä½¿ç”¨ä¸Šç±»ä¼¼äº match åŒ¹é…çš„å¤šåˆ†æ”¯ã€‚\nmacro_rules!â€˜s Syntax1234567891011// æ³¨é‡Šè´Ÿè´£å¯¼å‡º#[macro_export]macro_rules! macro_name &#123;  \t// pattern æ¨¡å¼ expansion æ‹“å±•çš„ä»£ç   \t(pattern) =&gt; &#123; expansion; &#125;;&#125;// è°ƒç”¨çš„ä¸‰ç§æ–¹å¼macro_name!();macro_name![];macro_name!&#123;&#125;;\n\n\nmarco_export: ä½¿ç”¨è¯¥æ³¨é‡Šå°†å®å¯¼å‡ºï¼Œåªæœ‰è¢«å¯¼å‡ºçš„å®æ‰èƒ½è¢«å½“å‰ä½œç”¨åŸŸä½¿ç”¨æˆ–æ˜¯å¼•å…¥å…¶ä»–ä½œç”¨åŸŸä½¿ç”¨ï¼›\nmacro_nameï¼šå®çš„åå­—ï¼Œè°ƒç”¨æ—¶åŠ æ„Ÿå¹å·è°ƒç”¨ macro_name! ;\npattern: å®šä¹‰éœ€è¦åŒ¹é…çš„è¾“å…¥çš„ç»“æ„ï¼›\nexpansionï¼šå®šä¹‰åŒ¹é…åéœ€è¦çš„ä»£ç ï¼›\n\nPattern matchingä¸Šé¢è¯´äº† pattern æŒ‡çš„æ˜¯å®šä¹‰æŒ‡å®šçš„ tokenï¼ˆæ ‡è¯†ï¼‰è®©è¾“å…¥ï¼ˆinputï¼‰å»åŒ¹é…ï¼š\n1234567891011#[macro_export]macro_rules! greet &#123;    ($name:expr) =&gt; &#123;      println!(&quot;Hello, &#123;&#125;!&quot;, $name);    &#125;;&#125;fn main() &#123;    greet!(&quot;Mark&quot;);    greet!(&quot;Film&quot;);&#125;\n\næ¨¡å¼ä¸­ä½¿ç”¨ $xxx:expr è¿™æ ·çš„è¯­æ³•æ¥å®šä¹‰ï¼Œexpr å¯ä»¥åŒ¹é…ä»»ä½• Rust è¡¨è¾¾å¼ï¼Œé™¤äº†è¿™ä¸ª macro ä¸­è¿˜æä¾›äº†å¤šä¸ªå¯ä»¥ä½¿ç”¨çš„ token æˆ‘ä»¬å¯ä»¥äº†è§£ä¸‹ï¼Œå…·ä½“éœ€è¦ç”¨åˆ°çš„æ—¶å€™å†æŸ¥å°±æ˜¯äº†ã€‚\nToken types\nexpr: Matches any valid Rust expression. This includes literals, variables, function calls, and more.\nstmt: Matches a statement, which can be a full statement like an assignment or a control flow statement (e.g., if, for, etc.).\npat: Matches a pattern, which is used in pattern matching (e.g., in match statements).\nty: Matches a type, such as i32, String, or any user-defined type.\nident: Matches an identifier, which is typically a variable name or function name.\npath: Matches a path, which can be a simple identifier like foo, or fully qualified paths like std::mem::replace.\nmeta: Matches meta items, which are used in attributes (e.g., #[derive(Debug)]).\ntt: Stands for â€œtoken treeâ€ and matches any sequence of tokens. This is the most flexible option and can match anything from expressions to types to identifiers.\nvis: Matches visibility qualifiers (e.g., pub, private, etc.), which control the visibility of items.\n\né™¤äº†æŒ‡å®š token ä¹‹å¤–ï¼Œå®çš„å‚æ•°è¿˜æ˜¯å¯å˜å‚æ•°ï¼ˆä¸å‡½æ•°ä¸ä¸€æ ·ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥å†™å¯¹åº”çš„æˆ–è€…æ˜¯å¤šä¸ªåŒ¹é…æ¥å®ç°å‚æ•°çš„å¯å˜ã€‚\nå¤šä¸ªåŒ¹é…ï¼š123456789101112131415161718fn main() &#123;    greet!();    greet!(&quot;Mark&quot;);    greet!(&quot;Film&quot;);&#125;#[macro_export]macro_rules! greet &#123;    // å…¥å‚ç©º    () =&gt; &#123;        println!(&quot;Hello, world!&quot;);    &#125;;    // å…¥å‚éç©º    ($name:expr) =&gt; &#123;        println!(&quot;Hello, &#123;&#125;!&quot;, $name);    &#125;;&#125;\n\n\nå¯é‡å¤ï¼ˆrepetitionï¼‰å‚æ•°æ¨¡å¼ï¼š123456789101112131415161718192021#[macro_export]macro_rules! create_vec &#123;    ($($value:expr),*) =&gt; &#123;        &#123;            println!(&quot;å¤–å±‚ --- start&quot;);            let mut vec = Vec::new();            $(&#123;                println!(&quot;&#123;&#125;&quot;,$value);                vec.push($value);                println!(&quot;æ¯æ¬¡åŒ¹é…åˆ°çš„è¾“å…¥éƒ½ä¼šæ‰§è¡Œ&quot;);            &#125;)*            println!(&quot;å¤–å±‚ --- end&quot;);            vec        &#125;    &#125;;&#125;fn main() &#123;    let my_vec = create_vec![1, 2, 3];&#125;\n\n$($value:expr), * ä¸­  * è¡¨ç¤º zero or more å¯ä»¥åŒ¹é…0æˆ–å¤šæ¬¡ï¼Œè¿˜å¯ä»¥æ˜¯ + at least one è‡³å°‘åŒ¹é…ä¸€æ¬¡ï¼Œ? zero or one é›¶æ¬¡æˆ–1æ¬¡ã€‚\næ³¨æ„ä¸Šé¢çš„ä»£ç ï¼Œå¯ä»¥çœ‹åˆ° expansion  çš„éƒ¨åˆ†æˆ‘ä»¬æœ‰ä¸¤ä¸ªå¤§æ‹¬å·ï¼Œé‚£æ˜¯å› ä¸ºå®çš„æ¦‚å¿µæœ¬èº«æ˜¯ä¸ºäº†è®©æˆ‘ä»¬å®šä¹‰å¯¹æŒ‡å®šè¾“å…¥çš„å›ºå®šè¡Œä¸ºï¼Œä¹Ÿå°±æ˜¯ expansionï¼Œå› ä¸ºè¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥åœ¨ç¼–è¯‘æœŸé—´å°±ä¼šå°†å®è°ƒç”¨æ›¿æ¢æˆåŒ¹é…åˆ°çš„ expansionã€‚\nå¯¹äº expansion ï¼Œç”±äºä¸åŒçš„å®è°ƒç”¨ä¸Šä¸‹æ–‡ï¼Œæ¯”å¦‚å®ƒåœ¨ä¸€ä¸ªèµ‹å€¼è¯­å¥ä¸­è¢«è°ƒç”¨ let a = macro_name!(); ï¼Œé‚£ expansion çš„æ‰§è¡Œç»“æœå®ƒä¸€å®šæ˜¯ä¸€ä¸ªå€¼ï¼Œä¸€ä¸ªå€¼æ„å‘³ç€å®ƒå¯èƒ½æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼ˆexpressionï¼‰æˆ–ä¸€æ®µåŒ…å«å¤šä¸ªè¯­å¥ï¼ˆstatementï¼‰ä¸”æœ‰è¿”å›å€¼çš„ä»£ç å—ï¼ˆcode blockï¼‰ã€‚å¦‚æœæ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å®è°ƒç”¨ macro_name!();ï¼Œé‚£ä¹ˆ expansion å°±å¯ä»¥æ˜¯ä¸€ä¸ªå•ç‹¬çš„è¯­å¥ï¼Œè¿™å°±æ˜¯ä¸åŒä¸Šä¸‹æ–‡å¯¹ expansion çš„é™åˆ¶ã€‚\nè¯­å¥ï¼ˆstatementsï¼‰æŒ‡çš„æ˜¯ä¸€åˆ‡ä»£è¡¨æŸä¸ªæ“ä½œè¡Œä¸ºçš„ä»£ç å¥å­ï¼Œå¯èƒ½æ˜¯èµ‹å€¼ã€æ‰§è¡Œç­‰ç­‰ï¼Œå…¶ä¸­æœ‰è¿”å›å€¼çš„è¯­å¥è¢«ç§°ä¸ºè¡¨è¾¾å¼ï¼ˆexpressionï¼‰ï¼Œæ¯”å¦‚ a + b / add(1, 2) ï¼Œè€Œç”¨å¤§æ‹¬å·åŒ…è£¹çš„1è‡³å¤šç»„è¯­å¥è¢«ç§°ä¸ºä»£ç å—ï¼ˆcode blockï¼‰ã€‚\nå†è¯´å›ä¸Šé¢ä»£ç ç¤ºä¾‹ï¼Œå¦‚æœ  expansion æ˜¯ä»£ç å—å°±éœ€è¦å†å¥—ä¸Šä¸€å±‚å¤§æ‹¬å·ï¼Œå…¶ä¸­å¯ä»¥ç”¨ $(...)* è¯­æ³•ç³–åŒ…è£¹æ¯æ¬¡åŒ¹é…åˆ°ç¬¦åˆæŒ‡å®šæ¡ä»¶çš„è¾“å…¥ ï¼ˆ$valueï¼‰ æ—¶éœ€è¦æ‰§è¡Œçš„è¯­å¥ï¼Œå®ƒä¼šè¢«æ›¿æ¢æˆç­‰ä»·çš„é…æœ‰ä¸åŒè¾“å…¥çš„å¤šä¸ªè¯­å¥ï¼š\n123456789// æ¯”å¦‚ï¼š create_vec![1, 2, 3]// æ›¿æ¢å‰ï¼š$(println!(&quot;&#123;&#125;&quot;, $value))*// æ›¿æ¢åï¼šprintln!(&quot;&#123;&#125;&quot;, 1);println!(&quot;&#123;&#125;&quot;, 2);println!(&quot;&#123;&#125;&quot;, 3);\n\n\n\nç¼–è¯‘æœŸé—´æ›¿æ¢ä»£ç \n\n\n\n\n\n\n\n\nå†æä¸€ä¸‹\nå®ä¹‹æ‰€ä»¥å¥½ç”¨æ˜¯å› ä¸ºå®ƒåœ¨è¿è¡Œæ—¶ä¸ä¼šäº§ç”ŸæŸè€—ï¼Œå› ä¸ºå£°æ˜å®ä½¿ç”¨çš„åŒ¹é…æ¨¡å¼æ˜¯å®šä¹‰åå°±å›ºå®šäº†çš„ï¼Œç¼–è¯‘æœŸé—´å°±èƒ½å°†æ¯ä¸ªå®è°ƒç”¨ç­‰ä»·æ›¿æ¢æˆå‘½ä¸­åŒ¹é…åçš„æ‹“å±•ä»£ç ã€‚è¿™é‡Œè¯´çš„ä¸ä¼šäº§ç”Ÿè¿è¡Œæ—¶çš„æŸè€—ï¼Œè¯´ç™½äº†å°±æ˜¯ä»£ç åœ¨æ‰§è¡ŒæœŸé—´å¹¶ä¸ä¼šå› ä¸ºé€»è¾‘è€Œå‘ç”Ÿå˜åŒ–ï¼Œæ²¡æœ‰ä¼šå˜çš„é€»è¾‘ã€‚\nProcedural macrosæ´¾ç”Ÿå®ã€å±æ€§å®ã€å‡½æ•°å®\næ´¾ç”Ÿå®æˆ‘ä»¬å¸¸ç”¨çš„ derive åä½¿ç”¨çš„ crate å°±æ˜¯æ´¾ç”Ÿå®ã€‚\næ³¨é‡Šï¼š#[proc_macro_derive]\nå‡½æ•°å®æ³¨é‡Šï¼š#[proc_macro]\nå¸¸ç”¨å‡½æ•°å®ï¼š\n12345678910111213141516171819202122232425#[test]fn macro_fn() &#123;    // è¯»å–æ–‡ä»¶å†…å®¹    let file_content = include_str!(&quot;../Cargo.toml&quot;);    // è·å–ç¯å¢ƒè·¯å¾„    let env_path = env!(&quot;PATH&quot;);    // æ‹¼æ¥å­—ç¬¦ä¸²    let str = concat!(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);    // æ¡ä»¶ç¼–è¯‘    if cfg!(target_os = &quot;mac&quot;) &#123;        //    &#125;    panic!(&quot;manually panic!&quot;);    println!(&quot;111&quot;);&#125;#[test]fn echo() &#123;    // ä»¥åå®ç°çš„ä»£ç     todo!();    unimplemented!();&#125;\n\n\n\nå±æ€§å®æ³¨é‡Šï¼š#[proc_macro_attribute]\nç¼–è¯‘æœŸé—´è®¡ç®—å’Œç”Ÿæˆä»£ç æ´¾ç”Ÿå®ç”¨äºå¤„ç†æ¯”å£°æ˜å®ç»™ä¸ºå¤æ‚çš„ä¸šåŠ¡ï¼Œæ¯ä¸ªè¿‡ç¨‹å®éƒ½å¿…é¡»æœ‰ä¸€ä¸ªå•ç‹¬çš„ crateï¼Œè¢«å½“åšæ’ä»¶ä¸€æ ·åœ¨åˆ«çš„ crate ä¸­ä½¿ç”¨ã€‚æ‰€ä»¥è¿‡ç¨‹å®å’Œå£°æ˜å®ä¸€æ ·ï¼Œéƒ½æ˜¯ç¼–è¯‘æœŸé—´è®¡ç®—å’Œç”Ÿæˆå¯¹åº”çš„ä»£ç å¹¶å°†è°ƒç”¨çš„åœ°æ–¹æ›¿æ¢ï¼Œå¹¶æ— è¿è¡Œæ—¶æŸè€—ã€‚\nç»ƒä¹ \nå…ˆå®šä¹‰ä¸‰ä¸ªå£°æ˜å®çš„å£³å­ï¼š1234567891011121314151617181920fn main() &#123;    assert_eq!(repeat!(&quot;x&quot;, 3), &quot;xxx&quot;);    assert_eq!(sum!(1, 2, 3, 4, 5), 15);    assert_eq!(max_value!(1, 8, 9), 9);&#125;#[macro_export]macro_rules! repeat &#123;    ($value:expr) =&gt; &#123;&#125;;&#125;#[macro_export]macro_rules! sum &#123;    ($value:expr) =&gt; &#123;&#125;;&#125;#[macro_export]macro_rules! max_value &#123;    ($value:expr) =&gt; &#123;&#125;;&#125;\n\n\n\nåˆ†æå¹¶å®ç°å®ï¼š\n1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * repeat!(&quot;x&quot;, 3) * ç¬¬ä¸€ä¸ªå…¥å‚ï¼šå­—ç¬¦æˆ–å­—ç¬¦ä¸² C * ç¬¬äºŒä¸ªå…¥å‚ï¼šæ•°å­— N * è¿”å›ï¼šå°† C é‡å¤ N æ¬¡æ‹¼æ¥ */#[macro_export]macro_rules! repeat &#123;    ($str:expr,$num:expr) =&gt; &#123;&#123;        let mut s = String::from(&quot;&quot;);        for _ in 0..$num &#123;            s.push_str($str);        &#125;        s    &#125;&#125;;&#125;/** * sum!(1, 2, 3, 4, 5) * å…¥å‚ï¼šä¸å›ºå®šæ•°é‡çš„æ•°å­— * è¿”å›ï¼šè¿™äº›æ•°å­—çš„å’Œ */#[macro_export]macro_rules! sum &#123;    ($($value:expr),*) =&gt; &#123;&#123;        let mut v = 0;        $(v=v+$value;)*        v    &#125;&#125;;&#125;/** * max_value!(1, 8, 9) * å…¥å‚ï¼šä¸å›ºå®šæ•°é‡çš„æ•°å­— * è¿”å›ï¼šå…¥å‚ä¸­æœ€å¤§çš„æ•°å­— */#[macro_export]macro_rules! max_value &#123;    ($($value:expr),*) =&gt; &#123;&#123;        let mut max = 0;        $(max=if $value&gt;max &#123;$value&#125; else &#123;max&#125;;)*        max    &#125;&#125;;&#125;\n\n","slug":"marcos","date":"2025-01-13T14:29:24.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"bf66738dcbdc4a39018dfff1579fc70a","title":"ç‰¹å¾ Trait","content":"å­¤å„¿è§„åˆ™impl T for A : ä¸º A å®ç°ç‰¹å¾ T , é‚£ä¹ˆ A æˆ–è€… T è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯åœ¨å½“å‰ä½œç”¨åŸŸä¸­å®šä¹‰çš„ã€‚\n1234fn main &#123;  // âŒ Clone å’Œ String éƒ½æ˜¯æ ‡å‡†åº“ä¸­å®šä¹‰çš„ï¼Œè€Œä¸æ˜¯å½“å‰ crate ä¸­å®šä¹‰çš„ï¼Œæ— æ³•ä½¿ç”¨ impl å…³é”®å­—  impl Clone for String &#123;&#125;&#125;\n\n\nç­¾å signature å’Œé‡è½½ overridetrait ä¸­ï¼Œå¯ä»¥åªå®šä¹‰ç­¾åï¼Œä¹Ÿå¯ä»¥å®šä¹‰æ–¹æ³•çš„é»˜è®¤è¡Œä¸ºã€‚åœ¨å…·ä½“å®ç°ä¸­å®šä¹‰çš„æ–¹æ³•ä¼šé‡è½½ç‰¹å¾ä¸­é»˜è®¤çš„æ–¹æ³•ã€‚\nå½“æˆ‘ä»¬åœ¨è°ƒç”¨æŸä¸ªæ–¹æ³•æ—¶ï¼Œä¼šå…ˆæ‰¾è‡ªèº«ç»“æ„ä½“ä¸­æ˜¯å¦æœ‰å¯¹åº”å®ç°ï¼Œè‹¥æ²¡æœ‰åˆ™å‘ä¸ŠğŸ”¼æ‰¾ç‰¹å¾ä¸­çš„è¯¥æ–¹æ³•ã€‚\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Post ç»“æ„ä½“struct Post &#123;    name: String,    author: String,&#125;// Weibo ç»“æ„ä½“struct Weibo &#123;    username: String,    content: String,&#125;// Summary ç‰¹å¾trait Summary &#123;    fn summarize_author(&amp;self) -&gt; String;    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;Read more from &#123;&#125;...&quot;, self.summarize_author())    &#125;&#125;// ä¸º Post å®ç° Summary ç‰¹å¾impl Summary for Post &#123;    fn summarize_author(&amp;self) -&gt; String &#123;        self.author.clone()    &#125;    // fn summarize(&amp;self) -&gt; String &#123;    //     format!(&quot;æ–‡ç« &#123;&#125;ï¼Œä½œè€…æ˜¯&#123;&#125;&quot;, self.name, self.author)    // &#125;&#125;// ä¸º Weibo å®ç° Summary ç‰¹å¾impl Summary for Weibo &#123;    fn summarize_author(&amp;self) -&gt; String &#123;        format!(&quot;@&#123;&#125;&quot;, self.username)    &#125;    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;&#123;&#125;å‘è¡¨äº†å¾®åš&#123;&#125;&quot;, self.username, self.content)    &#125;&#125;fn main() &#123;    let post = Post &#123;        name: &quot;trait_study&quot;.to_string(),        author: &quot;marnie&quot;.to_string(),    &#125;;   // Post ä¸­åªæœ‰ summarize_author è¿™ä¸€ä¸ªæ–¹æ³•çš„å®ç°   // æ‰€ä»¥å½“è°ƒç”¨ summarize æ–¹æ³•æ—¶ä¼šæ‰¾åˆ°å…¶åŸç‰¹å¾ä¸­çš„å¯¹åº”æ–¹æ³•    println!(&quot;&#123;&#125;&quot;, post.summarize_author());    println!(&quot;&#123;&#125;&quot;, post.summarize());    let weibo = Weibo &#123;        username: String::from(&quot;marnie&quot;),        content: String::from(&quot;æ­£åœ¨å­¦ä¹  Trait ç‰¹å¾&quot;),    &#125;;   // å› ä¸º Weibo ä¸­åˆ†åˆ«å¯¹ä»¥ä¸‹ä¸¤ä¸ªæ–¹æ³•è¿›è¡Œäº†é‡å†™ï¼Œä¼šè¦†ç›–ç‰¹å¾ä¸­çš„é»˜è®¤æ–¹æ³•    println!(&quot;&#123;&#125;&quot;, weibo.summarize_author());    println!(&quot;&#123;&#125;&quot;, weibo.summarize());&#125;\n\n\næ³›å‹çš„ä½¿ç”¨åœ¨ç‰¹å¾ä¸­ä½¿ç”¨æ³›å‹trait AAA&lt;T&gt; ä½¿ç”¨åˆ°ä¼ å…¥çš„æ³›å‹çš„åœ°æ–¹ï¼Œå¿…é¡»æ‰‹åŠ¨æ ‡æ³¨ç±»å‹\nç‰¹å¾æ¥æ”¶çš„æ³›å‹æ˜¯ç»™ç‰¹å¾æ–¹æ³•æ‰€ä½¿ç”¨çš„ï¼Œåœ¨å…·ä½“å®ç°äº†ç‰¹å¾çš„ç»“æ„ä½“è°ƒç”¨æ–¹æ³•æ—¶ï¼Œéœ€è¦æ‰‹åŠ¨çš„æ ‡æ³¨æ³›å‹çš„å®é™…ç±»å‹ï¼Œè®©ç¼–è¯‘å™¨çŸ¥é“è°ƒç”¨å“ªä¸ªç±»å‹å®ç°çš„æ–¹æ³•\n123456789101112131415161718192021222324252627282930313233// ç‰¹å¾ Convert ç”¨äºè½¬æ¢ç±»å‹trait Convert&lt;T&gt; &#123;    fn convert(&amp;self) -&gt; T;&#125;// æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªç»“æ„ä½“æ¥å®ç° Convert ç‰¹å¾// å…ƒç»„ç»“æ„ä½“ï¼ˆtupleï¼‰struct MyInt(i32);// å¯¹ MyInt å®ç°äº†ä¸¤ç§ç±»å‹çš„ç‰¹å¾impl Convert&lt;i32&gt; for MyInt &#123;    fn convert(&amp;self) -&gt; i32 &#123;        self.0 as i32    &#125;&#125;impl Convert&lt;String&gt; for MyInt &#123;    fn convert(&amp;self) -&gt; String &#123;        self.0.to_string()    &#125;&#125;fn main() &#123;    let my_int = MyInt(5);    // å¿…é¡»æ‰‹åŠ¨åŠ ä¸Šç±»å‹æ ‡æ³¨    let output: i32 = my_int.convert();    println!(&quot;&#123;&#125;&quot;, output);    // å¿…é¡»æ‰‹åŠ¨åŠ ä¸Šç±»å‹æ ‡æ³¨    let output: String = my_int.convert();    println!(&quot;&#123;&#125;&quot;, output);&#125;\n\n\n\nåœ¨æ–¹æ³•ä¸­ä½¿ç”¨æ³›å‹impl&lt;T&gt; AAA for BBB ==&gt; impl&lt;T&gt; for BBB\nåœ¨æ–¹æ³•ä¸­ä½¿ç”¨æ³›å‹æŒ‡çš„æ˜¯ â€”â€” å½“æˆ‘ä»¬æŸä¸ªç‰¹å¾æ–¹æ³•éœ€è¦ä½¿ç”¨æ³›å‹ï¼Œå®ƒæœ¬è´¨ä¸Šå°±æ˜¯å°†æŒ‡å®šç±»å‹ä¼ ç»™æ–¹æ³•ï¼Œå’Œç‰¹å¾ã€å’Œç»“æ„ä½“å…¶å®æ— å…³ï¼Œä½¿ç”¨ä¸Šå’Œåœ¨ç»“æ„ä½“ä¸­ä½¿ç”¨æ³›å‹æ˜¯ä¸€ä¸ªæ–¹å¼ã€‚\nä¸€ç§æ›´ç–¯ç‹‚çš„ç”¨æ³•ï¼Œè¯¥æ³›å‹æ—¢æ˜¯æ–¹æ³•éœ€è¦ç”¨çš„ä¹Ÿæ˜¯ç‰¹å¾è¦ç”¨çš„ï¼Œä¼šæ˜¯ä¸‹é¢å®šä¹‰çš„æ ·å­ï¼š\n123impl&lt;T&gt; Convert&lt;T&gt; for MyInt &#123; // ...&#125;\n\nå½“ trait ä¸­åŠ å…¥äº†æ³›å‹ï¼Œè®©æˆ‘ä»¬æ‹¥æœ‰äº†é’ˆå¯¹ä¸åŒåœºæ™¯è¿›è¡Œä¸åŒç±»å‹å®ç°çš„èƒ½åŠ›ã€‚ä½†å¦‚æœæˆ‘ä»¬æƒ³æ§åˆ¶ â€”â€” ç‰¹å¾çš„å®ç°æ˜¯å¯ä»¥æ”¯æŒå¤šç§ç±»å‹çš„ï¼Œä½†åªèƒ½æœ‰ä¸€ç§ç±»å‹çš„å…·ä½“å®ç°ï¼Œè¿™ä¸ªæ—¶å€™æ³›å‹å°±åšä¸äº†è¿™æ ·çš„çº¦æŸäº†ï¼ŒRust é’ˆå¯¹éœ€è¦è¿™ç§çº¦æŸçš„åœºæ™¯æä¾›äº†ä¸€ä¸ªæ–°çš„æ–¹å¼ â€”â€” å…³è”ç±»å‹ã€‚\nå…³è”ç±»å‹å…³è”ç±»å‹æ˜¯åœ¨ç­¾åæ—¶ä¸å›ºå®šç±»å‹ï¼Œåœ¨å®ç°ä¸­æŒ‡å®šéœ€å…³è”çš„ç±»å‹ï¼Œä¸”ä¸èƒ½æœ‰å¤šæ¬¡æŒ‡å®šï¼ˆå³å¤šç§å®ç°ï¼‰ï¼Œç¼–è¯‘å™¨ä¼šåœ¨ç¬¬ä¸€æ¬¡ä»¥åå¾—å®ç°ä¸ŠæŠ¥é”™ã€‚\n123456789101112131415161718192021222324252627282930313233- trait Convert&lt;T&gt; &#123;-     fn convert(&amp;self) -&gt; T;- &#125;+ trait Convert &#123;+     // è¿™æ˜¯å…³è”ç±»å‹ Output+     type Output;+     // Self::Output ä½¿ç”¨å…³è”ç±»å‹+     fn convert(&amp;self) -&gt; Self::Output;+ &#125;struct MyInt(i32);- impl Convert&lt;i32&gt; for MyInt &#123;-     fn convert(&amp;self) -&gt; i32 &#123;-         self.0 as i32-     &#125;- &#125;- impl Convert&lt;String&gt; for MyInt &#123;-     fn convert(&amp;self) -&gt; String &#123;-         self.0.to_string()-     &#125;- &#125;+ impl Convert for MyInt &#123;+     type Output = i32;+     fn convert(&amp;self) -&gt; Self::Output &#123;+         self.0+     &#125;+ &#125;\n\n\n\nå¦‚æœå…³è”äº†ä¸æ­¢ä¸€ä¸ªç±»å‹ï¼Œå°±ä¼šå¾—åˆ°ä¸‹é¢çš„æŠ¥é”™ï¼š\n\nTrait å…³è”ç±»å‹çš„é»˜è®¤ç±»å‹A&lt;B = T&gt; T ä¸º A å…³è”ç±»å‹ B çš„é»˜è®¤ç±»å‹\næˆ‘ä»¬å…ˆå®ç°ä¸€ä¸ªç®€å•çš„ add å‡½æ•°ï¼ŒåŠŸèƒ½æ˜¯å°†ä¸¤ä¸ªå‚æ•°ç›¸åŠ ï¼Œå¹¶è¿”å›ç»“æœï¼š\n1234567891011use std::ops::Add;// ä½œç”¨ï¼šå°†ä¸¤å‚æ•°ç›¸åŠ ï¼Œå¹¶è¿”å›ç»“æœfn add&lt;T: Add&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T &#123;  a + b&#125;fn main() &#123;  let sum = add(10, 20);  println!(&quot;&#123;&#125;&quot;, sum);&#125;\n\n\nè¿™é‡Œç”¨äº†ä¸€ä¸ªå†…éƒ¨ç‰¹å¾ Addï¼Œå®ƒæ”¯æŒæ³›å‹ä¸”é»˜è®¤å€¼ä¸º Selfï¼ŒSelf æŒ‡çš„æ˜¯å½“ä½ æ²¡æœ‰æŒ‡å®šä¼ å…¥ç±»å‹æ—¶å®ƒå°±é»˜è®¤ä¸ºä½ æ­£åœ¨è°ƒç”¨çš„å®ç°äº† Add ç‰¹å¾çš„å½“å‰ç±»å‹ã€‚\n\n12345678910111213141516171819202122// ä¸¾ä¸ªä¾‹å­struct Point &#123;  x: i32,  y: i32,&#125;// âœ¨ å¹¶æ²¡æœ‰æŒ‡å®š Add çš„æ³›å‹ï¼ŒSelf åˆ™ä¸ºå½“å‰ç±»å‹ Pointimpl Add for Point &#123;  // âœ¨ å…³è”ç±»å‹æ²¡æœ‰é»˜è®¤å€¼ï¼Œå¿…é¡»æ‰‹åŠ¨æŒ‡å®š  type Output = Point;    fn add(self, rhs: Self) -&gt; Self::Output &#123;    Point &#123;      x: self.x + rhs.x,      y: self.y + rhs.y,    &#125;  &#125;&#125;let p1 = Point &#123; x: 10, y: 20 &#125;;let p2 = Point &#123; x: 20, y: 30 &#125;;let p3 = p1.add(p2);\n\n\nå†å›åˆ°å‰é¢æˆ‘ä»¬æ‰‹åŠ¨å®ç°çš„ add å‡½æ•°ï¼Œæˆ‘ä»¬å†ç”¨ä¸åŒç±»å‹æ¥è¯•éªŒä¸€ä¸‹æ³›å‹ï¼š\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Add ç‰¹å¾åœ¨ Meters ä¸Šçš„å¤šæ€å®ç°impl Add&lt;Kilometers&gt; for Meters &#123;    type Output = Meters;    fn add(self, rhs: Kilometers) -&gt; Self::Output &#123;        println!(            &quot;&#123;&#125;km, &#123;&#125;m, &#123;&#125;m&quot;,            rhs.0,            rhs.0 * 1000 as f64,            self.0 + (rhs.0 * 1000 as f64)        );        Meters(self.0 + (rhs.0 * 1000 as f64))    &#125;&#125;// Add ç‰¹å¾åœ¨ Meters ä¸Šçš„å¤šæ€å®ç°impl Add for Meters &#123;    type Output = Meters;    fn add(self, rhs: Meters) -&gt; Self::Output &#123;        Meters(self.0 + rhs.0)    &#125;&#125;// Add ç‰¹å¾åœ¨ Kilometers ä¸Šçš„å¤šæ€å®ç°impl Add&lt;Meters&gt; for Kilometers &#123;    type Output = Kilometers;    fn add(self, rhs: Meters) -&gt; Self::Output &#123;        println!(            &quot;&#123;&#125;m, &#123;&#125;km, &#123;&#125;km&quot;,            rhs.0,            rhs.0 / 1000 as f64,            self.0 + (rhs.0 / 1000 as f64)        );        Kilometers(self.0 + rhs.0 / 1000 as f64)    &#125;&#125;// Add ç‰¹å¾åœ¨ Kilometers ä¸Šçš„å¤šæ€å®ç°impl Add for Kilometers &#123;    type Output = Kilometers;    fn add(self, rhs: Self) -&gt; Self::Output &#123;        Kilometers(self.0 + rhs.0)    &#125;&#125;let m = Meters(600 as f64);let km = Kilometers(10 as f64);let total_m = m.clone().add(km.clone());let total_km = km.add(m.clone());println!(&quot;total meters = &#123;:?&#125;m&quot;, total_m.0);println!(&quot;total kilometers = &#123;:?&#125;km&quot;, total_km.0);\n\n\nå½“ Trait ä½œä¸ºå‚æ•°ä¼ é€’æ—¶ï¼Œå¦‚ä½•è¿›è¡Œç±»å‹å£°æ˜ â€”â€” Trait Bound ç‰¹å¾çº¦æŸ\nTrait Bound ç‰¹å¾çº¦æŸå‡è®¾å½“å‰æœ‰ä¸€ä¸ªç‰¹å¾ Summary\n12345trait Summary &#123;  fn summarize(&amp;self) -&gt; String;&#125;// TODOï¼šå®ç° notify å‡½æ•°ï¼Œç”¨äºå®ç°äº† Summary ç‰¹å¾çš„ç±»å‹è¿›è¡Œé€šçŸ¥ï¼ˆè°ƒç”¨ .summarize æ–¹æ³•ï¼‰\n\n&lt;T: U&gt; ç”¨äºçº¦æŸæ³›å‹ T å¿…é¡»æ˜¯å®ç°äº† U ç‰¹æ€§çš„ç±»å‹ï¼Œä½†è¯¥å‡½æ•°åªèƒ½æ¥å—ä¸€ç§æ³›å‹çš„å…·ä½“ç±»å‹\n1234567891011121314// å•ä¸ªå‚æ•°fn notify&lt;T: Summary&gt;(item: &amp;T) &#123;  item.summarize();&#125;// å¤šå‚æ•°fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;  item.summarize();&#125;// çœç•¥ Weiboï¼ŒPost å®šä¹‰ï¼Œå®ƒä»¬å‡æ˜¯å®ç°äº† Summary ç‰¹å¾çš„ç»“æ„ä½“// åªèƒ½ä¼ å…¥ä¸€ç§ç±»å‹notify(Weibo &#123;&#125;, Weibo &#123;&#125;); // âœ…notify(Weibo &#123;&#125;, Post &#123;&#125;); // âŒ\n\n\n\nimpl T ç”¨äºè¡¨ç¤ºå®ç°äº† T ç‰¹æ€§çš„ç±»å‹ï¼Œæ¯”èµ· &lt;T: U&gt; æ›´çµæ´»ï¼Œå¯ä»¥ä¼ å…¥ä¸åŒçš„å®ç°äº†åŒä¸€ç‰¹å¾çš„ç±»å‹\n1234567891011121314151617fn notify(item: &amp;impl Summary) &#123;  item.summarize();&#125;// è¿”å›ç±»å‹åŒæ ·ä¹Ÿèƒ½ä½¿ç”¨fn foo() -&gt; impl Summary &#123;  // ...&#125;// å¤šå‚æ•°fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) &#123;  item.summarize();&#125;// çœç•¥ Weiboï¼ŒPost å®šä¹‰ï¼Œå®ƒä»¬å‡æ˜¯å®ç°äº† Summary ç‰¹å¾çš„ç»“æ„ä½“// å¯ä»¥ä¼ å…¥å¤šä¸ªç±»å‹notify(Weibo &#123;&#125;, Post &#123;&#125;);\n\n\n\nå¤šé‡çº¦æŸ &lt;T: A + B&gt; &#x2F; impl A + B è¡¨ç¤ºåŒæ—¶å®ç°äº† ç‰¹å¾A å’Œ ç‰¹å¾B çš„ç±»å‹where è¯­æ³•ç³–å½“çº¦æŸå¤æ‚æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ where è¯­æ³•ç³–åœ¨å‡½æ•°åé¢å†™ç±»å‹çº¦æŸ\n1234567fn notify2&lt;T, U&gt;(item1: T, item2: U)where  T: Summary + Display,  U: Summary + Display + Debug,&#123;  // ...&#125;\n\n\n\nderive æ´¾ç”Ÿç‰¹æ€§å½“ä¸€ä¸ªç±»å‹æ²¡æœ‰å®ç°æŸä¸ª trait ä½†åˆæƒ³ä½¿ç”¨è¯¥ç‰¹æ€§çš„æ–¹æ³•ï¼Œå¯ä»¥ä½¿ç”¨ #[derive(AAA)] æ´¾ç”Ÿç‰¹æ€§çš„è¯­æ³•ï¼Œä¼šè‡ªåŠ¨å®ç°è¯¥ç‰¹å¾å’Œç»§æ‰¿å…¶æ–¹æ³•çš„é»˜è®¤è¡Œä¸ºã€‚å¦‚æœä¸€ä¸ªç»“æ„ä½“æ´¾ç”Ÿäº†æŸä¸ªç‰¹å¾ï¼Œé‚£ä¹ˆè¯¥ç»“æ„ä½“çš„æ¯ä¸ªå­—æ®µéƒ½éœ€è¦å®ç°äº†è¿™ä¸ªç‰¹å¾ï¼Œä¸ç„¶æ— æ³•å¯¹é½ç‰¹å¾ï¼Œä½¿ç”¨å…¶åŠŸèƒ½ã€‚\nCopy Trait å¤åˆ¶ç‰¹å¾è¿™é‡Œä»‹ç»ä¸€ä¸ªå¸¸ç”¨ç‰¹å¾ Copy ï¼Œé€šå¸¸æˆ‘ä»¬ä½¿ç”¨ let b = aï¼Œå› ä¸ºæ‰€æœ‰æƒçš„æ§åˆ¶ï¼Œèµ‹å€¼ä¼šå°† a çš„å€¼çš„æ‰€æœ‰æƒè½¬ç§»ç»™ç›®æ ‡å˜é‡ bï¼Œåœ¨èµ‹å€¼è¯­å¥ä¹‹åï¼Œa å°†ä¸èƒ½å†è¢«ä½¿ç”¨ã€‚\nä½†å¦‚æœæ˜¯å®ç°äº† Copy ç‰¹å¾çš„ç±»å‹ï¼Œåœ¨èµ‹å€¼æ“ä½œæ—¶ä¼šè°ƒç”¨ Copy ç‰¹å¾çš„åŠŸèƒ½ï¼Œä¸ä¼šè½¬ç§»æ‰€æœ‰æƒï¼Œä¼šå°†å€¼å¤åˆ¶ä¸€ä»½èµ‹å€¼ç»™ç›®æ ‡å˜é‡ï¼Œè¿™æ ·ä¸€æ¥ç­‰å·å·¦è¾¹å’Œå³è¾¹çš„å˜é‡å°±æ˜¯ä¸¤ä¸ªç‹¬ç«‹å˜é‡ï¼Œä¸ä¼šäº’ç›¸å½±å“ã€‚ä¸€èˆ¬å†…ç½®åŸºæœ¬ç±»å‹éƒ½å·²ç»å®ç°äº† Copy ç‰¹å¾ã€‚\n12345678struct Meters(i32);fn main() &#123;    let b = Meters(10);    let a = b;    println!(&quot;&#123;:?&#125;&quot;, b);&#125;\n\n\næˆ‘ä»¬ä½¿ç”¨æ´¾ç”Ÿç‰¹æ€§åŠ ä¸Š Copy ç‰¹å¾ï¼ŒæŠ¥é”™å°±è§£å†³äº†ï¼š\n123456789#[derive(Debug, Copy)]struct Meters(i32);fn main() &#123;    let b = Meters(10);    let a = b;    println!(&quot;&#123;:?&#125;&quot;, b);&#125;\n\n\nç»ƒä¹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960trait Item &#123;    type Output;    fn summarize(&amp;self) -&gt; Self::Output;&#125;struct Apple &#123;    name: String,&#125;struct Weibo &#123;    author: String,    content: String,&#125;impl Item for Apple &#123;    type Output = String;    fn summarize(&amp;self) -&gt; Self::Output &#123;        self.name.to_string()    &#125;&#125;impl Item for Weibo &#123;    type Output = String;    fn summarize(&amp;self) -&gt; Self::Output &#123;        format!(&quot;@&#123;&#125;:&#123;&#125;&quot;, self.author, self.content)    &#125;&#125;struct Container &#123;    // ğŸ’™ æ³¨æ„ç‚¹    items: Vec&lt;Box&lt;dyn Item&lt;Output = String&gt;&gt;&gt;,&#125;impl Container &#123;    fn iterator(&amp;self) &#123;        // ğŸ’™ æ³¨æ„ç‚¹        for item in self.items.iter() &#123;            println!(&quot;&#123;&#125;&quot;, item.summarize())        &#125;    &#125;&#125;fn main() &#123;    let apple = Apple &#123;        name: String::from(&quot;Marnie&quot;),    &#125;;    let weibo = Weibo &#123;        author: String::from(&quot;Marnie&quot;),        content: String::from(&quot;sky...&quot;),    &#125;;    let container = Container &#123;        // ğŸ’™ æ³¨æ„ç‚¹        items: vec![Box::new(apple), Box::new(weibo)],    &#125;;    container.iterator();&#125;\n\n\nTrait Object ç”¨ dyn å…³é”®å­—\nTrait Object æ˜¯åŠ¨æ€ç±»å‹ï¼Œç¼–è¯‘æ—¶æ²¡æœ‰å›ºå®šå¤§å°ï¼Œéœ€è¦ç”¨æ™ºèƒ½æŒ‡é’ˆåŒ…è£¹ï¼ˆèµ‹äºˆå…¶ä¸€ä¸ªæ ˆå†…çš„å›ºå®šå¤§å°ï¼‰ä½¿ç”¨\néå†å‘é‡ Vec ä½¿ç”¨ xxx.iter()\nå«å…³è”ç±»å‹çš„å£°æ˜æ–¹å¼ XXX&lt;Output = T&gt;\n\n","slug":"trait","date":"2025-01-05T14:56:40.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"9fb78f735ce3a3f25bf1795a347b0649","title":"æ™ºèƒ½æŒ‡é’ˆ2 Smart Pointers 2","content":"Rc æ™ºèƒ½æŒ‡é’ˆRust æ‰€æœ‰æƒæœºåˆ¶è¦æ±‚ä¸€ä¸ªå€¼åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œå¦‚æœå‡ºç°éœ€è¦å…±äº«æ•°æ®çš„æƒ…å†µï¼Œä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ªæ•°æ®èµ„æºæ‹¥æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼Œæˆ–è€…è¯´ä¸€ä¸ªèµ„æºéœ€è¦è¢«å¤šä¸ªå¯¹è±¡å¼•ç”¨ï¼ŒRust è®¾è®¡äº† Rc æ™ºèƒ½æŒ‡é’ˆæ¥åšç›¸åº”å®ç°ã€‚\nRc&lt;T&gt;Rc æ˜¯å¼•ç”¨è®¡æ•°ï¼ˆReference countingï¼‰çš„æ„æ€ï¼Œé¡¾åæ€ä¹‰å°±æ˜¯è®°å½•ä¸€ä¸ªæ•°æ®èµ„æºè¢«å¼•ç”¨çš„æ¬¡æ•°ï¼Œä»¥æ­¤æ¥ç¡®å®šè¯¥æ•°æ®æ˜¯å¦æ­£åœ¨è¢«ä½¿ç”¨ã€‚å½“å¼•ç”¨æ¬¡æ•°å½’é›¶åï¼Œå°±ä»£è¡¨è¯¥æ•°æ®ä¸å†è¢«ä»»ä½•ä½¿ç”¨ï¼Œå› æ­¤å¯ä»¥è¢«æ¸…ç†é‡Šæ”¾ã€‚åœ¨ç¦»å¼€æŸä¸ªä½œç”¨åŸŸæ—¶ï¼Œå¦‚å¼•ç”¨å¯¹è±¡è¢« drop äº†é‚£å¼•ç”¨æ¬¡æ•°ä¹Ÿä¼šå¯¹åº”å‡å»ã€‚\nRc::newæˆ‘ä»¬ä½¿ç”¨ Rc::new(data) åˆ›å»ºä¸€ä¸ªæ–°çš„ Rc&lt;T&gt; æ™ºèƒ½æŒ‡é’ˆï¼Œå¹¶èµ‹å€¼ç»™æŸä¸ªå˜é‡ã€‚\nRc::cloneæˆ‘ä»¬ä½¿ç”¨ Rc::clone(Rc&lt;T&gt;) åˆ›å»ºå‡ºä¸€ä¸ªæ–°çš„ Rc&lt;T&gt; æ™ºèƒ½æŒ‡é’ˆï¼ŒæŒ‡å‘å †å†…å­˜ä¸Šé‚£ä¸ªè¢«å…±äº«çš„ Rc&lt;T&gt; æ™ºèƒ½æŒ‡é’ˆã€‚ä½¿ç”¨ clone å¯ä»¥åœ¨ä¸è½¬ç§»æ‰€æœ‰æƒçš„æ¡ä»¶ä¸‹å¾—åˆ° owned valueï¼Œè€Œä¸æ˜¯æŸä¸ªå€¼çš„å¼•ç”¨ã€‚\nOwned Valuelet x = 5 æˆ‘ä»¬æŠŠ x ç§°ä¸º variable å˜é‡ï¼Œ5 ç§°ä¸º owned value å³ æ•°æ®å€¼ï¼Œæ­¤æ—¶ å˜é‡ x æ‹¥æœ‰ æ•°æ® 5 çš„æ‰€æœ‰æƒã€‚\nRc::strong_countæ–°å»ºçš„ Rc&lt;T&gt; æ™ºèƒ½æŒ‡é’ˆåˆå§‹å¼•ç”¨è®¡æ•°ä¸º1ï¼Œæ¯è¢« clone ä¸€æ¬¡å°±ä¼šç›¸åº” +1ï¼Œè°ƒç”¨ Rc::strong(Rc&lt;T&gt;) ä¼šè¿”å›ä¼ å…¥çš„ Rc&lt;T&gt; æ™ºèƒ½æŒ‡é’ˆå½“å‰è¢«å¼•ç”¨çš„æ¬¡æ•°ã€‚\nStrong Reference å¼ºå¼•ç”¨Rc æ˜¯ strong reference å¼ºå¼•ç”¨ï¼Œå¼ºå¼•ç”¨æŒ‡çš„æ˜¯ä¼šå‚ä¸å¼•ç”¨è®¡æ•°çš„å¼•ç”¨ï¼Œå‚ä¸å¼•ç”¨è®¡æ•°æ„å‘³ç€æ¯è¢«å¼•ç”¨ä¸€æ¬¡ï¼Œè¯¥æ•°æ®çš„è¢«å¼•ç”¨æ¬¡æ•°å°±ä¼šåŠ ä¸€ï¼Œåªè¦è¢«å¼•ç”¨æ¬¡æ•°ä¸ä¸º0ï¼Œé‚£è¿™å—æ•°æ®å¯¹åº”çš„èµ„æºå°±ä¸ä¼šè¢«é‡Šæ”¾ã€‚\næ¯”å¦‚ c æ˜¯ä¸€ä¸ª Rc å˜é‡ï¼Œå®ƒè¢« a å’Œ b å¼•ç”¨ç€ï¼Œé‚£åªæœ‰ a å’Œ b çš„å¼•ç”¨éƒ½è¢« drop äº†ä¹‹åï¼Œc å¯¹åº”çš„å†…éƒ¨æ•°æ®èµ„æºæ‰ä¼šè¢«æ¸…ç†ã€‚è¿™é‡Œå°±ä¼šå‡ºç°ä¸€ä¸ªé—®é¢˜ï¼Œå› ä¸ºå¼ºå¼•ç”¨ä¼šå‚ä¸å¼•ç”¨è®¡æ•°ï¼Œå®ƒä¼šç›´æ¥å½±å“åˆ°å†…å­˜é‡Šæ”¾çš„é€»è¾‘ï¼Œå½“äº§ç”Ÿå¾ªç¯å¼•ç”¨æ—¶ï¼Œæ¯”å¦‚ a å¼•ç”¨ bï¼Œc å¼•ç”¨ dï¼Œb å’Œ d ä¹‹é—´å­˜åœ¨äº’ç›¸å¼•ç”¨ï¼Œæœ¬æ¥ a ç¦»å¼€ä½œç”¨åŸŸååº”è¯¥å°† b é‡Šæ”¾çš„ï¼Œä½†æ˜¯å› ä¸º d è¿˜æœ‰å¯¹ b çš„å¼•ç”¨æ‰€ä»¥è¿™å—èµ„æºå¹¶ä¸èƒ½é‡Šæ”¾ï¼ŒåŒæ ·çš„ c ç¦»å¼€ä½œç”¨åŸŸååº”è¯¥å°† d é‡Šæ”¾çš„ï¼Œä½† d è¿˜å­˜åœ¨è¢« b å¼•ç”¨ç€ä¹Ÿæ— æ³•è¢«é‡Šæ”¾ï¼Œè¿™å°±ä¼šäº§ç”Ÿå†…å­˜æ³„æ¼é—®é¢˜ã€‚ä¸ºäº†é¿å…å†…å­˜æ³„æ¼ï¼Œå½“æˆ‘ä»¬é‡åˆ°å¾ªç¯å¼•ç”¨çš„åœºæ™¯æ—¶æˆ‘ä»¬éœ€è¦ç”¨ weak reference å¼±å¼•ç”¨æ¥æ›¿ä»£ï¼Œä¸‹é¢è¯´æ˜ä¸€ä¸‹ç›¸å…³ç”¨æ³•ã€‚\nWeak Reference å¼±å¼•ç”¨Rc::downgradeä½¿ç”¨ Rc::downgrade(&amp;Rc&lt;T&gt;) å¾—åˆ°ä¸€ä¸ª Rc å¼•ç”¨çš„å¼±å¼•ç”¨ï¼Œå¼±å¼•ç”¨ä¸å‚ä¸å¼•ç”¨è®¡æ•°ï¼Œå®ƒåªæ˜¯ Rc åœ¨å¤„ç†å¾ªç¯å¼•ç”¨ä¸Šçš„ä¸€ä¸ªè§£å†³æ–¹æ¡ˆã€‚è€Œä¹Ÿå› ä¸ºä¸å‚ä¸å¼•ç”¨è®¡æ•°ï¼Œæ‰€ä»¥æ— æ³•ä¿è¯è¢«å¼•ç”¨çš„å¯¹è±¡ä¸€å®šæ˜¯å­˜åœ¨çš„ï¼Œå½“éœ€è¦è®¿é—®å®ƒå¯¹åº”çš„æ•°æ®æ—¶ï¼Œéœ€è¦ä½¿ç”¨ xx.upgrade() å°†å…¶è½¬æ¢ä¸ºå¼ºå¼•ç”¨ç±»å‹ï¼Œä¸”è¯¥å¼ºå¼•ç”¨è¢«å¼•ç”¨çš„å¯¹è±¡è¿˜å­˜åœ¨æ—¶ï¼Œæ‰å¯ä»¥è®¿é—®ã€‚\n12345678910111213let t = Rc::new(String::from(&quot;Hello&quot;));let weak_t = Rc::downgrade(&amp;t);// upgrade å¾—åˆ°å¼ºå¼•ç”¨çš„å¯¹è±¡match weak_t.upgrade() &#123;  // è‹¥å¼ºå¼•ç”¨å¯¹è±¡è¿˜å­˜åœ¨  Some(t) =&gt; &#123;    println!(&quot;&#123;&#125;&quot;, t);  &#125;  // å¼ºå¼•ç”¨å¯¹è±¡ä¸å­˜åœ¨  _ =&gt; &#123;&#125;&#125;;\n\nå…±äº«èµ„æºä¹‹åè¿˜å®‰å…¨ä¹ˆï¼Ÿæˆ‘ä»¬ä¹‹å‰å­¦ä¹ è¿‡ï¼ŒRust ä¸­è®¾è®¡æ‰€æœ‰æƒæœºåˆ¶å°±æ˜¯ä¸ºäº†ä¿è¯æ•°æ®èµ„æºçš„ä½¿ç”¨å®‰å…¨ï¼Œä¸€ä¸ªæ•°æ®èµ„æºåªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œå°±èƒ½è§„é¿æ‰å¯¹ä¸€ä¸ªæ•°æ®åŒæ—¶è¿›è¡Œè¯»å†™çš„çŠ¶å†µã€‚\nè€Œä¹Ÿæ˜¯å› ä¸ºæ‰€æœ‰æƒçš„é™åˆ¶ï¼Œåœ¨å¾ˆå¤šå®é™…åœºæ™¯ä¸­ï¼Œä¼šè®©å¼€å‘è€…å› ä¸ºæ‰€æœ‰æƒè½¬ç§»çš„è§„åˆ™è€Œå¤´ç–¼ï¼Œå¯¼è‡´ä»£ç æ€»æ˜¯æ— æ³•ç¼–è¯‘é€šè¿‡ã€æŠ¥é”™ã€‚äºæ˜¯ä¹ï¼ŒRc æ™ºèƒ½æŒ‡é’ˆçš„è¯ç”Ÿè®©å¼€å‘è€…å¯ä»¥æ›´è½»æ¾çš„å®ç°å¯¹ä¸€ä¸ªæ•°æ®èµ„æºçš„å…±äº«ä¸”ä¸è¿èƒŒæ‰€æœ‰æƒè§„åˆ™çš„åº•å±‚åŸå›  â€”â€” æ•°æ®è¯»å†™å®‰å…¨ï¼Œå®ƒæä¾›äº†â€œåˆ›å»ºæŒ‡å‘åŒä¸€å—èµ„æºçš„å¤šä¸ªæŒ‡é’ˆâ€çš„èƒ½åŠ›ï¼Œä»¥åŠä¸€äº›ç›¸å…³çš„åŠŸèƒ½ï¼ˆå¦‚ï¼šå¼•ç”¨è®¡æ•°ï¼‰ã€‚æŸ¥çœ‹ Rc çš„å†…éƒ¨å®ç°å°±å¯ä»¥å‘ç°ï¼Œå®ƒåœ¨åˆ›å»ºæ—¶å…¶å®æ˜¯æŠŠæ•°æ®è£…åœ¨äº†ä¸€ä¸ª Box æ™ºèƒ½æŒ‡é’ˆä¸­ï¼ˆè®©ä¸ç¡®å®šå¤§å°çš„æ•°æ®ç±»å‹å˜æˆæœ‰å¤§å°çš„æ•°æ®ç±»å‹ï¼Œæœ‰å¤§å°çš„æ•°æ®ç±»å‹æŒ‡çš„æ˜¯ä¸ºå…¶åœ¨æ ˆä¸Šç”³è¯·ä¸€å—ç©ºé—´ï¼Œå¹¶åœ¨æ ˆä¸Šæ‹¥æœ‰ä¸€ä¸ªå›ºå®šå¤§å°çš„æŒ‡é’ˆæŒ‡å‘è¿™å—å†…å­˜ï¼‰ï¼Œç„¶ååˆåœ¨å¤–é¢å¥—äº†ä¸€å±‚è‡ªå·±çš„å£³ï¼Œè€Œåœ¨ Rc æ™ºèƒ½æŒ‡é’ˆè¿™ä¸€å±‚å¹¶æ²¡æœ‰æä¾›ä¿®æ”¹å†…éƒ¨æ•°æ®çš„æ–¹æ³•ï¼Œæ‰€ä»¥å³ä½¿æ˜¯å…±äº«èµ„æºï¼Œå¤šä¸ªå¯¹è±¡å¯ä»¥è®¿é—®ä¸€å—å†…å­˜èµ„æºï¼Œå†…å­˜ä¸­çš„æ•°æ®ä¹Ÿè¿˜æ˜¯å®‰å…¨çš„ï¼Œå®ƒåªæ˜¯ä¸€ä¸ªä¸å¯å˜çš„å¼•ç”¨ã€‚\nä½†æ˜¯å¾€å¾€ï¼Œéœ€è¦ share data çš„åœºæ™¯ å’Œ ä¿®æ”¹çš„åœºæ™¯ éƒ½æ˜¯ä¼´éšå‡ºç°çš„ï¼Œæˆ‘ä»¬é‡åˆ° å…±äº« + ä¿®æ”¹ æ—¶éœ€è¦é…åˆ RefCell ä½¿ç”¨ã€‚\nRefCellä¸€èˆ¬åœ¨å…±äº«æ•°æ®çš„åœºæ™¯ä¸‹ï¼Œå¦‚æœè¿˜éœ€è¦æ”¯æŒå¯¹åŸæ•°æ®è¿›è¡Œä¿®æ”¹ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ RefCellã€‚RefCell æ˜¯è®©ä½ æ‹¥æœ‰å¯¹æ•°æ®ä¿®æ”¹èƒ½åŠ›çš„ç»“æ„ä½“ï¼Œå³ä¾¿è¿™ä¸ªæ•°æ®æ˜¯ immutable çš„ã€‚å®ƒå’Œå¯å˜å¼•ç”¨çš„åŒºåˆ«æ˜¯ï¼Œå¯å˜å¼•ç”¨ä¾ç„¶éµå®ˆä¸€ä¸ªæ‰€æœ‰è€…çš„åŸåˆ™ï¼Œä¸€ä¸ªæ•°æ®çš„å¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨æ˜¯ä¸èƒ½åŒæ—¶å­˜åœ¨çš„ã€‚æˆ‘ä»¬å¯ä»¥çœ‹ä¸‹ä¾‹å­ï¼š\n\nå¦‚æŠ¥é”™æ‰€ç¤ºï¼Œå› ä¸ºå¼•ç”¨æœ¬èº«è¿˜æ˜¯éµå®ˆ ownership çš„åŸåˆ™ï¼Œä¸å¯èƒ½åŒæ—¶å­˜åœ¨ä¸¤ç§ç±»å‹çš„å¼•ç”¨ï¼Œè¿™æ˜¯è¿èƒŒæ•°æ®å®‰å…¨çš„ï¼Œåœ¨ç¼–è¯‘æ—¶å°±å¯ä»¥æ ¡éªŒå‡ºæ¥ã€‚è¯´å› RefCell ï¼Œæˆ‘ä»¬çœ‹åˆ°å‰é¢å¼•ç”¨å­˜åœ¨ç€ä¸¥æ ¼çš„å€Ÿç”¨å…³ç³»ï¼Œå½“æˆ‘ä»¬éœ€è¦å€Ÿç”¨çš„åœ°æ–¹å˜å¤šæ—¶ï¼Œå°±ä¼šå¾ˆéš¾åœ¨å†™ä»£ç æ—¶å°±æ•´ç†å‡ºæ˜ç¡®çš„å€Ÿç”¨å…³ç³»ã€‚æ­¤æ—¶å°±å¯ä»¥ç”¨ RefCellï¼Œå®ƒæ²¡æœ‰ç¼–è¯‘æ—¶çš„å€Ÿç”¨å…³ç³»æ ¡éªŒï¼Œè€Œæ˜¯è¿è¡Œæ—¶æ ¡éªŒï¼Œä»‹ç»ä¸‹å®ƒçš„å¸¸ç”¨å†…å®¹ã€‚\nRefCell::newåˆ›å»ºä¸€ä¸ªæ–°çš„å†…éƒ¨å¯å˜çš„ RefCell ç»“æ„ä½“\n123use std::cell::RefCell;let data = RefCell::new(5);\n\nborrow()å¾—åˆ°æŸä¸ª RefCell çš„ä¸å¯å˜å€Ÿç”¨\n1let r1 = data.borrow();  // Immutable borrow\n\nborrow_mut()å¾—åˆ°æŸä¸ª RefCell çš„å¯å˜å€Ÿç”¨\n12let mut r2 = data.borrow_mut();  // Mutable borrow*r2 += 1; // Modify through mutable borrow\n\nRefCell çš„é™åˆ¶RefCell ä¹Ÿæœ‰ä¸€ä¸ªä½¿ç”¨è§„åˆ™ï¼Œåœ¨è¿è¡Œæ—¶ä¸èƒ½åŒæ—¶å­˜åœ¨ç€å¯å˜å€Ÿç”¨å’Œä¸å¯å˜å€Ÿç”¨ã€‚\nå¦‚ä¸‹å›¾çš„ç¤ºä¾‹ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è™½ç„¶æˆ‘ä»¬åˆ›å»ºäº†å¯å˜å€Ÿç”¨å’Œä¸å¯å˜å€Ÿç”¨ï¼Œå¹¶æœ‰åŒæ—¶å­˜åœ¨çš„æ—¶åˆ»ï¼Œä½†è¿™å¹¶æ²¡æœ‰è§¦å‘ç¼–è¯‘æŠ¥é”™ï¼š\n\næˆ‘ä»¬è¿è¡Œä»£ç ï¼Œå¯ä»¥çœ‹åˆ°æŠ¥é”™ä¿¡æ¯ â€œalready borrowedâ€ï¼š\n\nInterior Mutability å†…éƒ¨å¯å˜æ€§å†…éƒ¨å¯å˜æ€§æŒ‡çš„æ˜¯å³ä½¿å˜é‡æœ¬èº«å®šä¹‰çš„æ˜¯éå¯å˜å˜é‡ï¼Œä½¿ç”¨ RefCell ä¹Ÿèƒ½æ”¹å˜å…¶å†…éƒ¨çš„æ•°æ®ã€‚\nç»ƒä¹ \nå®ç°ï¼š\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091use std::&#123;    cell::RefCell,    rc::&#123;Rc, Weak&#125;,&#125;;fn main() &#123;    home_work();&#125;#[derive(Debug)]struct User &#123;    name: String,    // friends ç”¨æˆ·åˆ—è¡¨ Vec&lt;User&gt;    // aã€b å­˜åœ¨äº’ç›¸å¼•ç”¨ éœ€è¦å®šä¹‰æˆ Weak æ™ºèƒ½æŒ‡é’ˆ Vec&lt;Weak&lt;User&gt;&gt;    // aã€b çš„ friends éœ€è¦æœ‰å¯å˜æ€§ Vec&lt;Weak&lt;RefCell&lt;User&gt;&gt;&gt;    friends: RefCell&lt;Vec&lt;Weak&lt;User&gt;&gt;&gt;,&#125;impl User &#123;    fn new(name: &amp;str) -&gt; Rc&lt;User&gt; &#123;        Rc::new(User &#123;            name: String::from(name),            friends: RefCell::new(vec![]),        &#125;)    &#125;    // å› ä¸ºæˆ‘ä»¬éœ€è¦æ‹¿åˆ° user å†…éƒ¨çš„ friends æ•°æ®ï¼Œæ‰€ä»¥æ­¤æ—¶éœ€è¦ç”¨ Rc è€Œä¸æ˜¯ Weakï¼ŒWeak æ— æ³•å¾—åˆ°å†…éƒ¨æ•°æ®    fn add_friend(self: &amp;Rc&lt;User&gt;, other: Rc&lt;User&gt;) &#123;        // éœ€è¦æ£€æŸ¥otherå’Œselfæ˜¯å¦å·²ç»æ˜¯æœ‹å‹ï¼Œè‹¥ä¸æ˜¯åˆ™pushè¿›friendsåˆ—è¡¨        // å¦‚ä½•æ£€æŸ¥ friends åˆ—è¡¨ï¼Œå·²çŸ¥ friends åˆ—è¡¨æ˜¯ä¸€ä¸ª Weak&lt;User&gt; list        let weak_other = Rc::downgrade(&amp;other.clone());        let is_friend = self            .friends            .borrow()            .iter()            .any(|user| weak_other.ptr_eq(user));        if is_friend &#123;            println!(&quot;&#123;&#125; and &#123;&#125; are already friends.&quot;, self.name, other.name);            return;        &#125;        if !is_friend &#123;            println!(&quot;&#123;&#125; add friend &#123;&#125;&quot;, self.name, other.name);            // è‹¥ä¸æ˜¯æœ‹å‹ï¼Œæ›´æ–° friends åˆ—è¡¨            self.friends.borrow_mut().push(weak_other);            other.friends.borrow_mut().push(Rc::downgrade(self));        &#125;    &#125;    fn list_friends(self: &amp;Rc&lt;User&gt;) &#123;        let mut output = String::from(format!(&quot;The friends of &#123;&#125; are &quot;, self.name).as_str());        for item in self.friends.borrow().iter() &#123;            match item.upgrade() &#123;                Some(friend) =&gt; output.push_str(format!(&quot;&#123;&#125;,&quot;, friend.name).as_str()),                None =&gt; &#123;&#125;            &#125;        &#125;        output.pop();        println!(&quot;&#123;&#125;&quot;, output);    &#125;&#125;/** * å®ç°ä¸€ä¸ªç®€å•çš„ç¤¾äº¤ç½‘ç»œç³»ç»Ÿï¼ŒåŒ…å«ç”¨æˆ·å’Œæœ‹å‹çš„å…³ç³»ã€‚ * ç”¨æˆ·ç»“æ„ï¼šæ¯ä¸ªç”¨æˆ·æ‹¥æœ‰ä¸€ä¸ªåå­—å’Œä¸€ä¸ªæœ‹å‹åˆ—è¡¨ * æ·»åŠ æœ‹å‹ï¼šæ”¯æŒåœ¨ä¸¤ä¸ªç”¨æˆ·ä¹‹é—´å»ºç«‹æœ‹å‹å…³ç³» * å±•ç¤ºæœ‹å‹å…³ç³»ï¼šèƒ½å¤Ÿå±•ç¤ºæ¯ä¸ªç”¨æˆ·çš„æœ‹å‹åˆ—è¡¨ * å¾ªç¯å¼•ç”¨ï¼šå¤„ç†ç”¨æˆ·ä¹‹é—´çš„åŒå‘å¼•ç”¨ï¼Œç¡®ä¿ä¸äº§ç”Ÿå¾ªç¯å¼•ç”¨ */fn home_work() &#123;    let a = User::new(&quot;Milk&quot;);    let b = User::new(&quot;Mark&quot;);    let c = User::new(&quot;Film&quot;);    a.add_friend(b.clone());    a.add_friend(c.clone());    b.add_friend(a.clone());    b.add_friend(c.clone());    c.add_friend(a.clone());    c.add_friend(b.clone());    a.list_friends();    b.list_friends();    c.list_friends();    // println!(&quot;a = &#123;:?&#125;&quot;, a);    // println!(&quot;b = &#123;:?&#125;&quot;, b);    // println!(&quot;c = &#123;:?&#125;&quot;, c);    // println!(&quot;a rc = &#123;:?&#125;&quot;, Rc::strong_count(&amp;a));    // println!(&quot;b rc = &#123;:?&#125;&quot;, Rc::strong_count(&amp;b));    // println!(&quot;c rc = &#123;:?&#125;&quot;, Rc::strong_count(&amp;c));&#125;\n\nè¿è¡Œç»“æœï¼š\n\n","slug":"smart-pointers-2","date":"2024-12-05T03:36:40.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"be46c1c387f4b8a2a5d0ca8494de6c20","title":"ç”Ÿå‘½å‘¨æœŸ Lifetime","content":"ä½œç”¨ç”Ÿå‘½å‘¨æœŸå³æŒ‡ä¸€ä¸ªå˜é‡çš„æœ‰æ•ˆä½œç”¨èŒƒå›´ï¼Œå®ƒå’Œ Scope çš„æ¦‚å¿µå¬èµ·æ¥ä¼šæœ‰ç‚¹ç±»ä¼¼ã€‚Scopeï¼ˆä½œç”¨åŸŸï¼‰è§„å®šäº†å˜é‡èƒ½è¢«è®¿é—®çš„èŒƒå›´ï¼Œè¶…å‡ºäº†å®šä¹‰ä½œç”¨åŸŸçš„åœ°æ–¹æ˜¯ä¸èƒ½è®¿é—®ä½œç”¨åŸŸå†…å®šä¹‰çš„å˜é‡çš„ã€‚è€Œ Lifetimeï¼ˆç”Ÿå‘½å‘¨æœŸï¼‰æ˜¯é’ˆå¯¹å¼•ç”¨å˜é‡çš„ï¼Œå®ƒè¡¨ç¤ºä¸€ä¸ªå¼•ç”¨å˜é‡å¯å­˜æ´»çš„èŒƒå›´ï¼Œç®€å•è¯´ä¹Ÿå°±æ˜¯ï¼Œå¦‚æœæˆ‘å‹æ ¹ä¸å­˜åœ¨å¼•ç”¨çš„å˜é‡ï¼Œé‚£æˆ‘éµå¾ªä½œç”¨åŸŸçš„é™åˆ¶å°±å¤Ÿç”¨äº†ã€‚ä½†æ˜¯ä¸€æ—¦å‡ºç°äº†å¼•ç”¨å’Œè¢«å¼•ç”¨çš„å…³ç³»ï¼Œå•çº¯ä½œç”¨åŸŸçš„æ¦‚å¿µä¸å¤Ÿä½¿ç”¨ï¼Œå¯èƒ½ä¼šäº§ç”Ÿæ‚¬å‚å¼•ç”¨ä¹‹ç±»çš„é—®é¢˜ï¼Œäºæ˜¯ Rust ä¸ºäº†ç¡®ä¿æ‰€æœ‰æ“ä½œéƒ½æ˜¯å†…å­˜å®‰å…¨çš„ï¼Œåˆ¶å®šäº†ç”Ÿå‘½å‘¨æœŸçš„ä¸€å¥—æ¦‚å¿µã€‚\næ‚¬å‚æŒ‡é’ˆ Dangling Pointeræ‚¬å‚æŒ‡é’ˆæŒ‡çš„æ˜¯å¼•ç”¨äº†å†…å­˜å·²è¢«é‡Šæ”¾çš„å˜é‡ï¼Œå¦‚ä¸‹ï¼š\n12345678910111213fn main() &#123;    let r;    &#123;        let x = 5;        r = &amp;x;        // ğŸŒŸ drop(x) è¿™é‡Œåœ¨ç¦»å¼€ä»£ç å—å‰æœ‰ä¸€æ­¥éšè—çš„è‡ªåŠ¨é‡Šæ”¾ x    &#125;    // r æŒ‡å‘çš„å¼•ç”¨ x åœ¨ç¦»å¼€ä»£ç å—åå°±ä¼šè¢«é‡Šæ”¾    // åˆ™ä»¥ä¸‹ä»£ç è®¿é—® r å³äº§ç”Ÿäº†ä¸€ä¸ªæ‚¬å‚æŒ‡é’ˆï¼ˆdangling pointerï¼‰    // â€”â€” è®¿é—®äº†å·²è¢«é‡Šæ”¾å†…å­˜çš„å˜é‡    println!(&quot;This is a dangling pointer &amp;r &#123;&#125;&quot;, &amp;r);&#125;\n\næ‚¬å‚å¼•ç”¨çš„æœ¬è´¨æ˜¯å˜é‡çš„å­˜æ´»æ—¶é—´ï¼Œä¹Ÿå¯ä»¥è¯´æ˜¯ä½œç”¨åŸŸé“¾é•¿åº¦ï¼Œé€šå¸¸æ¥è¯´ï¼Œå­˜æ´»æ—¶é—´æ›´é•¿çš„å˜é‡å»å¼•ç”¨æ¯”å®ƒå­˜æ´»æ—¶é—´çŸ­çš„å˜é‡å°±ä¼šå®¹æ˜“å‘ç”Ÿè¿™ç±»é—®é¢˜ï¼ŒRust ç¼–è¯‘æœŸé—´å°±ä¼šæ£€æŸ¥å‡ºæ¯ä¸ªå˜é‡çš„æœ‰æ•ˆä½œç”¨èŒƒå›´ï¼Œæ¥é¿å…è¿™ç±»å¼‚å¸¸ã€‚\nå‡½æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸæˆ‘ä»¬æ¥å®ç°ä¸€ä¸ªå‡½æ•° longerï¼Œæ¥æ”¶ä¸¤ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œç„¶åè¿”å›é•¿åº¦æ›´å¤§çš„å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼š\n1234567891011121314fn longer(a: &amp;str, b: &amp;str) -&gt; &amp;str &#123;    if a.len() &gt; b.len() &#123;        a    &#125; else &#123;        b    &#125;&#125;fn main() &#123;    let s1 = String::from(&quot;Hello&quot;);    let s2 = &quot;Rust&quot;;    let s3 = longer(s1.as_str(), s2);    println!(&quot;The longer string is &#123;&#125;&quot;, s3);&#125;\n\næˆ‘ä»¬å¾—åˆ°å¦‚å›¾çš„æŠ¥é”™æç¤ºï¼š\n\nMissing lifetime specifier ç¼ºå°‘ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆï¼Ÿæˆ‘ä»¬ä¸Šæ®µæœ‰è®²è¿‡ï¼ŒRust éœ€è¦ç¡®ä¿æ‰€æœ‰æ“ä½œéƒ½æ˜¯å†…å­˜å®‰å…¨ã€‚è€Œå¦‚ä½•ç¡®ä¿ï¼Ÿå°±ä¼šéœ€è¦è¶³å¤Ÿçš„ä¿¡æ¯æ¥åˆ†æç”Ÿå‘½å‘¨æœŸï¼Œç¡®ä¿åªä¼šæœ‰çŸ­ç”Ÿå‘½å‘¨æœŸå¼•ç”¨é•¿ç”Ÿå‘½å‘¨æœŸçš„æƒ…å†µã€‚æ‰€ä»¥ï¼Œåœ¨ Rust ä¸­æ¯ä¸ªå˜é‡éƒ½ä¼šæœ‰å®ƒè‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸï¼Œä»£è¡¨å®ƒèƒ½å­˜æ´»å¤šä¹…ã€‚\né‚£ä¹ˆè®²å›æˆ‘ä»¬ä¸Šé¢çš„ longer å‡½æ•°ï¼Œå‡½æ•°å‚æ•°æ˜¯ä¸¤ä¸ªå˜é‡ a å’Œ bï¼Œå¦‚æœè¯¥å‡½æ•°æ²¡æœ‰è¿”å›å€¼çš„æƒ…å†µä¸‹ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªå…¥å‚å¼•ç”¨åœ¨å‡½æ•°æ‰§è¡Œå®Œæˆåå°±æ— æ³•è¢«è®¿é—®äº†ï¼Œè¿™æ˜¯å¯ä»¥ç†è§£çš„ã€‚ä½†æˆ‘ä»¬ç°åœ¨ç»™å‡½æ•°æŒ‡å®šäº†è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ç±»å‹çš„å˜é‡ï¼Œæ­¤æ—¶ Rust ç¼–è¯‘å™¨å¹¶ä¸èƒ½åˆ†æå‡ºåˆ°åº•æ˜¯è¿”å›å…¥å‚ a è¿˜æ˜¯å…¥å‚ b è¿˜æ˜¯åˆ«çš„ä»€ä¹ˆæƒ…å†µï¼Œè¿™äº›éƒ½æ˜¯è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šçš„ï¼Œè¿™å°±å¯¼è‡´äº†åœ¨é™æ€ç¼–è¯‘æœŸé—´ Rust ç¼–è¯‘å™¨åˆ¤æ–­ä¸å‡ºè¿”å›å€¼æ“ä½œå†…å­˜æ˜¯å¦æ˜¯å®‰å…¨çš„ï¼Œè¿™ç§çŠ¶å†µå¯¹ Rust æ¥è¯´æ˜¯ä¸å…è®¸çš„ã€‚\näºæ˜¯å°±éœ€è¦å¼€å‘è€…æ‰‹åŠ¨çš„æ˜¾å¼æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼Œè®©ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶è‡³å°‘äº†è§£è¿”å›çš„å˜é‡å¯¹åº”çš„æ˜¯å“ªä¸ªç”Ÿå‘½å‘¨æœŸï¼Œä»¥æ­¤æ¥é€šè¿‡ç¼–è¯‘æœŸé—´çš„å®‰å…¨æ£€æŸ¥ã€‚\nğŸ“¢ æ³¨æ„ï¼Œç”Ÿå‘½å‘¨æœŸæ ‡æ³¨å¹¶ä¸ä¼šå¯¹å˜é‡çš„å®é™…ç”Ÿå‘½å‘¨æœŸé€ æˆä»»ä½•å½±å“ï¼Œä»…æ˜¯å‘ŠçŸ¥ç¼–è¯‘å™¨åŠé€šè¿‡ç¼–è¯‘æœŸé—´æ£€æŸ¥ã€‚\nç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ Lifetime Specifierå†™æ³•ï¼šåŠä¸ªå•å¼•å· &#39;a\n123&amp;i32 // ä¸€ä¸ªå¼•ç”¨&amp;&#x27;a i32 // å…·æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„å¼•ç”¨&amp;&#x27;a mut i32 // å…·æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„å¯å˜å¼•ç”¨\n\næˆ‘ä»¬æ¥ä¿®æ”¹ä¸‹ longer å‡½æ•°ï¼Œå¯¹å®ƒåŠ ä¸Šæ˜¾å¼çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼š\n1234567891011121314151617// æ˜¾å¼çš„å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œa,b,è¿”å›å€¼ éƒ½å±äºåŒä¸€ä¸ªç”Ÿå‘½å‘¨æœŸ// å› ä¸ºè¿”å›å€¼è¦ä¹ˆæ˜¯ a è¦ä¹ˆæ˜¯ b// ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨å’Œæ³›å‹ä¸€æ ·ï¼Œä¹Ÿéœ€è¦å‰ç½®å£°æ˜ &lt;&#x27;a&gt; åæ‰èƒ½ä½¿ç”¨fn longer&lt;&#x27;a&gt;(a: &amp;&#x27;a str, b: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;    if a.len() &gt; b.len() &#123;        a    &#125; else &#123;        b    &#125;&#125;fn main() &#123;    let s1 = String::from(&quot;Hello&quot;);    let s2 = &quot;Rust&quot;;    let s3 = longer(s1.as_str(), s2);    println!(&quot;The longer string is &#123;&#125;&quot;, s3);&#125;\n\nè¿è¡Œç»“æœï¼Œå¦‚ä¸‹ï¼š\n\né‚£ä¹ˆå¯èƒ½ä¼šæœ‰ç–‘æƒ‘ï¼Œä¸ºä»€ä¹ˆæˆ‘ä»¬ä¹‹å‰çš„ç»ƒä¹ ä¸­ï¼Œéƒ½æ²¡æœ‰éœ€è¦æ˜¾å¼ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„ case å‘¢ï¼Ÿé‚£æ˜¯å› ä¸º Rust ç¼–è¯‘å™¨æœ¬èº«æœ‰è‡ªåŠ¨æ¨ç†ç”Ÿå‘½å‘¨æœŸçš„åŠŸèƒ½ï¼Œå¹¶ä¸”å¦‚æˆ‘ä»¬ä¸Šé¢æåˆ°çš„â€œæ¯ä¸ªå˜é‡éƒ½æœ‰å…¶å¯¹åº”çš„ç”Ÿå‘½å‘¨æœŸâ€ï¼Œå®é™…ä¸Šæˆ‘ä»¬å®šä¹‰çš„å‡½æ•°ä¹Ÿä¼šé€šè¿‡ç¼–è¯‘å™¨è¢«ç¿»è¯‘ï¼Œå‡½æ•°çš„æ¯ä¸ªå…¥å‚éƒ½ä¼šè¢«è‡ªåŠ¨åŠ ä¸Šå…¶å¯¹åº”çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œè€Œå½“æˆ‘ä»¬å¹¶æ²¡æœ‰å‡ºç°æ— æ³•åˆ†æç”Ÿå‘½å‘¨æœŸçš„æƒ…å†µæ—¶ï¼Œåœ¨ç¼–è¯‘å™¨è‡ªåŠ¨æ¨ç†èƒ½åŠ›èŒƒå›´å†…çš„ case å°±ä¸éœ€è¦æ‰‹åŠ¨åŠ ä¸Šç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ã€‚\nè¿™æ˜¯å› ä¸ºï¼Œå¦‚æœå‡½æ•°å‹æ ¹æ²¡æœ‰è¿”å›å€¼ï¼Œè‡ªç„¶å°±ä¸éœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„åŠ æŒäº†ã€‚å¦‚æœæœ‰è¿”å›å€¼ï¼Œå‡è®¾å‡½æ•°çš„è¿”å›å€¼æ˜¯å¼•ç”¨ç±»å‹ï¼Œé‚£ä¹ˆå®ƒä¹Ÿåªå¯èƒ½æœ‰ä¸¤ç§æ¥æºï¼š\n\nå‡½æ•°æŸä¸ªå…¥å‚çš„ç”Ÿå‘½å‘¨æœŸ\nå‡½æ•°å†…æŸä¸ªæ–°å»ºå˜é‡çš„ç”Ÿå‘½å‘¨æœŸ\n\nå¯¹äºç¬¬ä¸€ç§æƒ…å†µï¼Œå¦‚æœåªæœ‰ä¸€ä¸ªå…¥å‚ï¼Œé‚£ä¹Ÿå°±ä¸éœ€è¦ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼ˆâœ¨ ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨é€šå¸¸æ˜¯å‡ºç°åœ¨æ‹¥æœ‰å¤šä¸ªç”Ÿå‘½å‘¨æœŸçš„æƒ…å†µä¸‹çš„ï¼‰ã€‚ è€Œç¬¬äºŒç§æƒ…å†µï¼Œè¿™æ˜¯æ˜æ˜¾çš„æ‚¬å‚æŒ‡é’ˆï¼Œæ–°å»ºå˜é‡çš„ç”Ÿå‘½å‘¨æœŸä»…åœ¨å‡½æ•°å†…éƒ¨ï¼Œå‡½æ•°å¤–æ˜¯æ— æ³•å¯¹å…¶è¿›è¡Œå¼•ç”¨çš„ï¼Œç›´æ¥ä¼šè¢«ç¼–è¯‘å™¨æ‹’ç»ã€‚\nè¿™ç§æ— éœ€æ‰‹åŠ¨è¿›è¡Œç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„èƒ½åŠ›è¢«ç§°ä¸º â€œç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤ï¼ˆLifetime Elisionï¼‰â€ï¼Œæ˜¯ç¼–è¯‘å™¨ä¸ºäº†ç®€åŒ–å¼€å‘è€…çš„ä½¿ç”¨è€Œè‡ªåŠ¨è¿ç”¨çš„ã€‚å…·ä½“çš„ï¼Œä¼šè‡ªåŠ¨ä½¿ç”¨ç”Ÿå‘½æ¶ˆé™¤èƒ½åŠ›éœ€è¦ç¬¦åˆä¸‰æ¡å…·ä½“è§„åˆ™ï¼Œå¯ä»¥å‚è€ƒä¸€ä¸‹æˆªå›¾è¦æ±‚ï¼š\nï¼ˆä¸€èˆ¬æƒ…å†µï¼Œåªè¦ç¼–è¯‘å™¨èƒ½é€šè¿‡ç¼–è¯‘ï¼Œåˆ™è¯æ˜æ— éœ€æ‰‹åŠ¨è¿›è¡Œç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼‰\n\nå¯¹ ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ çš„æ€»ç»“ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨å°±æ˜¯å°†å‡½æ•°çš„å¤šä¸ªå¼•ç”¨å‚æ•°å’Œè¿”å›å€¼çš„ä½œç”¨åŸŸè¿›è¡Œå…³è”ï¼Œä¸€æ—¦å…³è”åˆ°ä¸€èµ·åï¼ŒRust ä¾¿å¯ä»¥æ‹¥æœ‰å……åˆ†çš„ä¿¡æ¯æ¥åˆ†æå’Œç¡®ä¿æˆ‘ä»¬çš„æ“ä½œæ˜¯å†…å­˜å®‰å…¨çš„ã€‚\nç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸå½“ç»“æ„ä½“ä¸­å­˜åœ¨å¼•ç”¨ç±»å‹æ—¶ï¼Œä¹Ÿä¼šå­˜åœ¨éœ€è¦æ˜¾å¼ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„ caseï¼š\n12345// ç»“æ„ä½“åŠ ä¸Šç”Ÿå‘½å‘¨æœŸæ ‡æ³¨struct Example&lt;&#x27;a, &#x27;b&gt; &#123;  x: &amp;&#x27;a str,  y: &amp;&#x27;b str,&#125;\n\næ–¹æ³•ä¸­çš„ç”Ÿå‘½å‘¨æœŸç»™ Example ç»“æ„ä½“åŠ ä¸Šæ–¹æ³•ï¼ˆmethodsï¼‰ï¼š\n1234567891011121314151617// ç»“æ„ä½“åŠ ä¸Šç”Ÿå‘½å‘¨æœŸæ ‡æ³¨struct Example&lt;&#x27;a, &#x27;b&gt; &#123;    x: &amp;&#x27;a str,    y: &amp;&#x27;b str,&#125;impl&lt;&#x27;a, &#x27;b&gt; Example&lt;&#x27;a, &#x27;b&gt; &#123;    // è¿™é‡Œæˆ‘ä»¬å¹¶ä¸éœ€è¦æ ‡æ³¨å› ä¸ºæˆ‘ä»¬çš„å…¥å‚ä¸Šå«æœ‰ &amp;self æˆ–è€… &amp;mut selfï¼Œ    // å…¶å®å°±æ˜¯ç¬¦åˆäº†æˆ‘ä»¬ä¸Šé¢æŒ‡å‡ºè¿‡çš„ç¬¬ä¸€ç§ caseï¼Œè¯¥æ–¹æ³•æœ‰å¼•ç”¨ç±»å‹çš„è¿”å›å€¼ï¼Œ    // æ— è®ºæ˜¯ä»€ä¹ˆå¼•ç”¨ç±»å‹ï¼Œåªå¯èƒ½æ˜¯æ¥æºäºå…¥å‚ã€‚    // æ­¤æ—¶å¦‚æœä»…ä¸€ä¸ªå…¥å‚ï¼Œé‚£ä¹ˆå®ƒçš„è¿”å›å€¼ç”Ÿå‘½å‘¨æœŸä¸€å®šæ˜¯ self çš„ç”Ÿå‘½å‘¨æœŸï¼Œ    // ä¸”æ— è®ºè¿”å›å€¼æœ‰å¤šå°‘ä¸ªï¼Œéƒ½ä¸€å®šåªæœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸã€‚ä¹Ÿå°±ä¸éœ€è¦æ‰‹åŠ¨æ·»åŠ ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨äº†ï¼Œ    // self çš„ç”Ÿå‘½å‘¨æœŸ â€”â€” å³å½“å‰ Example ç»“æ„ä½“å®ä¾‹ä¼šè¢«ç›´æ¥èµ‹äºˆç»™è¿™ä¸ªæ–¹æ³•çš„è¿”å›å€¼ã€‚    fn get_self(&amp;self) -&gt; &amp;Example &#123;        self    &#125;&#125;\n\næ‰‹åŠ¨çº¦æŸç”Ÿå‘½å‘¨æœŸå¦å¤–è¿˜æœ‰ä¸€ç§æ‰‹åŠ¨çº¦æŸå¤šä¸ªç”Ÿå‘½å‘¨æœŸçš„è¯­æ³• â€”â€” &#39;a: &#39;b è¡¨ç¤º &#39;a æ´»çš„æ¯” &#39;b æ—¶é—´é•¿ï¼Œç”¨äºå½“æ–¹æ³•å¼•ç”¨äº†å¤šä¸ªç”Ÿå‘½å‘¨æœŸçš„æƒ…å†µä¸‹ï¼Œå› ä¸ºå¦‚æœè¿”å›äº†ä¸€ä¸ªè¾ƒå¤§çš„ç”Ÿå‘½å‘¨æœŸä¼šäº§ç”Ÿæ‚¬å‚å¼•ç”¨ï¼Œéœ€è¦æ‰‹åŠ¨è¡¨æ˜ç”Ÿå‘½å‘¨æœŸä¹‹é—´çš„å…³ç³»ï¼š\n12345678910111213141516// beforeimpl&lt;&#x27;a&gt; MyStruct&lt;&#x27;a&gt; &#123;  // æ–¹æ³•è¿”å›å€¼ä¸º&#x27;b, ä¸”è¯¥æ–¹æ³•å¼•ç”¨äº†&#x27;a, é‚£ä¹ˆåªæœ‰ &#x27;b å­˜æ´»æ—¶é—´ä¸€å®šæ¯” &#x27;a çŸ­æ‰ä¸ä¼šå¼•èµ·æ‚¬å‚å¼•ç”¨ã€‚  // Rust ç¼–è¯‘å™¨å¹¶ä¸èƒ½çŸ¥é“ä¸¤è€…å…³ç³»ï¼Œéœ€è¦æ‰‹åŠ¨åŠ ä¸Šç”Ÿå‘½å‘¨æœŸçº¦æŸã€‚  fn foo&lt;&#x27;b&gt;(&amp;&#x27;a self, other: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123;   self.name &#125;&#125;// afterimpl&lt;&#x27;a: &#x27;b, &#x27;a&gt; MyStruct&lt;&#x27;a&gt; &#123;  fn foo&lt;&#x27;b&gt;(&amp;&#x27;a self, other: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123;   self.name &#125;&#125;\n\nç‰¹æ®Šç”Ÿå‘½å‘¨æœŸæ ‡æ³¨é™æ€ç”Ÿå‘½å‘¨æœŸ&#39;static æ ‡æ³¨æ˜¯æŒ‡è¿™æ˜¯ä¸€ä¸ªé™æ€ç”Ÿå‘½å‘¨æœŸï¼Œæ‹¥æœ‰é™æ€ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨å°±è¡¨ç¤ºå¯ä»¥å’Œæ•´ä¸ªç¨‹åºå­˜æ´»çš„ä¸€æ ·ä¹…ã€‚\n1let s: &amp;&#x27;static str = &quot;æˆ‘æ²¡å•¥ä¼˜ç‚¹ï¼Œå°±æ˜¯æ´»å¾—ä¹…ï¼Œå˜¿å˜¿&quot;;\n\nåœ¨ Rust ä¸­ï¼Œå­—ç¬¦ä¸²å­—é¢é‡é»˜è®¤å°±æ˜¯ é™æ€ç”Ÿå‘½å‘¨æœŸï¼Œå³ä¸ç®¡å­—ç¬¦ä¸²å­—é¢é‡å®šä¹‰åœ¨å“ªï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸé»˜è®¤éƒ½æ˜¯æ•´ä¸ªç¨‹åºå­˜æ´»æœŸé—´ã€‚è¿™é‡Œæˆ‘ä»¬å¯ä»¥ç»“åˆä¸€ä¸ªå¤æ‚ç‚¹çš„ä¾‹å­æ¥å¯¹æ¯”çœ‹ä¸‹å­—ç¬¦ä¸²å­—é¢é‡çš„ç”Ÿå‘½å‘¨æœŸå’Œæ™®é€šç”Ÿå‘½å‘¨æœŸçš„å·®å¼‚ã€‚\næœ‰å¦‚ä¸‹ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«éƒ½è¿”å›ç¬¬äºŒä¸ªå…¥å‚ï¼Œå¯¹åº”ä¹Ÿéƒ½åŠ ä¸Šäº†ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼š\n1234567fn example&lt;&#x27;a&gt;(a: &amp;&#x27;a str, b: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;    b&#125;fn example2&lt;&#x27;a&gt;(a: &amp;&#x27;a i32, b: &amp;&#x27;a i32) -&gt; &amp;&#x27;a i32 &#123;    b&#125;\n\næˆ‘ä»¬å†™ä¸¤ä¸ªä¸€æ ·çš„ caseï¼Œä¸€ä¸ªç”¨å­—ç¬¦ä¸²å­—é¢é‡æµ‹è¯• å¯¹åº” exampleï¼Œä¸€ä¸ªç”¨ i32 ç±»å‹æµ‹è¯• å¯¹åº” example2ï¼š\n123456789101112131415161718192021let s1 = &quot;Hello&quot;; // &#x27;staticlet result = &#123;  let s2 = &quot;Rust&quot;; // &#x27;static  let result = example(s1, s2);  result&#125;;// result æŒæœ‰å¯¹ s2 çš„å¼•ç”¨// å°è¯•èƒ½å¦è®¿é—®println!(&quot;result is &#123;&#125;&quot;, result);let n1 = 3;  // i32let result = &#123;  let n2 = 9;  // i32  let result = example2(&amp;n1, &amp;n2);  result&#125;;// result æŒæœ‰å¯¹ n2 çš„å¼•ç”¨// å°è¯•èƒ½å¦è®¿é—®println!(&quot;result is &#123;&#125;&quot;, result);\n\nç¼–è¾‘å™¨æœ‰å¦‚ä¸‹æŠ¥é”™ï¼š\n\nn2 does not live long enough å¯ä»¥çœ‹åˆ° case2 å¤–é¢çš„ result æŒæœ‰äº†å¯¹ n2 çš„å¼•ç”¨ï¼Œé‚£ä¹ˆå°±æ„å‘³ç€ n2 çš„ç”Ÿå‘½å‘¨æœŸåº”è¯¥é•¿äºå¤–éƒ¨çš„ resultï¼Œä½† n2 æ˜¯ä»£ç å—å†…éƒ¨å®šä¹‰çš„å˜é‡ï¼Œå®ƒçš„å­˜æ´»èŒƒå›´ä»…åœ¨ä»£ç å—å†…éƒ¨ï¼Œåˆ™æ— æ³•é€šè¿‡ç¼–è¯‘æ£€æŸ¥ã€‚\nè€ŒåŒä¸€ä¸ªçŠ¶å†µï¼Œå› ä¸º case1 ä¸­ç”¨åˆ°çš„æ˜¯å­—ç¬¦ä¸²å­—é¢é‡ï¼Œå­—ç¬¦ä¸²å­—é¢é‡æœ¬èº«çš„ç”Ÿå‘½å‘¨æœŸå°±æ˜¯æ•´ä¸ªç¨‹åºæœŸé—´ï¼Œè¿™æ‰é€šè¿‡äº†ç¼–è¯‘å™¨çš„æ£€æŸ¥ã€‚\nå ä½ç¬¦é»˜è®¤åŒ¹é…ç”Ÿå‘½å‘¨æœŸå½“æˆ‘ä»¬åœ¨å®ç°æ–¹æ³•æ—¶ï¼Œå¦‚æœå¹¶æ²¡æœ‰æ¶‰åŠå¤šç”Ÿå‘½å‘¨æœŸçš„æƒ…å†µï¼Œæˆ–è€…è¯´éƒ½æ»¡è¶³ç”Ÿå‘½æ¶ˆé™¤è§„åˆ™çš„æ¡ä»¶ä¸‹ï¼Œå…¶å®å°±è¡¨ç¤ºæˆ‘ä»¬å¹¶ä¸æ˜¯å¾ˆå…³å¿ƒè¿™ä¸ªç”Ÿå‘½å‘¨æœŸï¼Œè¿™æ—¶å€™æˆ‘ä»¬ impl  å£°æ˜å¯ä»¥ä½¿ç”¨ _ å ä½ç¬¦æ¥è¡¨ç¤ºé»˜è®¤åŒ¹é…çš„é‚£ä¸ªç”Ÿå‘½å‘¨æœŸï¼Œä¸éœ€è¦ç»™å®šä¸€ä¸ªå…·ä½“çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨åäº†ï¼Œå› ä¸ºåœ¨å†…å±‚æ–¹æ³•çš„å®ç°ä¸Šæˆ‘ä»¬ä¹Ÿä¸éœ€è¦ç”¨åˆ°æ‰‹åŠ¨æ ‡æ³¨ã€‚\n1234567891011struct Counter&lt;&#x27;a&gt; &#123;    count: &amp;&#x27;a mut i32,&#125;// å ä½ç¬¦åŒ¹é…é»˜è®¤çš„ç”Ÿå‘½å‘¨æœŸ// è¯¥ Counter ç»“æ„ä½“å®ä¾‹å°±ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸimpl Counter&lt;&#x27;_&gt; &#123;    fn add(&amp;mut self) &#123;        *self.count += 1;    &#125;&#125;\n\nç»ƒä¹ å·©å›ºä¸Šé¢çš„ç†è§£ï¼Œè¯·ä¿®å¤ä¸‹é¢çš„å‡½æ•°å£°æ˜ï¼š\n\næ”¹åŠ¨ä»£ç å¦‚ä¸‹ï¼š\n123456789101112131415fn test_lifetime_mut() &#123;  fn insert_value&lt;&#x27;a, &#x27;b: &#x27;a&gt;(my_vec: &amp;mut Vec&lt;&amp;&#x27;a i32&gt;, value: &amp;&#x27;b i32) &#123;    // âœ… ç»“è®ºï¼šmy_vec æ‹¥æœ‰å¯¹ value çš„å¼•ç”¨ =&gt; &#x27;b: &#x27;a ä¸ºå‡½æ•°æ·»åŠ ç”Ÿå‘½å‘¨æœŸçº¦æŸé€šè¿‡ç¼–è¯‘å™¨æ£€æŸ¥    my_vec.push(value);  &#125;    &#123;    // âœ… æ ¹æ®ä¸Šè¿°ç»“è®ºï¼Œy å¿…é¡»æ—©äº x å®šä¹‰    let y = 2;    let x = 1;    let mut my_vec = vec![&amp;x];    insert_value(&amp;mut my_vec, &amp;y);    println!(&quot;&#123;my_vec:?&#125;&quot;);  &#125;&#125;\n\næˆåŠŸè¿è¡Œï¼\n\n","slug":"lifetime","date":"2024-12-04T10:16:46.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"ab26d33d9183b3dac0ad2f16b85bf6b4","title":"æ³›å‹ Generics","content":"å‡½æ•°ä¸­ä½¿ç”¨æ³›å‹æ³›å‹æ˜¯å®ç°è®©ä¸€ä¸ªåŠŸèƒ½å‡½æ•°æ”¯æŒä¸åŒç±»å‹çš„æ‰‹æ®µï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºå¤šæ€ã€‚åœ¨ä¸æ”¯æŒæ³›å‹æ—¶ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå†™å‡ºå¦‚ä¸‹ä»£ç ï¼š\n1234567891011fn add_i32(a: i32, b: i32) -&gt; i32 &#123;    a + b&#125;fn add_f64(a: f64, b: f64) -&gt; f64 &#123;    a + b&#125;fn add_i8(a: i8, b: i8) -&gt; i8 &#123;    a + b&#125;\n\nä¸Šé¢æ˜¯å¤šä¸ªç±»å‹çš„ add å‡½æ•°ï¼Œå› ä¸ºç±»å‹çš„é™åˆ¶ï¼Œæˆ‘ä»¬éœ€è¦ä¸ºæ¯ç§ç±»å‹å•ç‹¬å†™ä¸€ä¸ªå‡½æ•°ã€‚æœ‰äº†æ³›å‹ä¹‹åï¼Œå¯ä»¥çœå»è¿™æ ·å†—ä½™çš„ä»£ç ï¼Œæ³›å‹çš„å£°æ˜æ ¼å¼ï¼š\nä½¿ç”¨æ³›å‹å‚æ•°ï¼Œæœ‰ä¸€ä¸ªå…ˆå†³æ¡ä»¶ï¼Œå¿…éœ€åœ¨ä½¿ç”¨å‰å¯¹å…¶è¿›è¡Œå£°æ˜ã€‚\nä½¿ç”¨å‰å£°æ˜çš„æ„ä¹‰æ˜¯ï¼šè¡¨ç¤ºæˆ‘è¿™ä¸ªå‡½æ•°æ‹¥æœ‰å¤šå°‘æ³›å‹å‚æ•°ï¼Œå¦‚\n123fn add&lt;T&gt; // è¡¨ç¤ºå½“å‰ add å‡½æ•°æ‹¥æœ‰ä¸€ä¸ªæ³›å‹å‚æ•° Tfn foo&lt;T, R&gt; // è¡¨ç¤ºå½“å‰ foo å‡½æ•°æ‹¥æœ‰ä¸¤ä¸ªæ³›å‹å‚æ•° Tï¼ŒR\n\nå»¶ç”¨ add å‡½æ•°ï¼Œæˆ‘ä»¬å®Œå–„æ³›å‹å£°æ˜åå¦‚ä¸‹ï¼š\n\næˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªæŠ¥é”™ï¼Œcannot add T to T å› ä¸ºæ³›å‹å‚æ•° T å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼Œä½†å¹¶ä¸æ˜¯æ‰€æœ‰ç±»å‹éƒ½å¯ä»¥åšåŠ æ³•è¿™ä¸ªè¡Œä¸ºï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜éœ€è¦å¯¹æ³›å‹å‚æ•° T è¿›è¡Œç‰¹å¾ï¼ˆTraitï¼‰é™åˆ¶ï¼Œä»¥è¡¨ç¤ºè¿™ä¸ªç±»å‹æ˜¯å¯ä»¥è¿›è¡Œç›¸åŠ çš„ã€‚\næˆ‘ä»¬è¾“å…¥ add å¯ä»¥çœ‹åˆ°ç›¸å…³çš„ç‰¹å¾æç¤ºï¼Œadd ç‰¹å¾ä¹Ÿæ˜¯æ”¯æŒæ³›å‹çš„ï¼ŒæŒ‰ç…§æç¤ºçš„ç¤ºä¾‹ï¼Œæˆ‘ä»¬ä¿®æ”¹å‡½æ•°å£°æ˜ã€‚\n\nAdd æ˜¯ use std::ops::Add å¼•å…¥çš„ï¼ŒAdd&lt;Output = T&gt; æˆ‘ä»¬æŠŠæ³›å‹å‚æ•° T ä¼ å…¥ Trait Add çš„æ³›å‹å£°æ˜ä¸­ï¼Œæ•´ä¸ªæ³›å‹çš„å£°æ˜å°±å®Œæˆäº†ã€‚\n\nä¸‹é¢æˆ‘ä»¬å†å°è¯•å†™ä¸€ä¸ªå¤æ‚ç‚¹çš„ä¾‹å­ï¼Œå®ç°ä¸€ä¸ªè¾“å‡ºæ•°ç»„ä¸­æœ€å¤§å€¼çš„å‡½æ•°ã€‚\n123456789101112131415161718192021222324/** * 1. å£°æ˜æ³›å‹å‚æ•° T * 2. list ä¸ºç±»å‹ä¸º T çš„æ•°ç»„ï¼Œç”¨æŒ‡é’ˆç±»å‹è®©æ•°ç»„å‚æ•°åœ¨ç¼–è¯‘æ—¶æœŸæœ‰ä¸€ä¸ªç¡®å®šçš„å¤§å° * 3. è¿”å›å€¼ä¸º Tç±»å‹å€¼ çš„å¼•ç”¨ */fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T &#123;    // é»˜è®¤æœ€å¤§å€¼ä¸ºæ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´     let mut max = &amp;list[0];    // éå†åç»­æ•°ç»„ï¼Œé€ä¸ªæ¯”è¾ƒï¼Œå‡ºç°æ›´å¤§çš„å€¼åˆ™æ›¿æ¢    for i in 1..list.len() &#123;        // è¿™é‡Œéœ€è¦æ³¨æ„ï¼Œéœ€è¦é™åˆ¶æ³›å‹å‚æ•° T &lt;T: std::cmp::PartialOrd&gt;ï¼Œè¦æ‹¥æœ‰æ¯”è¾ƒå¤§å°çš„ç‰¹å¾        if max &lt; &amp;list[i] &#123;            max = &amp;list[i];        &#125;    &#125;    max&#125;fn main() &#123;    let number_list = vec![1, 5, 9, 4, 7];    let max = largest(&amp;number_list);    println!(&quot;largest number is &#123;&#125;&quot;, max);&#125;\n\nè¿è¡Œåç»“æœå¦‚ä¸‹ï¼š\n\nç»“æ„ä½“ä¸­ä½¿ç”¨æ³›å‹åŸºäºä¸Šé¢æ³›å‹çš„ç†è§£ï¼Œæˆ‘ä»¬ç›´æ¥çœ‹å£°æ˜ï¼š\n1234567891011struct Point&lt;T&gt; &#123;  x: T,  y: T,&#125;// ä¸Šè¿°ç±»å‹å£°æ˜è¡¨ç¤ºï¼Œç»“æ„ä½“ Point çš„ fields éƒ½æ˜¯åŒä¸€ä¸ªç±»å‹çš„fn main() &#123;    let p1 = Point &#123; x: 1, y: 2 &#125;;  // Point&lt;i32&gt;    let p2 = Point &#123; x: 1.0, y: 2.0 &#125;;  // Point&lt;f64&gt;&#125;\n\né‚£ä¹ˆå½“æˆ‘ä»¬éœ€è¦ x, y ä¸åŒç±»å‹æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å£°æ˜ç¬¬ 2 ä¸ªæ³›å‹å‚æ•° Uï¼Œå¦‚ä¸‹ï¼š\n123456789101112struct Point&lt;T, U&gt; &#123;  x: T,  y: U,&#125;fn main() &#123;    let p1 = Point &#123; x: 1, y: 2 &#125;;  // Point&lt;i32&gt;    let p2 = Point &#123; x: 1.0, y: 2.0 &#125;;  // Point&lt;f64&gt;     // è¿™æ ·æ—¢å¯ä»¥æ”¯æŒç›¸åŒç±»å‹çš„æƒ…å†µï¼Œä¹Ÿå¯ä»¥æ”¯æŒä¸åŒç±»å‹çš„æƒ…å†µ   let p3 = Point &#123; x: 1, y: 2.0 &#125;; // Point&lt;i32, f64&gt;&#125;\n\næšä¸¾ä¸­ä½¿ç”¨æ³›å‹123456789enum Option&lt;T&gt; &#123;    Some(T),    None,&#125;enum Result&lt;T, E&gt; &#123;    Ok(T),    Err(E),&#125;\n\næ–¹æ³•ä¸­ä½¿ç”¨æ³›å‹123456789101112struct Point&lt;T, U&gt; &#123;    x: T,    y: U,&#125;// è¿™é‡Œ Point&lt;T, U&gt; è¢«è§†ä¸ºä¸€ç§ç»“æ„ä½“ç±»å‹ï¼Œæ‰€ä»¥åœ¨å®ç°å…¶æ–¹æ³•æ—¶ï¼Œ// ä¹Ÿéœ€è¦é€šè¿‡ impl&lt;T, U&gt; æå‰å£°æ˜æ³›å‹å‚æ•°åˆ—è¡¨impl&lt;T, U&gt; Point&lt;T, U&gt; &#123;    fn x(&amp;self) -&gt; &amp;T &#123;        &amp;self.x    &#125;&#125;\n\næˆ‘ä»¬å†åŠ å…¥ä¸€ä¸ªå¤æ‚ç‚¹çš„æ–¹æ³• mixupï¼ŒåŠŸèƒ½æ˜¯ä¼ å…¥å¦ä¸€ä¸ª Pointï¼Œç„¶åè¾“å‡ºå®ƒä»¬äº¤å‰åçš„æ–° Pointã€‚äº¤å‰æŒ‡çš„æ˜¯ï¼Œå–åŸ Point çš„ x å’Œä¼ å…¥ Point çš„ yï¼Œç»„æˆä¸€ä¸ªæ–°çš„ Pointã€‚\n123456789101112131415161718192021impl&lt;T, U&gt; Point&lt;T, U&gt; &#123;    fn x(&amp;self) -&gt; &amp;T &#123;        &amp;self.x    &#125;    // mixup æ–¹æ³•å…¥å‚éœ€è¦æ³›å‹å‚æ•° T2, U2   // æ‰€ä»¥éœ€è¦æå‰å£°æ˜æ³›å‹å‚æ•°åˆ—è¡¨ mixup&lt;T2, U2&gt;   // è¿”å›å€¼ç±»å‹ä¸ºäº¤å‰åçš„ Point&lt;T, U2&gt; ç»“æ„ä½“ç±»å‹    fn mixup&lt;T2, U2&gt;(self, other: Point&lt;T2, U2&gt;) -&gt; Point&lt;T, U2&gt; &#123;        Point &#123;            x: self.x,            y: other.y,        &#125;    &#125;&#125;fn main() &#123;    // è¿™é‡Œ mixup å¹¶ä¸éœ€è¦æ‰‹åŠ¨ä¼ å…¥ç±»å‹ï¼Œä¼šæ ¹æ®å…¥å‚ Point&lt;T2, U2&gt; ç±»å‹è‡ªåŠ¨åšç±»å‹æ¨æ–­    let p4 = p1.mixup(Point &#123; x: 9.0, y: &quot;Hello&quot; &#125;);    println!(&quot;p4.x = &#123;&#125;, p4.y = &#123;&#125;&quot;, p4.x, p4.y);&#125;\n\nè¿è¡Œç»“æœï¼Œå¦‚ä¸‹ï¼š\n\nconst æ³›å‹æ„æ€æ˜¯ å¸¸é‡çš„æ³›å‹ï¼Œåœ¨è¯¸å¦‚å½“æˆ‘ä»¬åªå¸Œæœ›æ§åˆ¶å‚æ•°ç±»å‹ä¸ºä¸€ä¸ªæ•´æ•° i32 æ•°ç»„ï¼Œä½†æ•°ç»„é•¿åº¦ä¸éœ€è¦å›ºå®šçš„æƒ…å†µå¯ä»¥ä½¿ç”¨ï¼Œçœ‹å…·ä½“ä¾‹å­ï¼š\n12345678910111213// usize è¡¨ç¤ºç´¢å¼•ç±»å‹fn display_array&lt;const N: usize&gt;(list: &amp;[i32; N]) &#123;    println!(&quot;&#123;:?&#125;&quot;, list);&#125;fn main() &#123;    // æ‰“å°ä¸€ä¸ªæ•°ç»„    let a1 = [1, 2, 3];    display_array(&amp;a1);    let a2 = [9, 8, 7, 6];    display_array(&amp;a2);&#125;\n\nè¿è¡Œç»“æœï¼Œå¦‚ä¸‹ï¼š\n\næ³›å‹ä»£ç çš„æ€§èƒ½ä½¿ç”¨æ³›å‹ç»™å¼€å‘è€…å¸¦æ¥äº†å¾ˆå¤šä¾¿åˆ©ï¼Œåœ¨å¼€å‘æ•ˆç‡ä¸Šæ— ç–‘æ˜¯ææ•ˆçš„ã€‚è€Œæ³›å‹ä»£ç è™½ç„¶è¾“å…¥æ˜¯ä¸€ç§æ¨¡å¼ï¼Œä½†æ˜¯ç»ç”± Rust ç¼–è¯‘å™¨ï¼Œå®é™…ä¼šè¢«ç¿»è¯‘æˆ n ç§ï¼Œæ‰€æœ‰å¯æ”¯æŒçš„æƒ…å†µéƒ½ä¼šæœ‰ä¸€ä»½ä»£ç ï¼Œè¿™ä¸ªç¿»è¯‘çš„è¿‡ç¨‹è¢«ç§°ä¸º å•æ€åŒ–ï¼Œå³å£°æ˜æ—¶æ˜¯ å¤šæ€çš„ï¼Œç¼–è¯‘åå³å˜ä¸º å•æ€ã€‚åŒæ—¶ä¹Ÿå°±æ„å‘³ç€ï¼Œåœ¨è¿è¡Œæ—¶å…¶å®æ˜¯ä¸ä¼šå› ä¸ºæ³›å‹å¸¦æ¥ä»»ä½•å¢åŠ çš„å¼€é”€çš„ï¼Œå› ä¸ºç¼–è¯‘æœŸé—´éƒ½ç”Ÿæˆå¥½äº†ï¼Œå¯¹åº”çš„è°ƒç”¨ä»£ç è°ƒç”¨çš„ä¹Ÿå°±æ˜¯é‚£ä¸€ä»½ç¿»è¯‘åçš„ä»£ç ã€‚æ‰€æœ‰çš„å¼€é”€éƒ½æ˜¯åœ¨ç¼–è¯‘æœŸé—´äº§ç”Ÿçš„ï¼ˆç¼–è¯‘æ—¶é—´åŠç¼–è¯‘åæ–‡ä»¶å¤§å°ä¼šæœ‰æ‰€å¢åŠ ï¼‰ï¼Œè¿è¡ŒæœŸé—´æ— æŸï¼Œä»ç„¶ä¿æŒé«˜æ•ˆã€‚\n","slug":"generics","date":"2024-12-02T13:12:41.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"3b2621a700dd1210cc1c1a2ba961dd42","title":"First Project","content":"Getting Startedå®‰è£… anchor â€”â€” Solana æ™ºèƒ½åˆçº¦æ¡†æ¶\n1.ç”¨ cargo å®‰è£… avm ï¼ŒAnchor ç‰ˆæœ¬ç®¡ç†å™¨\n1cargo install --git https://github.com/coral-xyz/anchor --tag v0.30.1 anchor-cli\n\n2.ä½¿ç”¨ avm å®‰è£…æœ€æ–°ç‰ˆæœ¬ anchor\n1avm install latest\n\n3.æ£€æŸ¥å®‰è£…å¥½çš„ç‰ˆæœ¬\n1anchor --version\n\nTrouble Shooting\nerror: no such command: build-sbf\n12cargo buildcargo build-sbf --force-tools-install\n\n\n\n","slug":"first-project","date":"2024-11-01T08:06:44.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"2e2bd34ffcfc46d5575f7c18eed689f5","title":"æ™ºèƒ½æŒ‡é’ˆ Smart Pointers","content":"é¦–å…ˆç†è§£ï¼ŒæŒ‡é’ˆæ˜¯ä»€ä¹ˆï¼ŸæŒ‡é’ˆæ˜¯ä¸€ä¸ªå­˜å‚¨äº†å†…å­˜åœ°å€ï¼ˆmemory addressï¼‰çš„å˜é‡ï¼Œè¯¥å†…å­˜åœ°å€å¼•ç”¨æˆ–è€…æŒ‡å‘äº†å†…å­˜ä¸­å¦å¤–çš„æ•°æ®ã€‚\nåœ¨ Rust ä¸­æœ€å¸¸è§çš„æŒ‡é’ˆå°±æ˜¯å¼•ç”¨ï¼ˆreferenceï¼‰ï¼Œå¼•ç”¨å˜é‡å‘è¢«å®ƒå¼•ç”¨çš„å˜é‡å€Ÿç”¨ï¼ˆborrowï¼‰å®ƒæŒ‡å‘çš„æ•°æ®ï¼Œè¿™æ„å‘³ç€å®ƒä»¬è‡ªèº«æ˜¯æ²¡æœ‰å¯¹è¯¥æ•°æ®çš„æ‰€æœ‰æƒï¼ˆownershipï¼‰çš„ã€‚\nå¼•ç”¨åªåŒ…å«ä¸€ä¸ªæŒ‡å‘è¢«å¼•ç”¨å˜é‡çš„æŒ‡é’ˆï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œå¼•ç”¨å°±å†æ— å…¶ä»–åŠŸèƒ½äº†ã€‚è€Œ Rust æ˜¯é™æ€ç¼–è¯‘è¯­è¨€ï¼Œåœ¨ç¼–è¯‘æœŸé—´å°±éœ€è¦ç¡®å®šå˜é‡æ•°æ®çš„å¤§å°ä»¥åŠä½•æ—¶é‡Šæ”¾ã€‚æ‰€ä»¥è®¾è®¡äº†æ™ºèƒ½æŒ‡é’ˆï¼Œåœ¨æ™®é€šæŒ‡é’ˆçš„åŸºç¡€ä¸Šï¼Œè¿˜åŒ…å«äº†å½“å‰é•¿åº¦ï¼ˆlenï¼‰ã€æœ€å¤§é•¿åº¦ï¼ˆcapacityï¼‰ç­‰å­—æ®µï¼Œè¿™äº›éƒ½æ˜¯ç”¨æ¥ç¡®å®šæŒ‡é’ˆç±»å‹æŒ‡å‘çš„é‚£å—æ•°æ®æ‰€éœ€çš„å†…å­˜ size çš„å­—æ®µã€‚åƒæ˜¯æˆ‘ä»¬ä¹‹å‰ç”¨è¿‡çš„ String ã€Vec éƒ½æ˜¯æ™ºèƒ½æŒ‡é’ˆæ•°æ®ç±»å‹ã€‚\nä¸åŒäºæ™®é€šæŒ‡é’ˆï¼Œæ™ºèƒ½æŒ‡é’ˆæ˜¯å…·æœ‰æ‰€æœ‰æƒçš„æŒ‡é’ˆï¼Œä¸”å®ç°äº† Derefï¼ˆè§£å¼•ç”¨ï¼‰å’Œ Dropï¼ˆæ¸…ç†ï¼‰ä¸¤ä¸ª traitï¼ˆç‰¹å¾ï¼‰ï¼Œè¿™ä½¿å¾—ä»–ä»¬å¯ä»¥åƒæŒ‡é’ˆä¸€æ ·è§£å¼•ç”¨å¹¶åœ¨ç¦»å¼€ä½œç”¨åŸŸæ˜¯è‡ªåŠ¨æ¸…ç†èµ„æºã€‚è¿™æ˜¯å¯¹æ™ºèƒ½æŒ‡é’ˆæ˜¯ä»€ä¹ˆçš„ä¸€ä¸ªå¤§è‡´æ¦‚æ‹¬ï¼Œå…·ä½“åŠŸèƒ½å¯ä»¥é€šè¿‡åé¢æ›´å¤šçš„å®é™…ä¾‹å­å»ç†è§£æ›´ä¸ºè‡ªç„¶ã€‚\nä¸ºä»€ä¹ˆå­˜åœ¨æ™ºèƒ½æŒ‡é’ˆï¼Ÿæ€§èƒ½ç®¡ç† â€” å¤„ç†å¤§ä½“é‡çš„æ•°æ®æ ˆæ˜¯æˆ‘ä»¬ç”¨äºå¿«é€Ÿè¯»å†™çš„å†…å­˜ç©ºé—´ï¼Œå¹¶ä¸é€‚åˆå­˜å‚¨è¿‡å¤§çš„æ•°æ®ã€‚ç›¸å¯¹æ¥è¯´ï¼Œç®€å•çš„æ•°æ®ç±»å‹ä¼šè¢«åˆ†é…åœ¨æ ˆä¸Šï¼Œä½†é’ˆå¯¹ç®€å•å´å¤§ä½“é‡æ•°æ®ï¼Œæˆ‘ä»¬å°±ä¸åº”è¯¥å†ç»§ç»­å­˜å‚¨åœ¨æ ˆä¸Šäº†ï¼Œæ ˆæº¢å‡ºä¼šå¼•èµ·ç¨‹åºçš„å´©æºƒã€‚\n1234567/*å¤§ä½“é‡æ•°æ®ï¼Œé•¿åº¦ä¸º 1_000_000 çš„æ•°ç»„ï¼Œæ•°ç»„é»˜è®¤æ˜¯åˆ†é…çš„æ ˆå†…å­˜*/let arr_stack = [0; 1000000];for i in arr_stack &#123;  println!(&quot;&#123;&#125;&quot;, i);&#125;\n\nè¿è¡Œä»£ç ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°å¦‚ä¸‹æŠ¥é”™ï¼š\n\næ­£å¦‚å‰é¢æ‰€è¯´ â€”â€” æ ˆæº¢å‡ºï¼Œç¨‹åºä¸­æ­¢è¿è¡Œäº†ã€‚\nå¤„ç†æ›´å¤æ‚çš„æ•°æ®ç»“æ„Rust æ˜¯é™æ€ç¼–è¯‘è¯­è¨€ï¼Œè¿™æ„å‘³ç€å®ƒåœ¨ç¼–è¯‘æ—¶æœŸå°±æ˜¯éœ€è¦çŸ¥é“æ¯ä¸ªæ•°æ®æ‰€éœ€å†…å­˜å¤§å°ï¼Œè€Œé’ˆå¯¹ä¸€äº›å¤æ‚çš„æ•°æ®ç»“æ„ï¼Œå¦‚é€’å½’ç»“æ„ã€åˆ†äº«ç»“æ„ã€â“TODO è¿™æ˜¯å•¥ã€‘ç­‰ï¼Œæ˜¯æ²¡æœ‰å›ºå®šå¤§å°çš„ï¼Œè€Œæ™ºèƒ½æŒ‡é’ˆå°±æ˜¯ä¸ºäº†è§£å†³è¿™ä¸€é—®é¢˜è®¾è®¡çš„ã€‚\nä¸¾ä¸ªä¾‹å­ï¼Œå¸¸è§„ enum ï¼Œå› ä¸ºä¸€æ¬¡åªä¼šä½¿ç”¨ enum çš„æŸä¸€ä¸ªå€¼ï¼Œæ‰€ä»¥è¯¥ enum çš„æ‰€éœ€å†…å­˜å¤§å°å–å†³äºå…¶ä¸‹é¢å†…å­˜å ç”¨æœ€å¤§çš„ä¸€ä¸ªæšä¸¾å€¼ã€‚\n12345678910enum Message &#123;  Quit,  Move &#123; x: i32, y: i32 &#125;,  Write(String),  ChangeColor(i32, i32, i32),&#125;// enum Message ä¸­æ‰€éœ€å†…å­˜æœ€å¤§çš„æ˜¯ ChangeColorï¼Œ// åˆ™è¯¥ enum æ‰€éœ€å†…å­˜ä¸º ChangeColor æ‰€éœ€çš„å†…å­˜å¤§å°let a = Message::Quit;\n\næ›´å¤æ‚çš„æ•°æ®ç»“æ„ï¼Œé€’å½’ enum ç±»å‹\n1234enum List &#123;  Cons(i32, List), // åŠ¨æ€å¤§å°ï¼Œæ— æ³•ç¡®å®š size  Nil,&#125;\n\nå¯¹äºé€’å½’ enum æ¥è¯´ï¼ŒåŸºäºæˆ‘ä»¬å‰é¢è®¡ç®— enum å¤§å°çš„æ–¹å¼ï¼Œä¼šå‘ç°æˆ‘ä»¬å¹¶ä¸èƒ½çŸ¥é“å“ªä¸ªæ˜¯å†…å­˜å¤§å°æœ€å¤§çš„æšä¸¾å€¼ï¼Œé€’å½’çš„æšä¸¾å€¼æ˜¯åŠ¨æ€çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•å¾—å‡ºé€’å½’ç±»å‹çš„æ•°æ®å¤§å°ã€‚\nã€TODOã€‘åœ¨æ™®é€šæŒ‡é’ˆåŸºç¡€ä¸Šï¼Œå®Œå–„æ›´å¤šçš„åŠŸèƒ½â“TODOï¼šæ‰€æœ‰æƒã€æ‚¬å‚æŒ‡é’ˆã€åŠ¨æ€å¤§å°ï¼Ÿ\nã€TODOã€‘RC æ™ºèƒ½æŒ‡é’ˆæ™ºèƒ½æŒ‡é’ˆæ˜¯ Rust ç¡®ä¿å…¶å®‰å…¨æ€§çš„ä¸€ç§æ–¹å¼ã€‚æ™ºèƒ½æŒ‡é’ˆæ˜¯ä¸€ç§åŒ…è£¹äº†æ•°æ®å’Œæä¾›äº†ä¸€äº›é¢å¤–åŠŸèƒ½çš„æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚æ‰€æœ‰æƒï¼ˆownershipï¼‰å’Œå¼•ç”¨è®¡æ•°ï¼ˆreference countingï¼‰ã€‚Rust è®¾è®¡äº†å¤šç§æ™ºèƒ½æŒ‡é’ˆçš„æ•°æ®ç±»å‹ï¼Œé€‚ç”¨äºå¤šç§ä¸åŒçš„åœºæ™¯ã€‚\nBox Smart PointerBox æ™ºèƒ½æŒ‡é’ˆæ˜¯ Rust ä¸­æ™ºèƒ½æŒ‡é’ˆçš„ä¸€ç§ï¼Œå®ƒæ˜¯åœ¨æ ˆä¸Šæ‹¥æœ‰å›ºå®šå¤§å°çš„æŒ‡é’ˆï¼Œä½†å…¶æŒ‡å‘çš„æ•°æ®ï¼Œåœ¨å †ä¸Šå¯ä»¥æ˜¯ä»»æ„å¤§å°çš„æ•°æ®ã€‚æ‰€ä»¥å½“æˆ‘ä»¬ä½¿ç”¨äº† Box æ™ºèƒ½æŒ‡é’ˆï¼Œæˆ‘ä»¬æ˜¯å¯ä»¥åœ¨ç¼–è¯‘æ—¶å°±çŸ¥é“æ‰€éœ€å†…å­˜å¤§å°çš„ã€‚å› æ­¤ä¸Šé¢è¯´åˆ°çš„ç¼–è¯‘æ—¶æ— æ³•è®¡ç®—å†…å­˜å¤§å°çš„é—®é¢˜ï¼Œä¾¿å°±è¿åˆƒè€Œè§£äº†ã€‚\næˆ‘ä»¬å°†æ”¹å†™ä¸Šé¢é€’å½’ enum çš„ä¾‹å­ï¼Œç”¨ Box æ™ºèƒ½æŒ‡é’ˆæ¥è§£å†³é—®é¢˜ï¼š\n12345678910111213// å°†é€’å½’åµŒå¥—çš„ List ç±»å‹æ”¹å†™æˆ Box&lt;List&gt; æ™ºèƒ½æŒ‡é’ˆç±»å‹// æ™ºèƒ½æŒ‡é’ˆåœ¨æ ˆä¾§æ˜¯æ‹¥æœ‰å›ºå®šå¤§å°çš„æŒ‡é’ˆï¼Œå¯ä»¥é¡ºåˆ©é€šè¿‡ç¼–è¯‘enum List &#123;  Cons(i32, Box&lt;List&gt;),  Nil,&#125;use List::&#123; Cons, Nil &#125;;fn main() &#123;  // Box::new() åˆ›å»º Box æ™ºèƒ½æŒ‡é’ˆç±»å‹å˜é‡  let list = Cons(1, Box::new(Cons(2, Box::new(3, Box::new(Nil)))));&#125;\n\næ™ºèƒ½æŒ‡é’ˆä¹‹æ‰€ä»¥åŠŸèƒ½å¼ºå¤§ï¼Œè¿˜å› ä¸º Rust ä¸ºå…¶å®ç°äº†ä¸¤ç§ç‰¹å¾ï¼ˆtraitï¼‰ï¼ŒDeref Trait å’Œ Drop Traitï¼Œè®©æˆ‘ä»¬ä¸€èµ·äº†è§£ä¸‹ã€‚\nThe Deref TraitDeref Trait è§£å¼•ç”¨æ˜¯ä¸ºäº†è®©æ™ºèƒ½æŒ‡é’ˆèƒ½åƒæ™®é€šæŒ‡é’ˆä¸€æ ·ä½¿ç”¨è€Œå®ç°çš„ç‰¹å¾ï¼ˆtraitï¼‰ã€‚è¿™å¥è¯æœ‰ä¸¤ä¸ªå…³é”®ç‚¹ï¼š\n\nä»€ä¹ˆæ˜¯ traitï¼ˆç‰¹å¾ï¼‰ï¼Ÿ\n\nä»€ä¹ˆå«åƒæ™®é€šæŒ‡é’ˆä¸€æ ·ä½¿ç”¨ï¼Ÿ\n\n\næˆ‘ä»¬é€ä¸€äº†è§£ä¸€ä¸‹ï¼šï¼‰\nTraits ç‰¹å¾ ç‰¹å¾ï¼ˆtraitsï¼‰æ˜¯ Rust è®¾è®¡å‡ºå¯ä»¥è®©ä¸åŒç±»å‹æ‹¥æœ‰ç›¸åŒè¡Œä¸ºï¼ˆbehaviorï¼‰çš„ä¸€ç§å®ç°ï¼Œåœ¨æè¿°æŸç§æˆ–è€…è¯´æŸç±»è¡Œä¸ºæ—¶å¯ä»¥åŒ…å«1ä¸ªæˆ–è€…å¤šä¸ªæ–¹æ³•ï¼ˆmethodsï¼‰ï¼Œå³ç‰¹å¾å°±æ˜¯æˆ‘ä»¬ç”¨æ¥ä½¿å¾—ä¸åŒç±»å‹èƒ½å¤Ÿå…±äº«ï¼ˆsharingï¼‰åŒä¸€æ‰¹æ–¹æ³•çš„æ‰‹æ®µã€‚\næˆ‘ä»¬çœ‹ä¸€ä¸‹ trait çš„ä¾‹å­ï¼š\n123456pub trait TraitA &#123;  fn method_A(&amp;self) -&gt; String;  fn method_B(&amp;self) -&gt; String &#123;    String::from(&quot;Hello&quot;)  &#125;;&#125;\n\nä¸€èˆ¬æˆ‘ä»¬æè¿° trait æ—¶ï¼Œä¼šåŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªæ–¹æ³•çš„ç­¾åï¼Œå¦‚æœå¯¹æ–¹æ³•å†™äº†å…·ä½“å®ç°ï¼Œåˆ™ä½œä¸ºè¯¥æ–¹æ³•çš„é»˜è®¤è¡Œä¸ºã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨å…·ä½“ç±»å‹ä¸Šé‡å†™ï¼ˆoverwriteï¼‰ç‰¹å¾ä¸‹çš„æ–¹æ³•ï¼Œæ¥è‡ªå®šä¹‰ä¸åŒç±»å‹ä¸Šçš„å®ç°ã€‚\n1234567891011121314151617181920212223struct StructA &#123;    name: String,&#125;// once impl A for B means B is shared with all methods in Aimpl TraitA for StructA &#123;    // overwrite method_A of trait TraitA    fn method_a(&amp;self) -&gt; String &#123;        String::from([&quot;I&#x27;m&quot;, &amp;self.name].join(&quot; &quot;))    &#125;&#125;fn main() &#123;  let a = StructA &#123;    name: String::from(&quot;aaa&quot;),  &#125;;    // call the methods of trait  let name = a.method_a();  println!(&quot;&#123;&#125;&quot;, name);    a.method_b(); &#125;\n\nRust å®šä¹‰å¾ˆå¤šå†…ç½®çš„ç‰¹å¾ï¼Œå¹¶ä¸ºæˆ‘ä»¬æä¾›äº† derive å±æ€§ï¼Œç”¨äºåœ¨ä¸€ä¸ª struct æˆ– enum ä¸Šç”Ÿæˆå¯¹æŸä¸ª trait çš„å®ç°çš„ç›¸å…³ä»£ç ï¼Œè¿™é‡Œçš„ä»£ç å°±æ˜¯å°†è¯¥ trait æ‰€æ‹¥æœ‰çš„é»˜è®¤å®ç°å¤åˆ¶è¿‡æ¥ã€‚è¿™æ ·æˆ‘ä»¬å°±èƒ½å¿«é€Ÿçš„æ‹¥æœ‰ä¸€ä¸ª trait çš„æ‰€æœ‰é»˜è®¤è¡Œä¸ºï¼Œå†…ç½®çš„ç‰¹å¾éœ€è¦é€šè¿‡ use xxx å¯¼å…¥ä¹‹åä½¿ç”¨ã€‚\nåƒæ™®é€šæŒ‡é’ˆä¸€æ ·ä½¿ç”¨å…¶å®æŒ‡çš„å°±æ˜¯ï¼Œå¯ä»¥å¯¹äºæŒ‡é’ˆå˜é‡ä½¿ç”¨ * æ“ä½œç¬¦ï¼Œæˆ‘ä»¬çŸ¥é“å› ä¸ºæ‰€æœ‰æƒçš„å…³ç³»ï¼Œæˆ‘ä»¬åªèƒ½å¯¹æŒ‡é’ˆç±»å‹çš„å˜é‡è¿›è¡Œå€Ÿç”¨ï¼š\n123let x = String::from(&quot;Hello&quot;); // Stringlet y = &amp;x; // &amp;Stringprintln!(&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;, x, y, x == y); // âŒ [ERROR] can&#x27;t compare `String` with `&amp;String`.\n\nè¿™é‡Œç¼–è¯‘ä¼šæŠ¥é”™ï¼Œå› ä¸ºç¬¬ 3 è¡Œæ— æ³•å°†ä¸åŒç±»å‹çš„ä¸¤ä¸ªå€¼è¿›è¡Œæ¯”è¾ƒï¼Œx æ˜¯ String ç±»å‹ï¼Œè€Œ y æ˜¯ a reference to Stringã€‚\ny å°±æ˜¯å€Ÿç”¨äº† xï¼Œå€Ÿç”¨å°±æ„å‘³ç€å…¶å®å°±åªæ˜¯æ‹¿åˆ°äº†ä¸€ä¸ªå†…å­˜åœ°å€ï¼Œé‚£ä¹ˆå½“æˆ‘ä»¬éœ€è¦ç›´æ¥ä½¿ç”¨æ•°æ®æ—¶ï¼ˆå¦‚ï¼šä¸Šé¢åšæ¯”è¾ƒçš„åœºæ™¯ x &#x3D;&#x3D; yï¼‰å°±éœ€è¦ç”¨ * æ“ä½œç¬¦åšè§£å¼•ç”¨ï¼Œæ‹¿åˆ°å†…å­˜åœ°å€å¯¹åº”çš„æ•°æ®ï¼š\n123let x = String::from(&quot;Hello&quot;); // Stringlet y = &amp;x; // &amp;Stringprintln!(&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;, x, y, x == *y); // âœ…\n\né™¤äº† * æ“ä½œç¬¦å®ç°äº† derefï¼Œè¿˜æœ‰åŒ…æ‹¬æˆ‘ä»¬ç»å¸¸ä½¿ç”¨çš„ . æ“ä½œç¬¦ï¼Œæ˜¯é»˜è®¤å¸¦æœ‰è§£å¼•ç”¨åŠŸèƒ½çš„ï¼Œé€šè¿‡ä¾‹å­çœ‹ä¸€ä¸‹ï¼š\n\nå¯ä»¥çœ‹åˆ°ï¼Œå½“æˆ‘ä»¬åœ¨ä½¿ç”¨ . æ“ä½œç¬¦æ—¶ï¼Œä¼šå¾—åˆ°è‡ªåŠ¨è§£å¼•ç”¨ä¹‹åçš„ç»“æœï¼ˆå€’æ•°ç¬¬ 2 è¡Œï¼‰ï¼Œå¹¶ä¸”æœ€åä¸€è¡Œæˆ‘ä»¬çœ‹åˆ°ï¼Œæ— è®ºæ˜¯å¤šåŠ äº†å¤šå°‘å±‚çš„å¼•ç”¨ï¼Œéƒ½èƒ½å¾—åˆ°æœ€ç»ˆæŒ‡å‘çš„é‚£å—æ•°æ®ã€‚è¿™å°±æ˜¯ . æ“ä½œç¬¦ä¸Šå¸¦æœ‰çš„é­”æ³•ä¹‹ä¸€ â€”â€” è‡ªåŠ¨è§£å¼•ç”¨ã€‚\nä¸ºäº†æ›´å¥½çš„ç†è§£è§£å¼•ç”¨ç‰¹å¾ï¼Œæˆ‘ä»¬æ‰‹åŠ¨è¿˜åŸä¸€ä¸ªè‡ªå·±çš„ MyBox æ™ºèƒ½æŒ‡é’ˆç±»å‹ã€‚\næ‰‹åŠ¨è¿˜åŸ Box æ™ºèƒ½æŒ‡é’ˆé¦–å…ˆï¼ŒMyBox æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œå®ƒåªæœ‰ä¸€ä¸ªå­—æ®µ â€”â€” è¢«ä»–åŒ…è£¹çš„ç±»å‹ï¼Œä¸”ä¸éœ€è¦å­—æ®µåï¼Œå³æˆ‘ä»¬é‡‡ç”¨å…ƒç»„ç»“æ„ä½“ï¼ˆtuple structï¼‰æ„é€  MyBoxã€‚è¿™é‡Œè¿˜éœ€è¦ä½¿ç”¨æ³›å‹ Tï¼Œè¢«åŒ…è£¹çš„ç±»å‹æ˜¯ç”±è°ƒç”¨çš„æ—¶å€™ä¼ å…¥çš„ã€‚\n\n\n\n\n\n\n\n\n\nè¿™ä¸€éƒ¨åˆ†éœ€è¦è¡¥å……æ³›å‹ï¼ˆgenericsï¼‰çš„å†…å®¹ï¼Œå¯ä»¥å‚è€ƒ https://course.rs/basic/trait/generic.html\nä½¿ç”¨æ³›å‹çš„è§„èŒƒæ˜¯ï¼Œå…ˆå£°æ˜ xxx&lt;T&gt; åä½¿ç”¨ structNameXXX(T)ã€functionNameXXX(x: T) ç­‰ã€‚\n1struct MyBox&lt;T&gt;(T);\n\næ¥ç€å®ç° new æ–¹æ³•ï¼Œåœ¨ Rust ä¸­ä½¿ç”¨ impl æ¥å®šä¹‰æ–¹æ³•ï¼Œå¦‚ impl Circle ï¼Œæ³›å‹ç”¨ impl&lt;T&gt; Circle&lt;T&gt; ã€‚\n12345impl&lt;T&gt; MyBox&lt;T&gt; &#123;    fn new(x: T) -&gt; MyBox&lt;T&gt; &#123;        MyBox(x)    &#125;&#125;\n\nä¸‹ä¸€æ­¥ï¼Œåœ¨ MyBox ä¸Šå®ç° deref trait ï¼Œå¯ä»¥å‚è€ƒå®˜ç½‘ Deref Trait ç»™å‡ºçš„ç¤ºä¾‹å®ç°ï¼š\n\n1234567impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123;    type Target = T;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123; // Target å°±æ˜¯ç›®æ ‡ç±»å‹ T        &amp;self.0 // å› ä¸º MyBox æ˜¯å…ƒç»„ç»“æ„ä½“ï¼Œå¯¹åº”çš„å€¼ self.0    &#125;  // æ³¨æ„ï¼šè§£å¼•ç”¨å¹¶ä¸ä¼šæ¶‰åŠæ‰€æœ‰æƒè½¬ç§»ï¼Œè¿”å›çš„å€¼è¿˜æ˜¯ä¸€ä¸ªå¼•ç”¨å€¼&#125;\n\nç°åœ¨æˆ‘ä»¬å°±å¯ä»¥åœ¨ MyBox ç±»å‹å˜é‡ä¸Šä½¿ç”¨è§£å¼•ç”¨åŠŸèƒ½äº†ï¼Œè®©æˆ‘ä»¬è¯•ä¸‹:\n1234567fn main() &#123;    let n = MyBox::new(String::from(&quot;Marnie&quot;));    println!(&quot;&#123;:?&#125;&quot;, n);    let a = String::from(&quot;Marnie&quot;);    println!(&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;, a, *n, a == *n);&#125;\n\n\nä»¥ä¸Šå°±æ˜¯æ¨¡æ‹Ÿ MyBox å¹¶å®ç° Deref Trait çš„å¤§è‡´è¿‡ç¨‹ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨ *v æ—¶ï¼Œå°±ä¼šå» v å¯¹åº”çš„ç±»å‹ T ä¸Šæ‰¾ deref æ–¹æ³•ï¼Œå³ *(v.deref())ï¼Œæ‰€ä»¥ä½†å‡¡æ˜¯å®ç°äº† Deref Trait çš„ç±»å‹å˜é‡éƒ½å¯ä»¥ä½¿ç”¨ * æ“ä½œç¬¦æ¥è§£å¼•ç”¨ã€‚\nåœ¨å®˜ç½‘å…³äºâ€ä½¿ç”¨ Deref Trait å°†æ™ºèƒ½æŒ‡é’ˆåƒå¸¸è§„å¼•ç”¨ä¸€æ ·å¯¹å¾…â€æœ‰å¾ˆè¯¦ç»†çš„ä»‹ç»ï¼Œç»†èŠ‚å¯ä»¥æ›´å¤šçš„å‚è€ƒ https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-traitï¼Œè¿™é‡Œå†æä¸€ç‚¹æ¯”è¾ƒé‡è¦çš„å†…å®¹ï¼š\nImplicit Deref Coerions éšå¼çš„å¼ºåˆ¶è§£å¼•ç”¨åœ¨ Deref Trait ç›¸å…³å†…å®¹ä¸‹ï¼Œæœ‰ä¸€ä¸ªçŸ¥è¯†ç‚¹å« Deref coerion å¼ºåˆ¶è§£å¼•ç”¨ï¼Œæ„æ€æ˜¯åœ¨æŸäº›åœºæ™¯ä¸‹ï¼ŒRust ä¼šè‡ªåŠ¨å‘ç”Ÿè§£å¼•ç”¨ã€‚\nè¿™é‡Œä¼šå‘ç”Ÿè‡ªåŠ¨è§£å¼•ç”¨çš„åœºæ™¯æ˜¯åœ¨å˜é‡ä½œä¸ºå‚æ•°ä¼ å…¥æ–¹æ³• methods æˆ–è€…å‡½æ•° functions æ—¶ï¼Œè‹¥ä¼ å…¥å˜é‡ç±»å‹å®ç°äº† Deref Traitï¼Œå˜ä¼šå‘ç”Ÿè‡ªåŠ¨è§£å¼•ç”¨çš„è¡Œä¸ºã€‚æˆ‘ä»¬åˆ†æçœ‹ä¸‹å®˜æ–¹çš„ä¾‹å­ï¼š\n123fn hello(name: &amp;str) &#123;    println!(&quot;Hello, &#123;&#125;!&quot;, name);&#125;\n\nè¿™é‡Œå†™äº†ä¸€ä¸ª hello å‡½æ•°ï¼Œæ¥æ”¶ string slice ç±»å‹çš„å‚æ•°ï¼Œå¦‚æœæˆ‘ä»¬ç»§ç»­ç”¨å‰é¢ MyBox çš„å®ä¾‹ n ä¼ å…¥ hello å‡½æ•° hello(&amp;n)ï¼Œå¦‚ï¼š\n123456fn main() &#123;    let n = MyBox::new(String::from(&quot;Marnie&quot;)); // MyBox&lt;String&gt;    println!(&quot;&#123;:?&#125;&quot;, n);    hello(&amp;n); // ğŸ¤”...&#125;\n\næˆ‘ä»¬ä¼šå‘ç°ï¼Œç¼–è¾‘å™¨å¹¶æ²¡æœ‰æç¤ºä»»ä½•ç¼–è¯‘é”™è¯¯ï¼Œè¿™é‡Œå°±æ˜¯å¼ºåˆ¶è§£å¼•ç”¨çš„ä½œç”¨ã€‚\né¦–å…ˆï¼Œæˆ‘ä»¬ä¼ å…¥çš„ n æœ¬èº«æ˜¯ä¸ª MyBox&lt;String&gt; ç±»å‹ï¼ŒæŒ‰ç…§å¼ºåˆ¶è§£å¼•ç”¨çš„å‘ç”Ÿè§„åˆ™ â€”â€” å½“æˆ‘ä»¬å°†æŸä¸ªç±»å‹ä½œä¸ºå‚æ•°ä¼ å…¥å‡½æ•°æˆ–è€…æ–¹æ³•æ—¶ï¼Œä¼šè‡ªåŠ¨å‘ç”Ÿè§£å¼•ç”¨ã€‚MyBoxç±»å‹çš„è§£å¼•ç”¨å®ç°æˆ‘ä»¬å‰é¢å·²ç»è¿˜åŸäº†ï¼Œé‚£ä¹ˆè¿™ä¸€æ­¥å¼ºåˆ¶è§£å¼•ç”¨å°±ç›¸å½“äºè°ƒç”¨ n.deref()ï¼Œåˆ™ &amp;n ä» &amp;MyBox&lt;String&gt; -&gt; &amp;Stringï¼Œè¿™ä¹ˆçœ‹èµ·æ¥è¿˜æ˜¯ä¸å¯¹å‘€ï¼Œç›®æ ‡å‚æ•°æ¥æ”¶çš„æ˜¯ String Sliceï¼Œç°åœ¨è¿˜åªæ˜¯ Stringã€‚å¥½ï¼Œè¿™é‡Œæ³¨æ„ ğŸ“¢ï¼Œå½“ç±»å‹ä¸Šå®ç°äº† Deref Trait çš„è¯å¼ºåˆ¶è§£å¼•ç”¨ä¼šä¸€ç›´ç»§ç»­è‡ªåŠ¨å‘ç”Ÿï¼Œå³å¯èƒ½å‘ç”Ÿè¿ç»­çš„è§£å¼•ç”¨ã€‚\næˆ‘ä»¬ä¸Šä¸€æ­¥å¼ºåˆ¶è§£å¼•ç”¨å¾—åˆ°çš„æ˜¯ç±»å‹ Stringï¼Œåœ¨æ ‡å‡†åº“é‡Œ String ä¹Ÿå¯¹åº”å®ç°äº† Deref Trait ï¼Œæ‰€ä»¥ä¼šå†æ¬¡åšå¼ºåˆ¶è§£å¼•ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥æŸ¥çœ‹å®˜ç½‘çœ‹åˆ°æ ‡å‡†åº“ä¸­å¯¹äº String ä¸Š Deref Trait å®ç°çš„ç­¾åæè¿°ï¼š\n\nå¯ä»¥çœ‹åˆ° String çš„ deref æ–¹æ³•è¿”å› string slice ç±»å‹ï¼Œæ‰€ä»¥æ‰æ»¡è¶³äº† hello å‡½æ•°ï¼Œå¹¶ä¸ä¼šæœ‰ç¼–è¯‘é—®é¢˜ã€‚\nå…³äºè¿™ä¸ªè¿ç»­å¼ºåˆ¶è§£å¼•ç”¨ï¼Œæˆ‘å°è¯•å†ç”¨ä¸€äº›è‡ªå®šä¹‰çš„ç±»å‹ä¾‹å­æ¥éªŒè¯ä¸€ä¸‹æ˜¯å¦å¦‚æ­¤ï¼š\n1234567891011121314151617181920212223242526272829303132333435363738394041use std::ops::Deref;struct TypeA(i32); // i32struct TypeB(TypeA); // TypeAstruct TypeC(TypeB); // TypeBimpl Deref for TypeA &#123;    type Target = i32;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;        println!(&quot;calling TypeA&#x27;s deref&quot;);        &amp;self.0    &#125;&#125;impl Deref for TypeB &#123;    type Target = TypeA;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;        println!(&quot;calling TypeB&#x27;s deref&quot;);        &amp;self.0    &#125;&#125;impl Deref for TypeC &#123;    type Target = TypeB;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;        println!(&quot;calling TypeC&#x27;s deref&quot;);        &amp;self.0    &#125;&#125;fn test(x: &amp;i32) &#123;    println!(&quot;I get &#123;&#125;&quot;, x);&#125;fn main() &#123;  let a = TypeA(0);  let b = TypeB(a);  let c = TypeC(b);    test(&amp;c);&#125;\n\næˆ‘å†™äº†ä¸Šè¿°çš„è¿™äº›ä»£ç ï¼Œä¼å›¾éªŒè¯æ˜¯å¦ä¼šæœ‰è¿ç»­çš„å¼ºåˆ¶è§£å¼•ç”¨å‘ç”Ÿã€‚æŒ‰ç…§æˆ‘ä¸Šä¸ªæ®µè½çš„ç»“è®ºï¼Œæˆ‘é¢„æƒ³çš„ å°† c ä½œä¸ºå‚æ•°ä¼ å…¥ test å‡½æ•°ï¼Œc çš„ç±»å‹ TypeC ä¸Šåˆæœ‰ deref trait çš„å®ç°ï¼Œé‚£ä¹ˆè¿ç»­çš„å¼ºåˆ¶è§£å¼•ç”¨å°†ä¼šæ˜¯ TypeC -&gt; TypeB, TypeC -&gt; TypeA, TypeA -&gt; i32ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç¼–è¯‘å™¨é¦–å…ˆå¹¶æ²¡æœ‰æç¤ºç±»å‹é”™è¯¯ï¼Œæˆ‘ä»¬å†è¿è¡Œçœ‹çœ‹ï¼š\n\nå¦‚ç»“æœæ‰€ç¤ºï¼Œå°è¯äº†é¢„æƒ³ï¼Œé‚£ä¹ˆè¿™å°±æ˜¯ä¸€ä¸ªè¿ç»­çš„å¼ºåˆ¶è§£å¼•ç”¨çš„è¿‡ç¨‹ã€‚Rust ä¹‹æ‰€ä¾æä¾›è¿™ä¸ªéšå«çš„åŠŸèƒ½å°±æ˜¯ä¸ºäº†è®©æˆ‘ä»¬çœå»æ‰‹åŠ¨åšâ€è¿ç»­çš„ç±»å‹è½¬æ¢â€çš„è¿‡ç¨‹ã€‚æˆ‘ä»¬å†å¼ºè°ƒä¸€ä¸‹ï¼Œè¿™ä¸ªå¼ºåˆ¶ç±»å‹è½¬æ¢å‘ç”Ÿéœ€è¦ç¬¦åˆçš„æ¡ä»¶ï¼š\n\n&amp;T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt;  T ä¸Šæœ‰è¿”å›ç±»å‹ä¸º U çš„è§£å¼•ç”¨å®ç°\n&amp;mut T -&gt; &amp;mut U ===&gt; T: DerefMut&lt;Target=U&gt;  T ä¸Šæœ‰è¿”å›ç±»å‹ä¸º U çš„å¯å˜è§£å¼•ç”¨å®ç°\n&amp;mut T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt; T ä¸Šæœ‰è¿”å›ç±»å‹ä¸º U çš„è§£å¼•ç”¨å®ç°ï¼ˆå¯å˜çš„ç±»å‹å¯ä»¥è½¬æ¢ä¸ºä¸å¯å˜ç±»å‹ï¼Œä½†ä¸å¯å˜ä¸èƒ½è½¬æ¢æˆå¯å˜ï¼‰\n\nThe Drop Traité™¤äº† Deref Trait å¤–ï¼Œæ™ºèƒ½æŒ‡é’ˆè¿˜æ‹¥æœ‰ Drop Traitã€‚Drop Trait æ˜¯ Rust è®¾è®¡ç”¨äºå†…å­˜ç®¡ç†çš„ç‰¹å¾ï¼Œå½“ä¸€ä¸ªå˜é‡è¶…å‡º scope ä¹‹åï¼Œè‡ªåŠ¨é‡Šæ”¾å…¶å ç”¨çš„å†…å­˜ã€‚Drop Trait çš„å®ç°å’Œ Deref Trait å¼‚æ›²åŒå·¥ï¼Œæœ¬è´¨ä¹Ÿæ˜¯æ‰§è¡Œè¯¥ Trait ä¸‹å¯¹åº”çš„ drop method , å½“æˆ‘ä»¬éœ€è¦è‡ªå®šä¹‰é‡Šæ”¾å†…å­˜çš„åœºæ™¯å°±å¯ä»¥æ‰‹åŠ¨å®ç° drop method ï¼Œè®©æˆ‘ä»¬ä¸€æ ·ç”¨ä¾‹å­çœ‹ä¸€ä¸‹ï¼š\n1234567891011121314151617181920212223use std::ops::Drop;#[derive(Debug)]struct CustomSmartPointer &#123;    data: String,&#125;impl Drop for CustomSmartPointer &#123;    fn drop(&amp;mut self) &#123;        println!(&quot;CustomSmartPointer of data &#123;&#125; is dropping...&quot;, self.data);    &#125;&#125;fn main() &#123;    let c1 = CustomSmartPointer &#123;        data: String::from(&quot;c1&quot;),    &#125;;    println!(&quot;&#123;:?&#125; is created.&quot;, c1);    let c2 = CustomSmartPointer &#123;        data: String::from(&quot;c2&quot;),    &#125;;    println!(&quot;&#123;:?&#125; is created.&quot;, c2);&#125;\n\nè¿è¡Œç»“æœå¦‚ä¸‹ï¼š\n\nç»“åˆæ‰€æœ‰æƒç³»ç»Ÿï¼Œå½“ä¸€ä¸ªå˜é‡ç¦»å¼€ä½œç”¨åŸŸä»¥åŠä¸å­˜åœ¨å¯¹å…¶çš„ä»»ä½•å¼•ç”¨ï¼ŒRust ä¼šè‡ªåŠ¨é‡Šæ”¾å˜é‡å ç”¨çš„å†…å­˜ï¼Œè¿™æ ·å°±æ— éœ€å¼€å‘è€…æ‰‹åŠ¨ç®¡ç†å†…å­˜ã€‚æˆ‘ä»¬ä¸Šé¢çš„ä»£ç å°±å¯ä»¥çœ‹åˆ°è¿™ä¸ªæ•ˆæœï¼Œå†…å­˜é‡Šæ”¾æ˜¯æŒ‰ç…§å˜é‡å‡ºæ ˆé¡ºåºï¼Œå³å…ˆè¿›åå‡ºï¼Œåˆ›å»ºé¡ºåºæ˜¯ c1 -&gt; c2ï¼Œé”€æ¯é¡ºåºåˆ™æ˜¯ c2 -&gt; c1ï¼Œå¦‚æ‰“å°ç»“æœæ‰€ç¤ºã€‚\nè¿™é‡Œæœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œå› ä¸º Rust å·²ç»æœ‰ä¸€å¥—åˆç†ç®¡ç†å†…å­˜çš„æœºåˆ¶ â€”â€” ç¦»å¼€ä½œç”¨åŸŸå†…å­˜ä¼šè‡ªåŠ¨è¢«é‡Šæ”¾ï¼Œæ‰€ä»¥æ˜¯ä¸æ”¯æŒæˆ‘ä»¬ç›´æ¥æ‰‹åŠ¨è°ƒç”¨ xxx.drop() æ¥é‡Šæ”¾å†…å­˜çš„ï¼Œè¿™æ ·ä¼šå¯¼è‡´åŒé‡é‡Šæ”¾å†…å­˜çš„é”™è¯¯ï¼ˆa double free errorï¼‰ã€‚\nTrait Objectsè™½ç„¶ Rust å¼ºè°ƒé™æ€ç±»å‹ç¼–è¯‘ï¼Œéœ€è¦æœ‰æ˜ç¡®çš„æ•°æ®ç±»å‹ï¼Œä½†ä¸ºäº†å®ç°ä»£ç çš„å¤šæ€æ€§ï¼ŒRust ä¹Ÿæä¾›äº†ä¸€ç§æ–¹æ¡ˆå¯ä»¥åŠ¨æ€è°ƒåº¦ï¼ˆdynamic dispatchï¼‰ç±»å‹ï¼Œå®ƒå°±æ˜¯ Trait Objectsã€‚é¦–å…ˆæˆ‘ä»¬ç†è§£ä¸€ä¸‹ä»€ä¹ˆæ˜¯åŠ¨æ€è°ƒåº¦ï¼š\nDynamic dispatch åŠ¨æ€è°ƒåº¦åŠ¨æ€è°ƒåº¦è¡¨ç¤ºåœ¨ç¼–è¯‘æ—¶å¹¶ä¸çŸ¥é“å…·ä½“ç±»å‹ï¼Œè€Œæ˜¯åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šç±»å‹ã€‚å®ƒä¸ static dispatch ç›¸å¯¹ï¼Œstatic dispatch é™æ€è°ƒåº¦æ˜¯æŒ‡åœ¨ç¼–è¯‘æ—¶å°±å·²ç»ç¡®å®šäº†ç±»å‹ï¼Œä¸€èˆ¬æˆ‘ä»¬æ²¡æœ‰ç‰¹åˆ«å¤„ç†çš„éƒ½å±äºé™æ€è°ƒåº¦ï¼Œå˜é‡çš„ç±»å‹æ˜¯æ˜ç¡®çš„ï¼Œå‡½æ•°çš„å…¥å‚ç±»å‹ä¹Ÿæ˜¯ç¡®å®šçš„ï¼Œæ‰€æœ‰çš„ç±»å‹éƒ½æ˜¯ç¼–è¯‘æ—¶å°±å·²ç»å›ºå®šäº†çš„ã€‚è€ŒåŠ¨æ€è°ƒåº¦éœ€è¦ä½¿ç”¨å…³é”®å­— dyn ï¼Œæ¥è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªåŠ¨æ€è°ƒåº¦ç±»å‹ï¼Œæˆ‘ä»¬éœ€è¦ç»“åˆ Trait Objects è¿™ä¸ªæ¦‚å¿µä¸€èµ·ä½¿ç”¨ã€‚\nTrait Objects æ˜¯ Rust æä¾›åº”å¯¹æœ‰ç€åŒæ ·è¡Œä¸ºçš„ä½†æ‰€å±ä¸åŒç±»å‹çš„å˜é‡çš„äº‹åŠ¡ï¼Œç”¨å®˜æ–¹çš„ä¾‹å­ï¼Œæ¯”å¦‚æˆ‘ä»¬ç°åœ¨è¦å®ç°ä¸€ä¸ªå‰ç«¯æ¡†æ¶åº“ï¼Œæˆ‘ä»¬ä¼šæ‹¥æœ‰å¾ˆå¤š components ç»„ä»¶ï¼Œæ¯ä¸ªç»„ä»¶éƒ½æ˜¯ä¸€ä¸ªç±»å‹ã€‚\nå› ä¸ºç»„ä»¶ä¼šæœ‰å¾ˆå¤šç§ï¼Œæ¯”å¦‚ Buttonã€Selectã€Inputï¼Œæˆ‘ä»¬åœ¨å£°æ˜ components ç±»å‹çš„æ—¶å€™ï¼Œé¦–å…ˆå®ƒæ˜¯ä¸ªå¯ä»¥æ›´æ”¹é•¿åº¦çš„ listï¼Œæ‰€ä»¥ components: vec![???]ï¼Œå¥½äº†ï¼Œè¿™é‡Œå°±æœ‰ä¸€ä¸ªé—®é¢˜å‡ºç°äº†ï¼vec! é‡Œé¢çš„ç±»å‹å¹¶ä¸æ˜¯æˆ‘ä»¬ä»¥å¾€å›ºå®šçš„æŸä¸€ç§ç±»å‹ï¼Œå®ƒå¯èƒ½æ˜¯ Button/Input/Select ç­‰ç­‰ï¼Œè¿™ç§æƒ…å†µæˆ‘ä»¬å°±éœ€è¦ä½¿ç”¨åŠ¨æ€è°ƒåº¦ï¼Œè¡¨ç¤ºè¿™é‡Œçš„ç±»å‹ä¸æ˜¯æŸä¸€ä¸ªå›ºå®šç±»å‹ï¼Œæ˜¯å¤šç§ç±»å‹ã€‚\nå…·ä½“ä½¿ç”¨æ–¹å¼ï¼Œç”¨ dyn å…³é”®å­—è¡¨ç¤ºè¿™é‡Œæ˜¯åŠ¨æ€è°ƒåº¦ï¼Œdyn åé¢è·Ÿçš„ç±»å‹æ˜¯ä¸€ä¸ª traitï¼Œdyn xxxTrait åˆ™è¡¨ç¤ºå½“å‰æ˜¯ä¸€ä¸ª trait objects ç±»å‹ã€‚traitï¼ˆç‰¹å¾ï¼‰æˆ‘ä»¬åœ¨ä¸Šé¢æœ‰å•ç‹¬ä»‹ç»ï¼Œå®ƒç”¨æ¥æè¿°æŸç§è¡Œä¸ºï¼Œé‚£ä¹ˆ trait objects å…¶å®å°±æ˜¯æ‹¥æœ‰åŒç§è¡Œä¸ºçš„ä¸åŒç±»å‹çš„å¯¹è±¡ï¼Œæœ¬è´¨å°±æ˜¯ä¸åŒç±»å‹éƒ½å¯¹åŒä¸€ä¸ª trait è¿›è¡Œäº†å®ç°ã€‚æˆ‘ä»¬ä¸Šé¢è¿™ä¸ªç»„ä»¶çš„ä¾‹å­ï¼Œå°±æ˜¯ Trait Objects çš„ä¸€ä¸ªæ ‡å‡†æ¡ˆä¾‹ï¼Œç»„ä»¶æœ¬èº«éƒ½æ˜¯ä¸åŒçš„ç±»å‹ï¼Œä½†æ˜¯å®ƒä»¬éƒ½è‡³å°‘æœ‰æŸä¸ªæˆ–æŸäº›ç›¸åŒçš„è¡Œä¸ºï¼Œæ¯”å¦‚ç»˜åˆ¶åŠŸèƒ½ï¼Œé‚£ä¹ˆå®ç°æ—¶å°±å¯ä»¥æŠŠç»˜åˆ¶ä½œä¸ºä¸€ä¸ª traitï¼Œè¿™äº›ç»„ä»¶éƒ½æœ‰å¯¹äº ç»˜åˆ¶trait çš„å®ç°ï¼Œè¿™äº›ç»„ä»¶ä¾¿å¯ä»¥é€šè¿‡ dyn Draw è§†ä¸ºåŒä¸€ä¸ª trait object ç±»å‹ã€‚ä½†å› ä¸º trait æœ¬èº«æ²¡æœ‰å›ºå®šå¤§å°ï¼Œæ‰€ä»¥å®ƒå¿…é¡»ç»“åˆæŒ‡é’ˆç±»å‹ä½¿ç”¨ï¼ˆæŒ‡é’ˆç±»å‹æ‹¥æœ‰å›ºå®šå¤§å°ï¼‰ï¼Œå¦‚ Box&lt;dyn Draw&gt; è¡¨ç¤º Draw trait objects ç±»å‹ã€‚\nç”¨è¿™ä¸ªåœºæ™¯ï¼Œæˆ‘ä»¬å…·ä½“å®ç°ä¸‹ä»£ç æ¥ç†è§£ï¼š\n1234567891011121314151617181920212223242526272829303132333435363738// ç»˜åˆ¶traittrait Draw &#123;  fn draw(&amp;self);&#125;// Buttonç±»å‹struct Button &#123;  width: u32,  height: u32,  label: String,&#125;// Selectç±»å‹struct Select &#123;  width: u32,  height: u32,  options: Vec&lt;String&gt;,&#125;// éƒ½ä¼šç»§æ‰¿ç»˜åˆ¶traitimpl Draw for Button &#123;  fn draw(&amp;self) &#123;    // do Button&#x27;s drawing stuff   &#125;&#125;// éƒ½ä¼šç»§æ‰¿ç»˜åˆ¶traitimpl Draw for Select &#123;  fn draw(&amp;self) &#123;    // do Select&#x27;s drawing stuff   &#125;&#125;// æ¡†æ¶åº“ç±»struct Library &#123;  // components list  components: Vec&lt;Box&lt;dyn Draw&gt;&gt;, // a list of &quot;Draw trait objects&quot;&#125;\n\nè¿™å°±æ˜¯ã€åŠ¨æ€è°ƒåº¦ + trait objectsã€‘çš„ä½¿ç”¨æ–¹æ³•ï¼Œè¿™ç§æ–¹å¼æœ¬è´¨ä¸Šå…¶å®æ˜¯è®©æˆ‘ä»¬æœ‰äº†å¯ä»¥åŒæ—¶ä½¿ç”¨ä¸åŒçš„ç±»å‹çš„èƒ½åŠ›ï¼Œè¿™å°±æ˜¯åŠ¨æ€è°ƒåº¦çš„é­”æ³•ã€‚å’Œæ³›å‹ï¼ˆgenericsï¼‰çš„ä¸åŒä¹‹å¤„å°±æ˜¯è¿™é‡Œï¼Œæ³›å‹åªæ˜¯å£°æ˜æ—¶çš„å¤šæ€ï¼Œåœ¨è°ƒç”¨æ—¶ä¸€æ¬¡ä¼ å…¥çš„è¿˜åªæ˜¯åŒä¸€ä¸ªç±»å‹ï¼Œè€ŒåŠ¨æ€è°ƒåº¦æ˜¯ä¸€æ¬¡è°ƒç”¨èƒ½ä¼ å…¥å¤šç§ç±»å‹ï¼Œå®ç°äº†çœŸæ­£çš„è¿è¡Œæ—¶å¤šæ€ã€‚\nç»ƒä¹ ä½œä¸š2\nå®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163use std::ops::DerefMut;use colored::Colorize;fn main() &#123;    trait FileSystem &#123;        // type Output;        fn create_file(&amp;mut self, name: &amp;str) -&gt; &amp;Node;        fn create_folder(&amp;mut self, name: &amp;str) -&gt; &amp;Node;        fn list_contents(&amp;self);        fn find_folder(&amp;mut self, name: &amp;str) -&gt; Option&lt;&amp;mut Self&gt;;    &#125;    #[derive(Debug)]    enum Node &#123;        // æ–‡ä»¶        File(String),        // æ–‡ä»¶å¤¹        Folder(FolderNode),    &#125;    #[derive(Debug)]    struct FolderNode &#123;        name: String,        contents: Vec&lt;Box&lt;Node&gt;&gt;,    &#125;    impl FileSystem for FolderNode &#123;        // åœ¨å½“å‰æ–‡ä»¶å¤¹ä¸‹åˆ›å»ºå•ä¸ªæ–‡ä»¶        fn create_file(&amp;mut self, name: &amp;str) -&gt; &amp;Node &#123;            self.contents.push(Box::new(Node::File(String::from(name))));            println!(&quot;/&#123;&#125; æ·»åŠ æ–‡ä»¶ &#123;&#125;&quot;, self.name, name);            self.contents.last().unwrap()        &#125;        // åœ¨å½“å‰æ–‡ä»¶å¤¹ä¸‹åˆ›å»ºæ–‡ä»¶å¤¹        fn create_folder(&amp;mut self, name: &amp;str) -&gt; &amp;Node &#123;            self.contents.push(Box::new(Node::Folder(FolderNode &#123;                name: String::from(name),                contents: vec![],            &#125;)));            println!(&quot;/&#123;&#125; æ·»åŠ æ–‡ä»¶å¤¹ &#123;&#125;&quot;, self.name, name);            self.contents.last().unwrap()        &#125;        // è¿”å›å€¼æ˜¯ä¸€ä¸ªå¯å˜çš„ FolderNodeï¼Œå› ä¸ºå¯èƒ½éœ€è¦ç»§ç»­ä¿®æ”¹ folder å†…å®¹        fn find_folder(&amp;mut self, target_name: &amp;str) -&gt; Option&lt;&amp;mut FolderNode&gt; &#123;            // å£°æ˜è¿”å›å€¼ä¸ºå¯å˜çš„ï¼Œåˆå§‹ä¸º None            let mut target: Option&lt;&amp;mut FolderNode&gt; = None;            // éå†å­ç›®å½•ï¼Œiter_mut() å…è®¸è¿”å›å¯å˜çš„éå†å¯¹è±¡            for node in self.contents.iter_mut() &#123;                // deref_mut() å…è®¸è¿”å›è§£å¼•ç”¨åå¹¶å¯å˜çš„å€¼                match node.deref_mut() &#123;                    Node::Folder(folder) =&gt; &#123;                        if folder.name == target_name &#123;                            target = Some(folder);                            break;                        &#125;                    &#125;                    _ =&gt; &#123;                        continue;                    &#125;                &#125;            &#125;            // log error            if target.is_none() &#123;                println!(&quot;&#123;&#125;&quot;, &quot;[ERR] Cannot find this folder!&quot;.red());            &#125;            target        &#125;        // åˆ—å‡ºæ–‡ä»¶å¤¹ä¸‹æ‰€æœ‰æ–‡ä»¶å’Œæ–‡ä»¶å¤¹ï¼ˆé€’å½’ recursionï¼‰        fn list_contents(&amp;self) &#123;            println!(&quot;======== /&#123;&#125; å½“å‰ç›®å½•ç»“æ„ ========&quot;, self.name);            // print current folder name            println!(&quot;/&#123;&#125;&quot;, self.name);            // æ‰“å°å•ä¸ª node ä¸‹çš„å†…å®¹ï¼Œå› ä¸ºéœ€è¦æ‰“å°ç›®å½•ç»“æ„ï¼Œå­ç›®å½•éœ€è¦ä½¿ç”¨é€’å½’            fn print_node(level: usize, node: &amp;Node) &#123;                // é™¤ root å¤–ï¼ˆéæ ¹ç›®å½•ï¼‰ï¼Œç›®å½•ç»“æ„å‰ç¼€é€çº§æ·»åŠ  &#x27;|[][][][]&#x27;                let mut level_prefix = String::with_capacity(5 * level);                // level &gt; 1 need append space prefix                for _ in 1..(level) &#123;                    level_prefix.push_str(&quot;|    &quot;);                &#125;                match node &#123;                    // å½“å‰ node æ˜¯æ–‡ä»¶ï¼Œæ²¡æœ‰å­ç›®å½•                    Node::File(file_name) =&gt; &#123;                        // print current file name                        println!(&quot;&#123;&#125;&#123;&#125;&quot;, level_prefix, file_name);                    &#125;                    // å½“å‰ node æ˜¯æ–‡ä»¶å¤¹ï¼Œå­ç›®å½•éœ€è¦ç»§ç»­è°ƒç”¨ print_node                    Node::Folder(folder) =&gt; &#123;                        // print current folder name                        println!(&quot;&#123;&#125;/&#123;&#125;&quot;, level_prefix, folder.name);                        folder                            .contents                            .iter()                            .for_each(|n| print_node(level + 1, n));                    &#125;                &#125;;            &#125;            match self.contents.len() &#123;                // ç©ºæ–‡ä»¶å¤¹                0 =&gt; &#123;                    return;                &#125;                // å½“å‰ä¸ºæœ‰å†…å®¹çš„æ–‡ä»¶å¤¹                _ =&gt; &#123;                    for (_, content) in self.contents.iter().enumerate() &#123;                        // å½“å‰æ–‡ä»¶å¤¹ level 1ï¼Œå­æ–‡ä»¶å¤¹ initial level = 2                        print_node(2, &amp;content);                    &#125;                &#125;            &#125;            println!(&quot;================ END =================&quot;);            println!();        &#125;    &#125;    let mut root = FolderNode &#123;        name: String::from(&quot;root&quot;),        contents: Vec::new(),    &#125;;    // base on root    &#123;        root.create_file(&quot;file_1.txt&quot;);        root.create_file(&quot;file_2.txt&quot;);        root.create_folder(&quot;folder_1&quot;);        root.create_folder(&quot;folder_2&quot;);        root.list_contents();    &#125;    // base on root/folder_1    &#123;        let folder_1 = root.find_folder(&quot;folder_1&quot;).unwrap();        folder_1.create_file(&quot;file_11.txt&quot;);        folder_1.create_file(&quot;file_12.txt&quot;);        folder_1.create_folder(&quot;folder_11&quot;);        folder_1.list_contents();        let folder_11 = folder_1.find_folder(&quot;folder_11&quot;).unwrap();        folder_11.create_folder(&quot;folder_111&quot;);        folder_11.list_contents();    &#125;    // base on root/folder_2    &#123;        let folder_2 = root.find_folder(&quot;folder_2&quot;).unwrap();        folder_2.create_file(&quot;file_21.txt&quot;);        folder_2.create_file(&quot;file_22.txt&quot;);        folder_2.create_folder(&quot;folder_21&quot;);        folder_2.list_contents();    &#125;    root.list_contents();    &#123;        println!(&quot;Test finder_folder error case&quot;);        root.find_folder(&quot;not_exist&quot;);    &#125;&#125;\n\nè¿è¡Œç»“æœ\n","slug":"smart-pointers","date":"2024-10-24T07:41:13.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"1f5f42bbe18d84ce044c457f49d8e22c","title":"Rust åŸºç¡€ Rust Basic","content":"å…¥é—¨ Getting StartedRusté™æ€ç±»å‹è¯­è¨€ï¼ˆstatically typedï¼‰ï¼šåœ¨ç¼–è¯‘æ—¶å°±ç¡®å®šäº†æ‰€æœ‰è¡¨è¾¾å¼çš„ç±»å‹\nå¼ºç±»å‹è¯­è¨€ï¼ˆstrongly typedï¼‰ï¼šä¸€åˆ‡çš†éœ€è¦æ˜ç¡®çš„ç±»å‹å£°æ˜\n\nrustcï¼šrust ç¼–è¯‘å™¨ï¼ˆcompilerï¼‰\n\næ£€æŸ¥ rust æ˜¯å¦å®‰è£…æˆåŠŸï¼šrustup --version\nå°†æŸä¸ª rust æ–‡ä»¶ç¼–è¯‘æˆäºŒè¿›åˆ¶ï¼ˆbinaryï¼‰æ–‡ä»¶ï¼šrustc &lt;file_name&gt;.rs\n\n\nrustupï¼šrust å®‰è£…å™¨å’Œç‰ˆæœ¬ç®¡ç†å·¥å…·\n\nrustup update å‡çº§ rust\nrustup doc æ‰“å¼€æœ¬åœ° rust æ–‡æ¡£\n\n\nå‘½åè§„åˆ™ï¼ˆnaming ruleï¼‰ï¼šè›‡å½¢å¼ï¼ˆsnake_caseï¼‰\n\nè¯­å¥ï¼ˆstatementï¼‰ï¼šä¸€å®šè¦åŠ åˆ†å·ï¼ˆsemicolonï¼‰ï¼Œè¡¨ç¤ºæ‰§è¡ŒæŸä¸ªæ“ä½œä½†æ²¡æœ‰è¿”å›å€¼çš„æŸä¸ªæŒ‡ä»¤\n\nè¡¨è¾¾å¼è¯­å¥ï¼šä»¥åˆ†å·ç»“å°¾çš„è¡¨è¾¾å¼\nå£°æ˜è¯­å¥\n\n\nè¡¨è¾¾å¼ï¼ˆexpressionï¼‰ï¼šä¸»è¦ç”¨äºè®¡ç®—æ±‚å€¼ï¼ˆexpression-base languageï¼‰\n\n\nCrateç”¨ rust å†™çš„åº“æˆ–è€…å¯æ‰§è¡Œç¨‹åº a rust library or executable program\ncrate.io - rust å®˜æ–¹åŒ…æ³¨å†Œè¡¨\nCargorust åŒ…ç®¡ç†å™¨ rust package manager\n\næ”¯æŒç®¡ç†é¡¹ç›®ä¾èµ– cargo update\næ”¯æŒç¼–è¯‘ã€è¿è¡Œé¡¹ç›® cargo build, cargo run\næ”¯æŒä¸Šä¼  crates.io cargo publish\nCargo.tomlï¼šdependencies declaration file\n\n1234567891011// setup a new project dircargo new &lt;project_name&gt;// compile project [debug or release version]cargo build [--release]// compile project and execute [debug or release version]cargo run [--release]// update all dependencies (keep semi-version 0.8.5 -&gt; 0.8.latest)cargo update\n\né€šç”¨æ¦‚å¿µ Common Conceptså˜é‡ Variablesé»˜è®¤éƒ½æ˜¯ä¸å¯å˜å˜é‡ï¼ˆimmutable variablesï¼‰ï¼Œä¸ç”¨å£°æ˜ç±»å‹\n12let x = 5;println!(&quot;The value of x is: &#123;&#125;&quot;, x);\n\nå£°æ˜å¯å˜å˜é‡ï¼ˆmutable variablesï¼‰ï¼Œåœ¨è¿è¡Œæ—¶æ‰ä¼šç¡®å®šå˜é‡çš„å€¼\n12345let mut x = 5;println!(&quot;The value of x is: &#123;&#125;&quot;, x);x = 6; // è‹¥è¿™å¥ä¸è¿è¡Œï¼Œåˆ™ x å€¼è¿˜æ˜¯ 5println!(&quot;The value of x is: &#123;&#125;&quot;, x);\n\nä½œç”¨åŸŸè§„åˆ™ Scoping Rulesä½œç”¨åŸŸæ˜¯ä¸€ä¸ªå˜é‡åœ¨ç¨‹åºä¸­çš„æœ‰æ•ˆèŒƒå›´ï¼Œä»å˜é‡å£°æ˜çš„ç‚¹å¼€å§‹çŸ¥é“å½“å‰ä½œç”¨åŸŸçš„ç»“æŸå°±æ˜¯ä¸€ä¸ªæœ‰æ•ˆèŒƒå›´ã€‚\nä½œç”¨åŸŸèŒƒå›´ä¸€èˆ¬åˆ†ä¸º å‡½æ•°ä½œç”¨åŸŸã€ä»£ç å—ä½œç”¨åŸŸã€‚\nä¸å¯å˜å˜é‡ã€å¯å˜å˜é‡ã€å¸¸é‡éƒ½æ˜¯éµå¾ªè¿™ä¸ªä½œç”¨åŸŸè§„åˆ™\n123456789101112fn foo() &#123;  let foo_global_variable :i32 = 1;    &#123;    // the start of the block    let foo_local_variable :i32 = 2; // defined in current block, only can access in current block    println!(&quot;The value of foo_global_variable is: &#123;&#125;&quot;, foo_global_variable); // âœ… access anywhere within foo_block    println!(&quot;The value of foo_local_variable is: &#123;&#125;&quot;, foo_local_variable);  &#125; // the end of the block    println!(&quot;The value of foo_local_variable is: &#123;&#125;&quot;, foo_local_variable); // âŒ outer of the block&#125;\n\né®è”½ Shadowinglet ä¸å¯å˜å˜é‡æ”¯æŒé‡å®šä¹‰ï¼ˆé®è”½ shadowingï¼‰ï¼šè™½ç„¶æ˜¯ä¸å¯å˜å˜é‡ï¼Œä½†æ˜¯å¯ä»¥ç”¨è¿‡å»çš„å€¼é‡æ–°èµ‹å€¼ï¼Œä¸”å¯æ›´æ”¹ç±»å‹ï¼ˆä¸ mut çš„ä¸åŒä¹‹å¤„ï¼‰\n12let spaces = &quot;   &quot;;let spaces = spaces.len();\n\nå—å†…é®è”½ï¼ˆshadowingï¼‰ä¹Ÿéµå¾ªä½œç”¨åŸŸè§„åˆ™ï¼Œå—å†…é‡å®šä¹‰å˜é‡çš„æ“ä½œç»“æœå¯¹å¤–æ˜¯å±è”½çš„ï¼Œåœ¨å—å¤–è®¿é—®åˆ°çš„è¿˜æ˜¯åŸå€¼\n123456789101112fn foo() &#123;    let x: i32 = 1;    &#123;        // the start of the block       // é®è”½ï¼ˆshadowingï¼‰        let x = x + 1;        println!(&quot;The value of x is: &#123;&#125;&quot;, x); // âœ… The value of x is: 2    &#125; // the end of the block    println!(&quot;The value of x is: &#123;&#125;&quot;, x); // âœ… The value of x is: 1&#125;\n\nå¸¸é‡ Constantså£°æ˜å¸¸é‡å¿…é¡»è¦å¸¦ç±»å‹ï¼ˆdata typesï¼‰æ³¨é‡Šï¼ˆannotationï¼‰ï¼Œåœ¨ç¼–è¯‘æ—¶æœŸå°±ç¡®å®šäº†å˜é‡çš„å€¼ï¼Œå‘½åè§„èŒƒå¤§å†™è›‡å½¢å¼ï¼ˆUPPER_SNAKE_CASEï¼‰\nç¼–è¯‘åæ˜¯ç›´æ¥æ›¿æ¢å€¼\n1234// u32: unsigned 32-bit integer æ— ç¬¦å·32ä½æ•´æ•°const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;println!(&quot;&#123;&#125;&quot;, THREE_HOURS_IN_SECONDS); // ğŸ¯ ç¼–è¯‘åï¼šprintln!(&quot;&#123;&#125;&quot;, 60 * 60 * 3)\n\né™æ€å˜é‡ Staticç‰¹ç‚¹å¦‚ä¸ŠåŒå¸¸é‡\nä½œç”¨åŸŸï¼ˆscopeï¼‰ï¼šåœ¨æ•´ä¸ªç¨‹åºä¸­å…±äº«ï¼Œå¯ä»¥å†å¤šä¸ªçº¿ç¨‹ä¹‹é—´å…±äº« â€”â€” å³ å…¨å±€å˜é‡ï¼ï¼\nç¼–è¯‘åæ˜¯æŒ‡å‘å¼•ç”¨åœ°å€\n123static A : i32 = 1; // å‡è®¾è¿™ä¸ª static å˜é‡åˆ†é…çš„å†…å­˜åœ°å€ä¸º 0x123println!(&quot;&#123;&#125;&quot;, A); // ğŸ¯ ç¼–è¯‘åï¼šå­˜åœ¨å¯¹ A çš„å¼•ç”¨ï¼ŒæŒ‡å‘ A çš„å†…å­˜åœ°å€\n\næ•°æ®ç±»å‹ Data TypesåŸå§‹ç±»å‹ Primitive Typesæ•´æ•°å‹ Integer Typesé»˜è®¤ i32\nå¦‚æœå¯èƒ½æ˜¯è´Ÿæ•°åˆ™ç”¨ i[bit]ï¼Œåä¹‹ç”¨ u[bit]ï¼Œä½æ•°ç”±è¿è¡Œä»£ç çš„ç”µè„‘å†³å®š\n1// TODO: äºŒè¿›åˆ¶ä½æ•°å’Œ[æ•´/è´Ÿ]æ•°å¤§å°èŒƒå›´çš„å…³ç³»\n\næµ®ç‚¹æ•°å‹ Floating-Point Typesé»˜è®¤ f64\n12let x = 2.0; // f64let y: f32 = 3.0; // f32\n\nå¸ƒå°”å‹ The Boolean Types123// both are ğŸ‘ŒğŸ»let a = true;let b: bool = true;\n\næ–‡æœ¬ç±»å‹ Textual Typeschar å­—ç¬¦å‹\nunicode ç¼–ç ï¼Œ1 char &#x3D; 4 bytesï¼Œé»˜è®¤å•å¼•å·åŒ…è£¹çš„æ–‡å­—ï¼ˆå•ä¸ªæ–‡å­—ï¼‰è¡¨ç¤ºå­—ç¬¦å‹å˜é‡ï¼Œä¹Ÿå¯ä»¥æ˜¾å¼å£°æ˜ç±»å‹,\n123let c = &#x27;z&#x27;;let z: char = &#x27;â„¤&#x27;;let heart_eyed_cat = &#x27;ğŸ˜»&#x27;;\n\nå¤åˆç±»å‹ Compound TypesğŸ•µğŸ»â€â™‚ï¸ ï¼šä¸‹é¢å­—ç¬¦ä¸²ç±»å‹å»ºè®®çœ‹å®Œæ‰€æœ‰æƒéƒ¨åˆ†çŸ¥è¯†ï¼Œå†å»ç†è§£æ¯”è¾ƒå¥½ï¼ï¼\nCharacter encoding format\nASCIIï¼š1 character &#x3D; 7 bits binaryï¼Œtotal 128 charactersï¼ˆmax decimal number of 7-bit binary numberï¼‰\nUTF-8ï¼š1 character &#x3D; 1ï½4 bytes &#x3D; (1ï½4) x 8 bitsï¼Œtotal 1,112,064 character\n\nğŸ¯ TODOï¼šMemory management &amp; ownership in Rust\nhttps://www.linkedin.com/pulse/memory-management-rust-amit-nadiger#:~:text=The%20.,string%20literals%20and%20other%20constants.\nã€TODOã€‘compile binary â€“&gt; read-only memory æ˜¯ä»€ä¹ˆï¼Ÿ\nã€TODOã€‘Machine words æ˜¯ä»€ä¹ˆï¼Ÿ\nã€TODOã€‘Rc smart pointer  reference counted pointer\nVisualizing memory layout of Rustâ€™s data types\nString æ–‡æœ¬å­—ç¬¦ä¸²å‹ä¸€ä¸²åŠ¨æ€é•¿åº¦çš„ UTF-8 ç¼–ç åºåˆ—ï¼Œç”¨æ¥è¡¨ç¤ºæ–‡æœ¬å­—ç¬¦ä¸²ã€‚UTF-8 ç¼–ç è§„åˆ™ç”¨ 1ï½4 ä¸ªå­—èŠ‚è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ï¼Œæ˜¯é»˜è®¤æ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ã€‚\nåŠ¨æ€åˆ†é…å¤§å°æ‰€ä»¥å­˜å‚¨åœ¨ heap ä¸Šï¼Œå¯¹åº”æ ˆä¸Šçš„å˜é‡å­˜å‚¨æŒ‡é’ˆï¼ˆptr &#x3D; å†…å­˜åœ°å€ï¼‰ã€é•¿åº¦ï¼ˆlen &#x3D; å®é™…é•¿åº¦ï¼‰ã€å®¹é‡ï¼ˆcapacity &#x3D; å¯ç”¨é•¿åº¦ï¼‰ã€‚\n123456789// String ç±»å‹å€¼å†…ç½®äº†ä¿®æ”¹å’Œå…¶ä»–çš„å„ç§æ–¹æ³•// mutable variablelet mut s: String = String::from(&quot;hello&quot;);// modify string ss.push(&#x27;!&#x27;);// replace first character of string ss.replace_range(0..1, &quot;H&quot;);// check the resultprintln!(&quot;s = &#123;&#125;&quot;, s);  // âœ… è¾“å‡ºï¼šs = Hello!\n\nString Slice æ–‡æœ¬å­—ç¬¦ä¸²åˆ‡ç‰‡ç±»å‹æˆ‘ä»¬æŠŠæŸä¸ªå­—ç¬¦ä¸²çš„æŸæ®µå­—ç¬¦ä¸²ç§°ä¸º sliceï¼ˆå­—ç¬¦ä¸²åˆ‡ç‰‡&#x2F;å­—ç¬¦ä¸²ç‰‡æ®µï¼‰ã€‚ä¸Šé¢æåˆ°çš„ï¼Œæ–‡æœ¬å­—ç¬¦ä¸²æœ¬èº«æ˜¯åŠ¨æ€é•¿åº¦çš„ UTF-8 ç¼–ç åºåˆ—ï¼Œä¸”æ‹¥æœ‰æ•°æ®çš„æ‰€æœ‰æƒã€‚å½“æˆ‘ä»¬åªéœ€è¦å€Ÿç”¨å­—ç¬¦ä¸²æ–‡æœ¬æ•°æ®æœ¬èº«æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ &amp;str ç±»å‹ï¼Œå®ƒåŒ…å«æŒ‡é’ˆï¼ˆptr &#x3D; è¯¥ slice ç¬¬ä¸€ä¸ªå­—ç¬¦åœ¨å†…å­˜ä¸­å¯¹åº”çš„åœ°å€ï¼‰ã€é•¿åº¦ï¼ˆlen &#x3D; ä»ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹ï¼Œä¸€å…±å¤šå°‘ä¸ªå­—ç¬¦ï¼‰ï¼Œslice å› ä¸ºæ˜¯å€Ÿç”¨å…³ç³»ï¼Œæœ¬èº«æ˜¯ä¸å¯å˜çš„ã€‚å­—ç¬¦ä¸²æœ¬èº«æ˜¯åŠ¨æ€å¤§å°çš„ç±»å‹ï¼Œæœ‰äº† slice çš„å€Ÿç”¨ç±»å‹ä¹‹åï¼Œç¼–è¯‘æ—¶å°±å¯ä»¥è®¡ç®—å‡ºå¯¹åº”å­—ç¬¦ä¸²æ‰€å å­—èŠ‚å¤§å°ï¼Œè¿™å¯¹ Rust è¿™ç§å¼ºé™æ€ç¼–è¯‘è¯­è¨€æ˜¯å¿…éœ€çš„ã€‚å®ƒæœ‰ä¸¤ç§å…·ä½“ä½¿ç”¨åœºæ™¯ï¼š\n\næ™®é€šæ–‡æœ¬å­—ç¬¦ä¸²ï¼ˆstring literalï¼‰ï¼šä¸å¯ä¿®æ”¹\nä½œä¸ºæŸä¸ª String ç±»å‹çš„åˆ‡ç‰‡å­—ç¬¦ä¸²ï¼šä¸å¯ä¿®æ”¹\n\nå¯ä»¥çœ‹åˆ°ï¼Œéƒ½æ˜¯ä¸å¯ä¿®æ”¹ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬æœ‰è¦ä¿®æ”¹å­—ç¬¦ä¸²çš„è®¡åˆ’ï¼Œæˆ‘ä»¬å°±åº”è¯¥ä½¿ç”¨ä¸Šé¢ String ç±»å‹ï¼Œè€Œä¸ä¿®æ”¹çš„è¯å°±é€‰æ‹© &amp;str ç±»å‹ã€‚\n12345678910111213141516171819202122232425262728fn str_and_string() &#123;    // æ™®é€šæ–‡æœ¬å­—ç¬¦ä¸² string literals    let normal_str = &quot;hello, &quot;;    // å¯æ“ä½œçš„ã€æ‹¥æœ‰æ‰€æœ‰æƒçš„ String ç±»å‹å­—ç¬¦ä¸²    let mut mutable_string = String::from(normal_str);    // a string slice of String, æ²¡æœ‰ä¿®æ”¹å­—ç¬¦ä¸²çš„è®¡åˆ’    let hello = &amp;mutable_string[0..5];    println!(&quot;hello = &#123;&#125;&quot;, hello);    // ä¿®æ”¹å­—ç¬¦ä¸² &amp;mut æ‰èƒ½ä¿®æ”¹    do_some_mutation(&amp;mut mutable_string);    // åªéœ€è¦å€Ÿç”¨å­—ç¬¦ä¸²çš„å€¼    only_use_text(&amp;mutable_string);    println!(&quot;mutable_string = &#123;&#125;&quot;, mutable_string);&#125;fn do_some_mutation(input: &amp;mut String) &#123;    input.replace_range(0..1, &quot;H&quot;);    input.push_str(&quot;add this to the end&quot;);&#125;fn only_use_text(input: &amp;String) &#123;    let hello = &amp;input[..=6];    let world = &quot;world&quot;;    println!(&quot;greet = &#123;&#125;&quot;, [hello, world].concat());&#125;\n\néšå¼ç±»å‹è½¬æ¢ String -&gt; &amp;str\nå½“å‡½æ•°å‚æ•°å®šä¹‰ä¸º &amp;str åˆ‡ç‰‡ç±»å‹æ—¶ï¼Œæˆ‘ä»¬åœ¨ä¼ å…¥çš„æ˜¯å®Œæ•´åˆ‡ç‰‡æ—¶æ˜¯å¯ä»¥ç›´æ¥ä¼ å…¥ String ç±»å‹å­—ç¬¦ä¸²çš„ï¼Œç›¸å½“äº &amp;s[..]ï¼ŒRust å®ç°äº†è‡ªåŠ¨è§£å¼•ç”¨ï¼Œåœ¨å¿…è¦æ—¶ä¼šå°† &amp;String è‡ªåŠ¨è½¬æ¢æˆ &amp;str ã€‚è¿™æ ·ä½¿å¾—ï¼Œå¦‚æœæ¥å—å‚æ•°æ˜¯å­—ç¬¦ä¸²çš„å¼•ç”¨ï¼Œæˆ‘ä»¬é‡‡ç”¨ &amp;str ä½œä¸ºå…¥å‚ï¼Œä½†èƒ½è·å¾—ä¸¤ç§ç±»å‹æ•°æ®çš„å…¼å®¹ã€‚\n123let s :String = String::from(&quot;hello, world&quot;);// String è½¬æ¢æˆ slicelet slice = s.as_str();\n\næ³¨æ„ï¼šåè¿‡æ¥æ˜¯ä¸è¡Œçš„ï¼Œå› ä¸º String ç±»å‹ è½¬ åˆ‡ç‰‡ç±»å‹ï¼Œæ²¡æœ‰è½¬æ¢æˆæœ¬ï¼Œè€Œä» åˆ‡ç‰‡ç±»å‹ è½¬ String ç±»å‹è¿˜éœ€è¦ä¸ºå…¶é‡æ–°ç”³è¯·å†…å­˜ï¼Œå¯¹æ€§èƒ½æ˜¯æœ‰æŸè€—çš„ï¼ŒRust ä¸ä¼šè‡ªåŠ¨åšè¿™ä¸ªè¡Œä¸ºã€‚\nä¸å…¶ä»–ç±»å‹çš„è½¬æ¢\nå…ƒç»„ The Tuple Typeæ··åˆç±»å‹ â€”â€” å¤šç§ç±»å‹çš„æ•°å€¼çš„é›†åˆï¼Œä¸€æ—¦å®šä¹‰äº†ä¸èƒ½æ”¹å˜é•¿åº¦\n12345678// å£°æ˜let tup: (i32, f64, u8) = (500, 6.4, 1);// å–å€¼(1)let (x, y, z) = tup;println!(&quot;The value of y is: &#123;y&#125;&quot;); // âœ… The value of y is: 6.4// å–å€¼(2)println!(&quot;Values in tup: &#123;&#125; &#123;&#125; &#123;&#125;&quot;, tup.0, tup.1, tup.2); // âœ… Values in tup: 500 6.4 1\n\næ•°ç»„ The Array Typeæ•°ç»„çš„å®šä¹‰å…¶å®å°±æ˜¯ä¸ºåˆ†é…ä¸€æ®µè¿ç»­çš„ç›¸åŒæ•°æ®ç±»å‹çš„å†…å­˜å—ã€‚\n[T; N] è¡¨ç¤º N ä¸ªå€¼çš„æ•°ç»„ï¼Œæ¯ä¸ªå€¼çš„ç±»å‹ä¸º Tã€‚æ•°ç»„é•¿åº¦ä¸€ç»å®šä¹‰ä¸å¯ä¿®æ”¹ï¼Œæ‰€ä»¥ç¼–è¯‘æ—¶æ•°ç»„å ç”¨çš„å†…å­˜å¤§å°å°±å·²æ˜¯ç¡®å®šçš„äº†ï¼Œä¸èƒ½è¿½åŠ æˆ–åˆ é™¤å…ƒç´ ï¼Œä½†å¯ä»¥ä¿®æ”¹å…ƒç´ çš„å€¼ã€‚\n12345678910111213// å…ˆå£°æ˜ç±»å‹å’Œé•¿åº¦ï¼Œåèµ‹å€¼let a: [i32; 5] = [1, 2, 3, 4, 5]; // å®šä¹‰åæ— æ³•å†ä¿®æ”¹å¤§å°// åŒæ ·çš„å€¼ï¼Œå¯ä»¥ç®€åŒ–åˆ›å»ºlet a = [3; 5]; // 5 ä¸ª 3// å–å€¼let first = a[0];let second = a[1];// è½¬è¿­ä»£å™¨ï¼Œå¾—åˆ° (index, value) æšä¸¾å¯¹ lista.iter().enumerate()\n\néå†æ–¹å¼\n1234567891011// å·²çŸ¥é•¿åº¦let arr = [10; 4];for i in 0..4 &#123;  println!(&quot;&#123;&#125;&quot;, arr[i]);&#125;// æœªçŸ¥é•¿åº¦ï¼šè¿­ä»£å™¨for i in arr.iter() &#123; println!(&quot;&#123;&#125;&quot;, i);&#125;\n\næ•°ç»„çš„å¼•ç”¨éƒ½æ˜¯å€¼çš„ä¼ é€’ï¼Œå³å’ŒåŸæ•°ç»„æ²¡æœ‰è”ç³»ï¼ŒåŸæ•°ç»„ä¸å—ä»»ä½•å½±å“\n12345678910111213141516171819202122fn test_arr() &#123;    let mut a = [10, 20];    let mut b = a;    a[0] = 0;    println!(&quot;a &#123;:?&#125;&quot;, a); // [0, 20]    println!(&quot;b &#123;:?&#125;&quot;, b); // [10, 20]    let arr = [10, 20, 30];    println!(&quot;1111 &#123;:?&#125;&quot;, arr); // [10, 20, 30]   // å‚æ•°ä¼ é€’ï¼Œæ˜¯ç›´æ¥å¤åˆ¶ arr çš„å€¼ä¼ å…¥ï¼Œå’Œ arr æ— å…³    update(arr);    println!(&quot;2222 &#123;:?&#125;&quot;, arr); // [10, 20, 30]    fn update(mut arr: [i32; 3]) &#123;        for i in 0..3 &#123;            arr[i] = 0;        &#125;        println!(&quot;update &#123;:?&#125;&quot;, arr); // [0, 0, 0]    &#125;&#125;\n\nå‘é‡ The Vec TypeAn array-like data structureï¼Œä¸€ç§ç±»æ•°ç»„æ•°æ®ç»“æ„ï¼Œå’Œæ•°ç»„çš„åŒºåˆ«æ˜¯å®ƒæ”¯æŒåŠ¨æ€å¤§å°ï¼Œå³å¯ä»¥å¢åŠ æˆ–åˆ é™¤å…ƒç´ ã€‚\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465fn main() &#123;    /*      ä½¿ç”¨Vecå’ŒHashMapå®ç°ä¹¦ç±åº“ç®¡ç†ç³»ç»Ÿ      æ·»åŠ ä¹¦ç±ï¼ŒæŸ¥è¯¢åº“å­˜ï¼Œæ›´æ–°åº“å­˜ï¼Œåˆ é™¤ä¹¦ç±    */      let books = vec![        &quot;The Rust Programming Language&quot;,        &quot;Welcome to Rust&quot;,        &quot;Rust by Example&quot;,    ];    struct BookSystem &#123;        map: HashMap&lt;String, i32&gt;,    &#125;    impl BookSystem &#123;        // åˆ›å»º        fn new(books: Vec&lt;&amp;str&gt;) -&gt; BookSystem &#123;            let mut map = HashMap::new();            for book in books &#123;                map.insert(book.to_string(), 1);            &#125;            BookSystem &#123; map &#125;        &#125;        // æ·»åŠ ä¹¦ç±        fn add(&amp;mut self, name: &amp;str) &#123;            self.map.insert(name.to_string(), 1);        &#125;        // æŸ¥è¯¢åº“å­˜        fn find(&amp;self, name: &amp;str) -&gt; i32 &#123;            match self.map.get(&amp;name.to_string()) &#123;                Some(num) =&gt; *num,                None =&gt; 0,            &#125;        &#125;        // æ›´æ–°åº“å­˜        fn update(&amp;mut self, name: &amp;str, num: i32) &#123;            self.map.insert(name.to_string(), num);        &#125;        // åˆ é™¤ä¹¦ç±        fn delete(&amp;mut self, name: &amp;str) &#123;            self.map.remove_entry(name);        &#125;        fn log(&amp;self) &#123;            println!(&quot;&gt;&gt;&gt;&gt;&gt;&gt; Current stock &lt;&lt;&lt;&lt;&lt;&lt;&quot;);            for (k, v) in &amp;self.map &#123;                println!(&quot;[&#123;&#125;]: &#123;&#125;&quot;, k, v);            &#125;        &#125;    &#125;    let mut sys = BookSystem::new(books);    sys.log();    let book_name = &quot;Easy Rust&quot;;    sys.add(book_name);    sys.log();    sys.update(book_name, 3);    sys.log();    println!(&quot;The stock of [&#123;&#125;] is &#123;&#125;&quot;, book_name, sys.find(book_name));    sys.delete(book_name);    sys.log();&#125;\n\nåˆ‡ç‰‡ The Slice Typeè¡¨ç¤º String ç±»å‹ã€Array ç±»å‹ã€Vec ç±»å‹ çš„å±€éƒ¨æ•°æ®ï¼Œ&amp;T åªå¼•ç”¨å€¼ï¼Œ&amp;mut T å¯ä»¥ä¿®æ”¹åŸæ•°æ®\n12345678910åˆ‡ç‰‡å¸¸ç”¨å‡½æ•°- len(): å– slice å…ƒç´ ä¸ªæ•°- is_empty(): åˆ¤æ–­ slice æ˜¯å¦ä¸ºç©º- contains(): åˆ¤æ–­æ˜¯å¦åŒ…å«æŸä¸ªå…ƒç´ - repeat(): é‡å¤ slice æŒ‡å®šæ¬¡æ•°- reverse(): åè½¬ slice- join(): å°†å„å…ƒç´ å‹å¹³ï¼ˆflattenï¼‰å¹¶é€šè¿‡æŒ‡å®šçš„åˆ†éš”ç¬¦è¿æ¥èµ·æ¥- swap(): äº¤æ¢ä¸¤ä¸ªç´¢å¼•å¤„çš„å…ƒç´ ï¼Œå¦‚ s.swap(1, 3)- windows(): ä»¥æŒ‡å®šå¤§å°çš„çª—å£è¿›è¡Œæ»šåŠ¨è¿­ä»£- start_with(): åˆ¤æ–­ slice æ˜¯å¦ä»¥æŸä¸ª slice å¼€å¤´\n\nè‡ªå®šä¹‰ç±»å‹ Custom TypesRust è‡ªå®šä¹‰æ•°æ®ç±»å‹ä¸»è¦é€šè¿‡ struct å’Œ enum å…³é”®å­—å½¢æˆ\n\nstruct: å®šä¹‰ä¸€ä¸ªç»“æ„ä½“å‹æ•°æ®\nenum: å®šä¹‰ä¸€ä¸ªæšä¸¾å‹æ•°æ®\n\nç»“æ„ä½“ StructuresåŸºç¡€ç”¨æ³•ï¼Œç»“æ„ä½“å¯ä»¥å®šä¹‰ n å¤šä¸ªå­—æ®µ\n\nç»“æ„ä½“å˜é‡å’Œä¸€èˆ¬å˜é‡ä¸€æ ·ï¼Œé»˜è®¤ä¹Ÿæ˜¯ä¸å¯å˜çš„ï¼ˆimmutableï¼‰ï¼Œlet mut T = struct XXX å®šä¹‰å¯å˜çš„ï¼ˆmutableï¼‰ç»“æ„ä½“å˜é‡\nå¯ä»¥æ²¡æœ‰ä»»ä½•å­—æ®µåï¼Œä½†ä¸èƒ½æ²¡æœ‰å­—æ®µç±»å‹ï¼Œè¿™ç§ç»“æ„ä½“é•¿çš„åƒå…ƒç»„ï¼Œæ‰€ä»¥è¢«è¢«ç§°ä¸ºå…ƒç¥–ç»“æ„ä½“ï¼ˆtuple structï¼‰ï¼Œä¾‹å¦‚ï¼šstruct Point(i32, i32, i32) è¡¨ç¤ºä¸€ä¸ªç‚¹çš„åæ ‡ x,y,z\nå¯ä»¥ä¸åŒ…å«ä»»ä½•å­—æ®µï¼Œå³æ²¡æœ‰ç±»å‹ä¹Ÿæ²¡æœ‰åç§°ï¼Œè¢«ç§°ä¸ºå•å…ƒç»“æ„ä½“\n\n12345678910111213141516171819202122232425262728293031struct Person &#123;    name: String,    age: u8,&#125;let me = Person &#123; name: &quot;Marnie&quot;.to_string(), age: 10 &#125;;// A unit structstruct Unit;// A tuple structstruct Pair(i32, f32);let a = Pair(8, 0.2);println(&quot;&#123;&#125;&quot;, a.0);// A struct with two fieldsstruct Point &#123;    x: f32,    y: f32,&#125;let p = Point &#123; x: 0.5, y: 1.2 &#125;;// Structs can be reused as fields of another structstruct Rectangle &#123;    // A rectangle can be specified by where the top left and bottom right    // corners are in space.    top_left: Point,    bottom_right: Point,&#125;let point_top_left = Point &#123; x: 0.5, y: 1.2 &#125;;let point_bottom_right = Point &#123; x: 1.8, y: 0.2 &#125;;let rect = Rectangle &#123; top_left: point_top_left, bottom_right: point_bottom_right &#125;;\n\nç»“æ„ä½“æ›´æ–°è¯­æ³•ï¼šæˆ‘ä»¬å¯ä»¥ç”¨ ..structA ç»™ structB è¿›è¡Œæ›´æ–°ï¼Œåœ¨ structB ä¸­æ²¡æœ‰æ˜¾ç¤ºå£°æ˜çš„å­—æ®µï¼Œéƒ½ä¼šä» structA ä¸­å– ã€‚\nä½†æ˜¯æ³¨æ„äº†ğŸ“¢ï¼Œåœ¨ Rust ä¸­ä¸¥æ ¼ç®¡æ§ç€æ•°æ®æ‰€æœ‰æƒï¼ˆownershipï¼‰ï¼Œæ‰€ä»¥å½“é’ˆå¯¹æ²¡æœ‰ copy ç‰¹æ€§çš„å­—æ®µè¢«ç”¨æ¥èµ‹å€¼ä¹‹åï¼Œè¯¥å­—æ®µçš„æ•°æ®æ‰€æœ‰æƒå³ä¼šå‘ç”Ÿè½¬ç§»ã€‚åªè¦æœ‰ä¸€ä¸ªå­—æ®µå‘ç”Ÿäº†æ‰€æœ‰æƒå˜åŒ–ï¼Œé‚£ä¹ˆæ•´ä¸ªç»“æ„ä½“å°±å·²ç»æ˜¯ä¸å®Œæ•´çš„äº†ï¼Œè¯¥ç»“æ„ä½“æœ¬èº«å°±ä¸èƒ½å†è¢«è½¬ç§»ï¼Œå³æ— æ³•æ•´ä¸ªç»“æ„ä½“ç›´æ¥ä½¿ç”¨ã€‚\næ²¡æœ‰ copy ç‰¹æ€§ï¼ˆtraitï¼‰æŒ‡çš„å°±æ˜¯é‚£äº›å­˜åœ¨ heap ä¸Šçš„æ•°æ®ï¼Œåœ¨ stack-side å­˜å‚¨çš„æ˜¯å…¶å†…å­˜å—çš„ pointerï¼Œèµ‹å€¼æ“ä½œå³åŸæŒ‡é’ˆå¤±æ•ˆï¼Œå†…å­˜åœ°å€è½¬ç§»åˆ°æ–°æŒ‡é’ˆä¸Šã€‚\n12345678910let user1 = User &#123;     active: true,     username: String::from(&quot;example1&quot;),     email: String::from(&quot;example1@examples.com&quot;),     sign_in_count: 1, &#125;; let user2 = User &#123;     email: String::from(&quot;example2@examples.com&quot;),     ..user1 &#125;;\n\nç»“æ„ä½“å¯ä»¥åŒ…å«è¡Œä¸ºï¼Œå³å¸¦æœ‰æ–¹æ³•ï¼ˆæ–¹æ³•å’Œå‡½æ•°æ˜¯æœ‰åŒºåˆ«çš„ï¼‰çš„ç»“æ„ä½“\næšä¸¾å‹ Enumç»“æ„ä½“é€šå¸¸æ˜¯æè¿°å¸¦æœ‰ä¸åŒå­—æ®µçš„æŸä¸ªç±»å‹ï¼Œè€Œæšä¸¾å‹æŒ‡çš„æ˜¯æŸä¸ªæ›´ä¸Šå±‚çš„ç±»å‹ä¸‹ä¼šåŒ…å«å¤šä¸ªä¸åŒç±»å‹ï¼Œæ¯”å¦‚åŠ¨ç‰©ç±»å‹åŒ…å«çŒ«çŒ«ã€ç‹—ç‹—ã€å…”å­ã€çŒªç­‰ç­‰\n123456enum Animal &#123;  Dog,  Cat,  Rabbit,  Pig,&#125;\n\nå‡½æ•° Functionsè¯­å¥ Statementsè¡¨ç¤ºä¸€ä¸ªè¦æ‰§è¡Œçš„æ“ä½œï¼Œæ²¡æœ‰è¿”å›å€¼\n1234567fn foo() &#123;  // âŒ é¦–å…ˆ let y = 1; æ˜¯ä¸ªè¯­å¥ï¼Œæ²¡æœ‰è¿”å›å€¼ï¼Œä¸”ï¼ˆï¼‰ä¸­åŠ è¡¨è¾¾å¼åªèƒ½åœ¨ ifã€while æ¡ä»¶åˆ¤æ–­ä¸‹ä½¿ç”¨  let x = (let y = 1);    // ç­‰åŒäº let x = 1; let y = 1;  let x = y = 1;&#125;\n\næµç¨‹æ§åˆ¶ Control Flowæ¡ä»¶æ§åˆ¶ ifif è¡¨è¾¾å¼çš„æ¡ä»¶ï¼ˆconditionï¼‰å¿…é¡»æ˜¯ bool ç±»å‹\n123456let number = 3;// âŒ error[E0308]: mismatched types, expected `bool`, found integer&quot;if number &#123;  println!(&quot;Never print: expected `bool`, found integer&quot;);&#125;\n\nif or else è¡¨è¾¾å¼åç´§è·Ÿçš„ä»£ç å—è¢«ç§°ä¸º armsï¼Œå’Œ match è¡¨è¾¾å¼çš„ arms ä¸€è‡´\nif è¡¨è¾¾å¼çš„ä»£ç å—æœ€åä¸€è¡Œè‹¥æ˜¯è¡¨è¾¾å¼ï¼Œå³ä¸ºå½“å‰å—çš„è¿”å›å€¼\nè‹¥æ˜¯å¤šä¸ª if...else if æ¯ä¸ªä»£ç å—çš„è¿”å›å€¼ç±»å‹éœ€è¦ä¸€è‡´\n123456789101112131415161718fn if_else_expressions() -&gt; () &#123;    let number = 55;    const NOT_MATCHED_MESSAGE: &amp;str = &quot;Not Matched&quot;;    let message = if number % 4 == 0 &#123;        &quot;Divide by 4&quot;    &#125; else if number % 3 == 0 &#123;        &quot;Divide by 3&quot;    &#125; else if number % 2 == 0 &#123;        &quot;Divide by 2&quot;    &#125; else &#123;        NOT_MATCHED_MESSAGE    &#125;;    if message != NOT_MATCHED_MESSAGE &#123;        println!(&quot;&#123;&#125;&quot;, message);    &#125;&#125;\n\n todo()! è¡¨ç¤ºå»¶è¿Ÿå®ç°å½“å‰ä»£ç å—ï¼Œå’Œå ä½ç¬¦æ¦‚å¿µç±»ä¼¼ï¼Œå³å¯ä»¥è·³è¿‡ç±»å‹æ£€æŸ¥\n123fn foo() &#123;  todo()!;&#125;\n\nå¾ªç¯ Looplooploop åŠ å¤§æ‹¬å·å£°æ˜å¾ªç¯ï¼ˆä»£ç å—å¯ä»¥æœ‰è¿”å›å€¼ï¼‰ï¼Œcontinue è·³å‡ºæœ¬æ¬¡å¾ªç¯ï¼Œbreak è·³å‡ºå¹¶ç»ˆæ­¢æ•´ä¸ªå¾ªç¯ï¼Œ\n12345678910111213fn loop_expressions() -&gt; () &#123;    let mut counter = 0;    let result = loop &#123;        counter += 1;        if counter == 10 &#123;            break counter * 10; // ç»ˆæ­¢å¾ªç¯ï¼Œå¹¶æœ‰è¿”å›å€¼        &#125;    &#125;;    println!(&quot;&#123;&#125;&quot;, result);&#125;\n\nåµŒå¥—å¾ªç¯ï¼Œç”¨ å•å¼•å· + label çš„æ ¼å¼å‘½åï¼Œbreak LOOP_NAME è·³å‡ºå¯¹åº”å¾ªç¯\n123456789101112131415161718192021222324fn nested_loops() -&gt; () &#123;    let mut count = 0;    &#x27;counting_up: loop &#123;        println!(&quot;count = &#123;&#125;&quot;, count);        let mut remaining = 10;        loop &#123;            println!(&quot;remaining = &#123;&#125;&quot;, remaining);            if remaining == 9 &#123;                break; // ç»“æŸå¹¶è·³å‡ºå½“å‰å¾ªç¯            &#125;            if count == 2 &#123;                break &#x27;counting_up; // ç»“æŸå¹¶è·³å‡º &#x27;counting_up å¾ªç¯            &#125;            remaining -= 1;        &#125;        count += 1;    &#125;&#125;\n\nwhileå¦‚æœéœ€è¦åˆ¤æ–­æŸäº›æ¡ä»¶çš„å¾ªç¯ï¼Œå¯ä»¥ä½¿ç”¨ while æ›´æ–¹ä¾¿\n123456789fn while_case() -&gt; () &#123;    let mut count = 1;    while count &lt; 12 &#123;        count += 1;    &#125;    println!(&quot;count = &#123;&#125;&quot;, count);&#125;\n\nforfor loop éå†æ•°ç»„\n123456789101112131415161718192021222324252627282930313233343536// loop in arrayfn for_loop() -&gt; () &#123;    let a = [10, 20, 30, 40, 50];    for e in a &#123;        println!(&quot;i=&#123;&#125;&quot;, e);    &#125;   // 1..=5 å¿«é€Ÿåˆ›å»ºä¸€ä¸ª1-5çš„    for n in 1..=5 &#123;        println!(&quot;n=&#123;&#125;&quot;, n);    &#125;     // (1..=5).rev() å¿«é€Ÿåˆ›å»ºä¸€ä¸ª5-1å€’åºçš„æ•°ç»„    for n in (1..=5).rev() &#123;        println!(&quot;n=&#123;&#125;&quot;, n);    &#125;&#125;// loop in vectorfn vector_case() -&gt; () &#123;    let mut v = vec![1, 2, 3];    // è¡¨ç¤ºå¹¶éæ‰€æœ‰æƒè½¬ç§»ï¼Œ&amp; è¡¨ç¤ºå€Ÿç”¨ï¼Œå€Ÿç”¨æ˜¯åªè¯»    for vv in &amp;mut v &#123;        // vv æ˜¯å¯¹ v ä¸­çš„æŸä¸ª vector çš„å¼•ç”¨ï¼Œ        // å¼•ç”¨çš„æœ¬è´¨æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡é’ˆä¸èƒ½ç›´æ¥å’Œå€¼è¿›è¡Œæ¯”è¾ƒï¼Œ        // éœ€è¦åŠ  *å· è§£å¼•ç”¨ï¼Œè§£å¼•ç”¨å°±è¡¨ç¤ºè¯¥å¼•ç”¨å˜é‡çš„å€¼        if *vv == 1 &#123;            *vv = 5;        &#125;        println!(&quot;v=&#123;&#125;&quot;, vv);    &#125;    println!(&quot;&#123;&#125;&quot;, v[0]);&#125;\n\næ‰€æœ‰æƒ Ownershipæ‰€æœ‰æƒæ˜¯æ§åˆ¶ä¸€ä¸ª Rust ç¨‹åºå¦‚ä½•ç®¡ç†å†…å­˜çš„ä¸€å¥—è§„åˆ™ã€‚æ‰€æœ‰ç¨‹åºéƒ½è¦æœ‰ç®¡ç†å®ƒä»¬åœ¨è¿è¡Œæ—¶ä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼ã€‚\nå†…å­˜ç®¡ç†æ–¹å¼ Memory Managementå¸¸è§çš„å†…å­˜ç®¡ç†æ–¹å¼ï¼š\n\nåƒåœ¾å›æ”¶ï¼ˆGarbage Collectionï¼‰ï¼šå¦‚ JavaScriptã€Java è¿™ç§åŠ¨æ€è¯­è¨€ï¼Œè¯­è¨€å±‚é¢è®¾è®¡äº†ä¸€å¥—å†…å­˜å›æ”¶æœºåˆ¶ï¼Œåƒåœ¾å›æ”¶å™¨ä¼šæŒç»­è¿½è¸ªå†…å­˜çš„åˆ†é…å¹¶å®šæœŸæ‰¾åˆ°ä¸å†è¢«ä½¿ç”¨çš„å†…å­˜è¿›è¡Œé‡Šæ”¾å›æ”¶ï¼Œè®©å¼€å‘è€…æ— éœ€å»å…³å¿ƒå†…å­˜çš„åˆ†é…å’Œå›æ”¶\næ‰‹åŠ¨ç®¡ç†ï¼ˆManual Managementï¼‰ï¼šå¦‚ Cã€C++ è¿™ç§é™æ€è¯­è¨€ï¼Œéœ€è¦æ‰‹åŠ¨è°ƒç”¨åˆ†é…å’Œé‡Šæ”¾å†…å­˜çš„æ–¹æ³•è¿›è¡Œæ“ä½œï¼Œè¿™è®©å¼€å‘è€…éœ€è¦å¯¹å†…å­˜çš„åˆ†é…åŠé‡Šæ”¾è´Ÿè´£ï¼Œå¿˜è®°é‡Šæ”¾ä¼šå¯¼è‡´å†…å­˜æµªè´¹ï¼Œå¤ªæ—©é‡Šæ”¾åˆä¼šå¯¼è‡´è·å¾—æ— æ•ˆçš„å˜é‡\n\nç¬¬ä¸‰ç§ â€”â€” Rust ä½¿ç”¨çš„å†…å­˜ç®¡ç†æ–¹å¼ï¼šæ‰€æœ‰æƒç³»ç»Ÿï¼ˆOwnership Systemï¼‰\n\næ‰€æœ‰è€…ï¼ˆowerï¼‰æŒ‡çš„æ˜¯è¿™å—å†…å­˜ï¼ˆmemoryï¼‰æ˜¯å±äºè°çš„ï¼ŒåŒ…æ‹¬è®¿é—®å’Œä¿®æ”¹çš„èƒ½åŠ›\næ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œä»»ä½•æ—¶å€™éƒ½åªèƒ½æœ‰ä¸€ä¸ªæœ‰æ•ˆæ‰€æœ‰è€…\nå½“æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸï¼ˆscopeï¼‰ï¼Œå€¼ä¼šè¢«ä¸¢å¼ƒï¼ˆdropï¼‰\néµå¾ªæ‰€æœ‰æƒç³»ç»Ÿè§„åˆ™ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶é€šè¿‡é™æ€åˆ†æç®¡ç†å†…å­˜å®‰å…¨ï¼Œè¿èƒŒè§„åˆ™çš„ç¨‹åºä¸ä¼šé€šè¿‡ç¼–è¯‘\né€šè¿‡å€Ÿç”¨ï¼ˆborrowingï¼Œå³å¼•ç”¨ï¼‰æœºåˆ¶æ¥å…±äº«æ•°æ®\n\nğŸ¯ TODOï¼šå†…å­˜åˆ†é…æ–¹å¼ Memory Allocation\næ ˆï¼ˆStackï¼‰ï¼šè¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œä»ä½åœ°å€åˆ°é«˜åœ°å€é€æ­¥åˆ†é…ï¼Œç®€å•æ•°æ®ç±»å‹ä¼šè¢«ç›´æ¥å­˜å‚¨åœ¨æ ˆä¸Šï¼Œä¾¿äºæ“ä½œ\nå †ï¼ˆHeapï¼‰ï¼šéè¿ç»­å†…å­˜ç©ºé—´ï¼Œç”³è¯·å¤šå°‘å¤§å°ç©ºé—´å°±ä¸€æ¬¡æ€§åˆ†é…å¤šå°‘ï¼Œä¼šé€šè¿‡ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘è¿™ä¸€å—å†…å­˜ç©ºé—´ï¼Œå¤æ‚æ•°æ®ç±»å‹çš„å€¼ä¼šåœ¨å †ä¸Šå¼€è¾Ÿå¯¹åº”çš„ç©ºé—´å­˜æ”¾ï¼Œè€Œæ ˆä¸Šå¯¹åº”çš„è¿™ä¸ªå˜é‡å­˜çš„æ˜¯ä¸è¿™å—å†…å­˜ç›¸å…³çš„æŒ‡é’ˆä¿¡æ¯ï¼Œå³å†…å­˜åœ°å€ï¼ˆadressï¼‰ã€å¤§å°ï¼ˆCapacityï¼‰ã€é•¿åº¦ï¼ˆLengthï¼‰\nStaticï¼šblahblahblahâ€¦\n\nè½¬ç§» æˆ– å¤åˆ¶ Move or CopyåŸºäºä¸åŒçš„å†…å­˜åˆ†é…æ–¹å¼ï¼Œé’ˆå¯¹æ•°æ®å’Œå˜é‡ä¹‹é—´çš„èµ‹å€¼æ“ä½œï¼Œåœ¨ Rust ä¸­ä¹Ÿä¼šæœ‰ä¸¤ç§è¡¨ç°æƒ…å†µï¼š\n\nç®€å•æ•°æ®ç±»å‹ï¼šä¸€èˆ¬æ˜¯å›ºå®šå¤§å°çš„æ•°æ®ï¼Œå€¼å­˜æ”¾åœ¨æ ˆä¸Šï¼Œèµ‹å€¼æ˜¯å¯¹å€¼çš„æ‹·è´ï¼ˆcopyï¼‰\nå¤æ‚æ•°æ®ç±»å‹ï¼šä¸€èˆ¬ä¸ºéå›ºå®šå¤§å°æ•°æ®ï¼Œå€¼è¢«å­˜æ”¾åœ¨å †ä¸Šï¼Œè¯¥å†…å­˜ä¸€æ—¦åˆ†é…ï¼Œèµ‹å€¼çš„æ“ä½œé»˜è®¤è¢«çœ‹åšä¸ºè½¬ç§»ï¼ˆmoveï¼‰ï¼Œå³å°†è¯¥å†…å­˜çš„æ‰€æœ‰æƒè½¬ç§»ç»™æŸä¸ªå˜é‡\n\n12345678// copylet a: i32 = 1;let b = a; // directly copy 1// movelet a: String = String::from(&quot;Hello&quot;);let b = a; // move the ownership of &quot;Hello&quot; from a to b// current, a is considered as transferred, which means it&#x27;s no longer needed\n\nå…¶å®å¯ä»¥ç®€å•ç†è§£ï¼Œè½¬ç§»ï¼ˆmoveï¼‰æ˜¯æ‰€æœ‰æƒï¼ˆownershipï¼‰ç³»ç»Ÿå®ç° â€œå†…å­˜æ‰€æœ‰è€…åªèƒ½æœ‰ä¸€ä¸ªâ€ çš„ä¸€ç§è§„åˆ™æœºåˆ¶ï¼Œè¿™ä¸ªæœºåˆ¶é˜²æ­¢å‡ºç°æ•°æ®ç«äº‰çš„å¯èƒ½ â€”â€” å¤šä¸ªçº¿ç¨‹å¯¹ç»Ÿä¸€èµ„æºè¿›è¡Œè®¿é—®å’Œä¿®æ”¹ï¼Œä»è€Œå¯¼è‡´ç¨‹åºç»“æœä¸æœŸæœ›ä¸ç¬¦ã€‚æœ¬èº«å…·æœ‰æ‰€æœ‰æƒçš„å˜é‡æœ¬è´¨æ˜¯å­˜åœ¨æ ˆä¸Šçš„æŸä¸ªæŒ‡é’ˆç±»å‹å˜é‡ï¼Œå®ƒçš„ä½œç”¨æ˜¯ä¸ºäº†æŒ‡å‘å †ä¸­çš„æŸå—å†…å­˜ï¼Œæ‰€ä»¥ä¸€ç»è½¬ç§»ï¼Œç›¸å½“äºæŒ‡é’ˆä¸å†æŒ‡å‘è¿™å—å†…å­˜ï¼Œè¿™ä¸ªå˜é‡å°±ä¸å†æœ‰æ•ˆäº†ï¼Œå³ä¸å¯ä»¥å†è¢«è®¿é—®ã€‚\næ‰€æœ‰æƒå’Œç”Ÿå‘½å‘¨æœŸï¼ˆLifetimesï¼‰æ‰€æœ‰æƒæ˜¯æŒ‡æŸå—å†…å­˜çš„æ‰€æœ‰è€…ï¼Œæ‰€æœ‰è€…æ˜¯æŸä¸ªå˜é‡ï¼Œè€Œå˜é‡çš„ç”Ÿå‘½å‘¨æœŸå’Œæ‰€åœ¨ä½œç”¨åŸŸç›¸å…³ï¼Œåœ¨æŸä¸ªä½œç”¨åŸŸä¸‹å®šä¹‰çš„å˜é‡åªèƒ½åœ¨è¯¥ä½œç”¨åŸŸä¸‹ä½¿ç”¨ã€‚æ‰€æœ‰æƒä¹Ÿæœ‰ç€ç›¸åº”çš„é™åˆ¶ï¼Œå˜é‡åœ¨æŸä¸ªä½œç”¨åŸŸï¼ˆscopeï¼‰å†…è¢«åˆ†é…åˆ°å¯¹åº”æ•°æ®çš„å†…å­˜ï¼Œåœ¨ç¦»å¼€ä½œç”¨åŸŸåï¼Œå˜é‡ä¼šå˜å¾—æ— æ•ˆï¼Œå®ƒä¼šäº¤è¿˜å¯¹æŸä¸ªæ•°æ®å†…å­˜çš„æ‰€æœ‰æƒï¼Œåˆ™è¯¥â€œæ— ä¸»â€çš„æ•°æ®å†…å­˜ä¼šè¢«è§†ä¸ºä¸å†éœ€è¦çš„ï¼Œä¼šè§¦å‘è‡ªåŠ¨é‡Šæ”¾å†…å­˜çš„æœºåˆ¶ï¼Œä¹Ÿå°±æ˜¯å›æ”¶å†…å­˜ã€‚\n12345fn foo() &#123;  let s = String::from(&quot;Hello&quot;); // s is valid from this point  // s is the owner of the string &quot;Hello&quot;&#125; // this scope is over now, s and string &quot;Hello&quot; are not valid// the data is not valid means it is no longer needed, which will trigger the step of freeing memory\n\nå½“å˜é‡è¢«ä¼ å…¥æŸä¸ªå‡½æ•°ï¼Œä¹Ÿæ˜¯å‘ç”Ÿäº†è½¬ç§»æ“ä½œï¼Œæ„å‘³ç€æ•°æ®çš„æ‰€æœ‰æƒè¢«ä¼ é€’ç»™äº†å‡½æ•°ï¼Œå‡½æ•°å¤–å·²ç»æ²¡æœ‰æƒåˆ©è®¿é—®å’Œä¿®æ”¹è¯¥å˜é‡æ‰€æŒ‡çš„æ•°æ®ã€‚å¦‚ä¸‹ä¾‹å­ï¼š\n\nç¬¬ä¸€æ­¥ï¼Œs æ‹¥æœ‰äº† string &quot;Hello&quot; çš„æ‰€æœ‰æƒ\nç¬¬äºŒæ­¥ï¼Œå°† string &quot;Hello&quot; çš„æ‰€æœ‰æƒè½¬ç§»ç»™äº† carry_params å‡½æ•°\nè€Œ carry_params æ²¡æœ‰å¯¹å‚æ•° s åšä»»ä½•å¤„ç†ï¼Œé‚£ä¹ˆåœ¨å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œç¦»å¼€ä½œç”¨åŸŸï¼Œå…¥å‚ s å¯¹åº”ä¹Ÿä¸å†æœ‰æ•ˆï¼Œå¯¹åº”å ç”¨çš„æ•°æ®å†…å­˜ä¼šè¢«é‡Šæ”¾\nç¬¬ä¸‰æ­¥ï¼Œæˆ‘ä»¬å†æ‰“å° s å°±ä¼šå¾—åˆ°å€¼å·²è¢«è½¬ç§»äº†ï¼Œå³æ— æƒè®¿é—®çš„ç¼–è¯‘é”™è¯¯æç¤º\næ‹¥æœ‰æ‰€æœ‰æƒçš„ä½œç”¨æ‰€æœ‰æƒæ˜¯æŒ‡å¯¹æŸå—å†…å­˜çš„æ‰€æœ‰ï¼Œå³æ‹¥æœ‰è¯»å†™è¿™å—å†…å­˜çš„æƒåŠ›ï¼Œå½“æˆ‘ä»¬éœ€è¦ä¿®æ”¹æŸä¸ªæ•°æ®æ—¶ï¼Œæˆ‘ä»¬å°±éœ€è¦æ‹¥æœ‰å…¶æ‰€æœ‰æƒï¼Œæ‰èƒ½æœ‰ä¿®æ”¹çš„èƒ½åŠ›ã€‚è€Œå½“æˆ‘ä»¬åªéœ€è¦è¯»ï¼Œè€Œä¸éœ€è¦å†™ï¼Œé‚£å°±ä¸å¿…æ‹¥æœ‰æˆ–è€…è½¬ç§»å…¶æ‰€æœ‰æƒã€‚å¯ä»¥çœ‹åˆ°ï¼Œæœ‰äº†æ‰€æœ‰æƒè§„åˆ™çš„åŠ æŒï¼Œä»£ç å˜å¾—æ›´åŠ å®‰å…¨ä½†ä¹Ÿå› æ­¤å¢åŠ äº†ä¹¦å†™ä»£ç çš„éš¾åº¦ã€‚\nä¸Šé¢æåˆ°å¦‚æœæˆ‘ä»¬ä¸éœ€è¦è·å¾—æŸä¸ªæ•°æ®çš„æ‰€æœ‰æƒï¼Œåªæ˜¯æƒ³è¦è®¿é—®å€¼ï¼Œå¯ä»¥ç”¨å¦ä¸€ä¸ªæ¦‚å¿µ â€”â€” å€Ÿç”¨ï¼ˆborrowï¼‰ã€‚\nå€Ÿç”¨ Borrowå½“æˆ‘ä»¬ä¸éœ€è¦æ•°æ®çš„æ‰€æœ‰æƒæ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨å€Ÿç”¨æ¥è®¿é—®æ•°æ®çš„å€¼ï¼Œå€Ÿç”¨åˆ†ä¸ºä¸¤ç§ï¼š\n\nborrowï¼šä¸å¯å˜çš„å€Ÿç”¨ï¼Œæˆ‘åªæ˜¯æŠŠæ•°æ®å€Ÿç»™ä½ ç”¨ &amp;T\nborrow mutablyï¼šå¯å˜çš„å€Ÿç”¨ï¼Œæˆ‘ä¸ä»…æŠŠæ•°æ®å€Ÿç»™ä½ ç”¨ï¼Œä¸”ç»™ä½ ä¿®æ”¹å®ƒçš„æƒé™ &amp;mut Tï¼Œè¿™ç§å€Ÿç”¨ä¹Ÿå¯ä»¥è¢«å«åšå¼•ç”¨ï¼ˆreferenceï¼‰\n\nå…¶å®å¯ä»¥ç†è§£ä¸ºï¼Œ&amp; ç»™äº†è¯»æ•°æ®çš„æƒåŠ›ï¼Œ&amp;mut  åœ¨è¯»çš„åŸºç¡€ä¸Šç»™äº†å†™çš„æƒåŠ›ï¼Œä½†æ•°æ®ï¼ˆä¹Ÿå°±æ˜¯è¿™å—å†…å­˜ï¼‰çš„æ‹¥æœ‰è€…å¹¶æ²¡æœ‰å˜ã€‚\n123456789101112131415161718192021222324252627282930313233fn str_and_string() &#123;    // æ™®é€šæ–‡æœ¬å­—ç¬¦ä¸² string literals    let normal_str = &quot;hello, &quot;;    // å¯æ“ä½œçš„ã€æ‹¥æœ‰æ‰€æœ‰æƒçš„ String ç±»å‹å­—ç¬¦ä¸²    let mut mutable_string = String::from(normal_str);   // a string slice of String,    // å€Ÿç”¨ï¼ˆå¼•ç”¨ï¼‰ &quot;hello, &quot;ï¼Œæ²¡æœ‰ä¿®æ”¹å­—ç¬¦ä¸²çš„éœ€æ±‚    let slice = &amp;mutable_string[..];    println!(&quot;slice = &#123;&#125;&quot;, slice);    // å€Ÿç”¨å¯¹è±¡ å’Œ è¢«å€Ÿç”¨å¯¹è±¡ éƒ½æ˜¯æŒ‡å‘åŒä¸€å—å†…å­˜ï¼Œæ‰€ä»¥ç›¸ç­‰    assert_eq!(slice, mutable_string);    // 1ï¸âƒ£ é»˜è®¤å€Ÿç”¨ï¼Œåªéœ€è¦å€Ÿç”¨å­—ç¬¦ä¸²çš„å€¼ï¼Œä¸æ¶‰åŠæ‰€æœ‰æƒ    only_use_text(&amp;mutable_string);   // 2ï¸âƒ£ å¯å˜çš„å€Ÿç”¨ï¼Œä¸ä»…å¯ä»¥è®¿é—®å€¼ï¼Œè¿˜ç»™äº†ä¿®æ”¹å€¼çš„æƒåŠ›   // éœ€è¦å£°æ˜ &amp;mut æ‰èƒ½ä¿®æ”¹å­—ç¬¦ä¸²    do_some_mutation(&amp;mut mutable_string);    println!(&quot;mutable_string = &#123;&#125;&quot;, mutable_string);&#125;fn do_some_mutation(input: &amp;mut String) &#123;    input.replace_range(0..1, &quot;H&quot;);    input.push_str(&quot;add this to the end&quot;);&#125;fn only_use_text(input: &amp;String) &#123;    let hello = &amp;input[..=6];    let world = &quot;world&quot;;    println!(&quot;greet = &#123;&#125;&quot;, [hello, world].concat());&#125;\n\nğŸ¯ TODOï¼šç”Ÿå‘½å‘¨æœŸ LifetimesNLL â€”â€” Non-Lexical LifetimesDangling Referencing æ‚¬å‚å¼•ç”¨æŒ‡çš„æ˜¯ä¸€ä¸ªå˜é‡æ˜¯æœ‰æ•ˆçŠ¶æ€çš„æ—¶é—´ï¼Œå³å¯ä»¥è¢«ä½¿ç”¨çš„æ—¶é•¿ï¼Œé€šå¸¸ä¹Ÿè¢«å«åšå­˜æ´»ï¼ˆliveï¼‰æ—¶é—´ã€‚\nç”Ÿå‘½å‘¨æœŸæ˜¯ Rust ç”¨æ¥ä¿è¯å¼•ç”¨æœ‰æ•ˆæ€§çš„æœºåˆ¶ã€‚ç”Ÿå‘½å‘¨æœŸæ³¨è§£å…è®¸ç¼–è¯‘å™¨æ¨æ–­å¼•ç”¨çš„æœ‰æ•ˆèŒƒå›´ï¼Œç¡®ä¿åœ¨å¼•ç”¨ä»ç„¶æœ‰æ•ˆçš„æ—¶å€™ä½¿ç”¨å®ƒä»¬ã€‚\nåœ¨ Rust ä¸­ï¼Œä¸€ä¸ªå˜é‡çš„å­˜æ´»æ—¶é—´ä¸å…¶ä½œç”¨åŸŸï¼ˆscopeï¼‰å’Œæ˜¯å¦è¿˜å­˜åœ¨è¢«ä½¿ç”¨ï¼ˆå¼•ç”¨ referencesï¼‰æœ‰å…³ã€‚\n\nä½œç”¨åŸŸè§„åˆ™å†³å®šäº†ä¸€ä¸ªå˜é‡èƒ½å¦è¢«è®¿é—®ï¼Œåœ¨æŸä¸ªä½œç”¨åŸŸä¸‹å®šä¹‰çš„å˜é‡ä¹Ÿåªåœ¨è¿™ä¸ªä½œç”¨åŸŸå†…æœ‰æ•ˆï¼Œå³ç¦»å¼€ä½œç”¨åŸŸåæ— æ³•è¢«è®¿é—®ï¼Œä¼šè‡ªåŠ¨è¢«é”€æ¯ã€‚\n\nå½“ç¼–è¯‘å™¨æ£€æŸ¥åˆ°ä¸€ä¸ªå˜é‡ä¸å†å­˜åœ¨ä»»ä½•è¢«å¼•ç”¨è¢«å€Ÿç”¨å…³ç³»åï¼Œè¯¥å˜é‡ä¹Ÿä¼šè¢«è‡ªåŠ¨é”€æ¯ã€‚\n\n\n12345let x :i32 = 5;// å­˜åœ¨è¢«ä½¿ç”¨println!(&quot;x = &#123;&#125;&quot;, x); // after this line, x has no more references, will be automatically destroyedlet y :i32 = 6;\n\nå€Ÿç”¨è§„åˆ™ Borrow Rules\nä¸€ä¸ªå˜é‡åªèƒ½å­˜åœ¨ä¸€ä¸ªå¯å˜å¼•ç”¨æˆ–è€…å¤šä¸ªä¸å¯å˜å¼•ç”¨ï¼Œä¸èƒ½åŒæ—¶å­˜åœ¨å¯å˜å’Œä¸å¯å˜å¼•ç”¨\n\nå€Ÿç”¨æ£€æŸ¥å™¨ Borrow Checkerå‰é¢è¯´äº†ï¼Œå€Ÿç”¨æ˜¯ç”¨äºä¸å…³å¿ƒæ‰€æœ‰æƒçš„åœºæ™¯ä¸‹çš„ï¼Œé‚£æ²¡æœ‰æ‰€æœ‰æƒå°±æ„å‘³ç€æˆ‘éœ€è¦ä¾èµ–è¢«æˆ‘å€Ÿç”¨çš„é‚£ä¸ªå˜é‡ï¼Œå½“å®ƒä¸åˆæ³•æ—¶ã€æ— æ•ˆæ—¶ï¼Œé‚£æˆ‘çš„å€Ÿç”¨è¡Œä¸ºä¹Ÿæ˜¯ä¸å¯èƒ½é€šè¿‡çš„ã€‚Borrow Checker ä¾¿æ˜¯åœ¨ç¼–è¯‘æ—¶ï¼Œæ£€æŸ¥å€Ÿç”¨æ˜¯å¦åˆæ³•ï¼Œå³è¢«å€Ÿç”¨çš„å˜é‡æ˜¯å¦è¿˜åœ¨æœ‰æ•ˆçš„ç”Ÿå‘½å‘¨æœŸå†…ã€‚ç»“åˆå‰é¢æåˆ°çš„æ‰€æœ‰æƒçš„ç”Ÿå‘½å‘¨æœŸï¼Œæ¥çœ‹ä¸‹æˆªå›¾ä¸Šçš„ä¾‹å­ï¼š\n\nå¯ä»¥çœ‹åˆ°æŠ¥é”™éƒ¨åˆ†è¯´çš„æ˜¯è¢«å€Ÿç”¨å€¼ x å­˜æ´»çš„ä¸å¤Ÿé•¿ï¼Œé‡ç‚¹çœ‹ä¸‹é»„è‰²æ¡†å†…ï¼Œæ¨¡æ‹Ÿç”»çš„ä½œç”¨åŸŸç»“æ„å›¾ã€‚\n\nr åœ¨ a ä½œç”¨åŸŸä¸­åˆ›å»ºï¼Œå³å®ƒå­˜æ´»åœ¨ä½œç”¨åŸŸ a å­˜æ´»çš„æœŸé—´ï¼Œå³ foo å‡½æ•°æ‰§è¡ŒæœŸé—´\nx åœ¨ b ä½œç”¨åŸŸä¸­åˆ›å»ºï¼Œå³å®ƒå­˜æ´»åœ¨ä½œç”¨åŸŸ b å­˜æ´»çš„æœŸé—´ï¼Œä½œç”¨åŸŸ b æ˜¯ä¸ª block ä½œç”¨åŸŸï¼Œåœ¨å®ƒæ‰§è¡Œå®Œæˆåå†…éƒ¨å˜é‡éƒ½ä¼šè‡ªåŠ¨é‡Šæ”¾ï¼Œå³ x åœ¨ä½œç”¨åŸŸ b å¤–æ— æ•ˆ\n\nå› ä¸º r æ˜¯ä¸ªå€Ÿç”¨ç±»å‹ï¼ŒBorrow Checker ä¼šæ£€æŸ¥è¢«å€Ÿç”¨å˜é‡æ˜¯å¦æ˜¯æœ‰æ•ˆçš„ï¼Œå½“å‘ç°è¢«å€Ÿç”¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸå°äºå€Ÿç”¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸï¼Œå³ x çš„ç”Ÿå‘½å‘¨æœŸå°äº r çš„ç”Ÿå‘½å‘¨æœŸï¼Œè¿™æ˜¯ä¸åˆæ³•çš„ â€”â€” æŠ¥é”™ã€‚æ‰€ä»¥å¦‚æœæ˜¯å­˜åœ¨å€Ÿç”¨å…³ç³»çš„ä¸¤ä¸ªå˜é‡ï¼Œé‚£ä¹ˆè¢«å€Ÿç”¨å˜é‡çš„å­˜æ´»æ—¶é—´ä¸€å®šè¦æ¯”å€Ÿç”¨å˜é‡å­˜æ´»çš„æ—¶é—´æ›´é•¿ï¼Œå­˜æ´»æ—¶é—´æ›´é•¿å¯ä»¥å½’çº³ä¸ºä¸¤ç§æƒ…å†µï¼š\n\nç›¸åŒä½œç”¨åŸŸèŒƒå›´ä¸‹ï¼Œè¢«å€Ÿç”¨å˜é‡å®šä¹‰æ—©äºå€Ÿç”¨å˜é‡\nå€Ÿç”¨å˜é‡çš„ä½œç”¨åŸŸå±‚çº§æ·±äºè¢«å€Ÿç”¨å˜é‡ï¼ˆè¶Šæ·±é”€æ¯è¶Šæ—©ï¼‰\n\nğŸ“¸ TODO æ‰‹åŠ¨ç®¡ç†å¯èƒ½ä¼šé‡åˆ°çš„é—®é¢˜å†…å­˜æ³„éœ²\næ‚¬ç©ºæŒ‡é’ˆ\nç¼“å†²åŒºæº¢å‡º\næ³›å‹ï¼ˆGenericsï¼‰å’Œç‰¹è´¨ï¼ˆTraitsï¼‰MatchOption1234// `unwrap()`: æœ‰å€¼çš„æ—¶å€™ä¼šå–å€¼ï¼Œæ²¡å€¼çš„æ—¶å€™ä¼š `panic`let mut s = String::from(&quot;hello&quot;);let p1 = s.pop().unwrap();println!(&quot;&#123;&#125;&quot;, p1);\n\nè¿”å›å€¼ä¸é”™è¯¯å¤„ç†å¯æ¢å¤çš„é”™è¯¯ Result&lt;T, E&gt;ä»ç³»ç»Ÿå…¨å±€è§’åº¦æ¥çœ‹æ˜¯å¯ä»¥æ¥å—çš„é”™è¯¯ï¼Œè¿™äº›é”™è¯¯åªä¼šå½±å“æŸä¸ªç”¨æˆ·è‡ªèº«çš„æ“ä½œè¿›ç¨‹ï¼Œä¸€èˆ¬æ˜¯é€»è¾‘å±‚é¢ä¸Šçš„é”™è¯¯ï¼ˆä¸šåŠ¡é€»è¾‘ã€æ“ä½œé€»è¾‘ï¼‰ï¼Œä¸ä¼šå¯¹ç³»ç»Ÿçš„å…¨å±€ç¨³å®šæ€§äº§ç”Ÿå½±å“ã€‚\nä½¿ç”¨ Result è¿”å›å€¼ä¸å¯æ¢å¤çš„é”™è¯¯ panic!å…¨å±€æ€§æˆ–è€…ç³»ç»Ÿæ€§çš„é”™è¯¯ï¼Œåˆ—å…¥æ•°ç»„è¶Šç•Œè®¿é—®ã€å½±å“å¯åŠ¨æµç¨‹çš„é”™è¯¯ç­‰ç­‰ï¼Œè¿™äº›é”™è¯¯æ˜¯å½±å“ç³»ç»Ÿæµç¨‹çš„ã€‚\nä¸»åŠ¨è§¦å‘ panicRust æä¾›äº† panic! å®ï¼Œå½“è°ƒç”¨æ‰§è¡Œè¯¥å®æ—¶ï¼Œç¨‹åºä¼šæ‰“å°å‡ºä¸€ä¸ªé”™è¯¯ä¿¡æ¯ï¼Œå±•å¼€æŠ¥é”™ç‚¹å‰é¢çš„å‡½æ•°è°ƒç”¨å †æ ˆï¼Œæœ€åé€€å‡ºç¨‹åºã€‚\n123fn main() &#123;  panic!(&quot;crash and burn&quot;);&#125;\n\nbacktrace æ ˆå±•å¼€é»˜è®¤ç¨‹åºæ‰§è¡Œè°ƒç”¨æ ˆè¾“å‡ºæ˜¯å¼€å¯ --debug çš„æ—¶å€™æ‰ä¼šå±•ç¤ºï¼Œå¯ä»¥é€šè¿‡ RUST_BACKTRACE=1 cargo run æ¥æ‰‹åŠ¨å¼€å¯è°ƒç”¨æ ˆå›æº¯ã€‚\næ ˆå±•å¼€ä¹Ÿç§°æ ˆå›æº¯ï¼ŒåŒ…å«äº†å‡½æ•°è°ƒç”¨çš„é¡ºåºï¼ŒæŒ‰ç…§é€†åºæ’åˆ—ï¼šæœ€è¿‘è°ƒç”¨çš„å‡½æ•°åœ¨åˆ—è¡¨æœ€ä¸Šæ–¹ã€‚\nunwrap æ–¹æ³•\nOption : æœ‰å€¼çš„æ—¶å€™ä¼šå–å€¼ï¼Œæ²¡å€¼çš„æ—¶å€™ä¼šè°ƒç”¨ panic!\nResult : Ok ä¼šè¿”å› Ok ä¸­çš„å€¼ï¼ŒErr ä¼šä¸ºæˆ‘ä»¬è°ƒç”¨ panic!\n\n123let arr = [1, 2, 3, 4];let a = first(&amp;arr).unwrap();println!(&quot;The first element is &#123;&#125;&quot;, a);\n\nexpect æ–¹æ³•ç”¨äºè®¾ç½®é¢„æœŸçš„ panic é”™è¯¯æ–‡æ¡ˆ\n12let file = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);println!(&quot;&#123;:?&#125;&quot;, file);\n\nä¼ æ’­é”™è¯¯unwrap æ–¹æ³•åœ¨é‡åˆ°é”™è¯¯æƒ…å†µä¸‹éƒ½ä¼šç›´æ¥è°ƒç”¨ panic! ä»è€Œä¼šç›´æ¥ç»ˆæ­¢ç¨‹åºçš„è¿›è¡Œï¼Œä½†å¾ˆå¤šæƒ…å†µä¸‹æˆ‘ä»¬é‡åˆ°çš„éƒ½æ˜¯é¢„æœŸå†…çš„é”™è¯¯æƒ…å†µï¼Œå¹¶ä¸éœ€è¦ç»ˆæ­¢ï¼Œåªéœ€è¦å°†é”™è¯¯å‘ä¸Šä¼ æ’­ï¼Œè¿™æ—¶æˆ‘ä»¬å°±ä¸ç”¨ä½¿ç”¨ unwrap æ–¹æ³•ã€‚å–è€Œä»£ä¹‹ï¼Œé€šå¸¸ä½¿ç”¨ ? é“¾å¼è°ƒç”¨ä¼ æ’­é”™è¯¯ï¼Œå®ƒçš„åŠŸèƒ½æ˜¯é—®å·å‰çš„è¡¨è¾¾å¼æ‰§è¡Œç»“æœæˆåŠŸåˆ™ç»§ç»­å‘åæ‰§è¡Œï¼Œè‹¥ç»“æœå¤±è´¥æˆ–è€…è¯´é”™è¯¯ï¼Œåˆ™æˆªåœæ‰§è¡Œé€»è¾‘åˆ°å½“å‰è¡¨è¾¾å¼ä¸ºæ­¢å¹¶å°†é”™è¯¯è¿”å›ï¼Œæ­¤æ—¶å¦‚æœå‰ä¸€ä¸ªè¡¨è¾¾å¼è®¾ç½®äº†é”™è¯¯ callback ç­‰ç±»ä¼¼çš„å¤„ç†ï¼Œå°±èƒ½è§¦å‘ç›¸åº”çš„é€»è¾‘ã€‚\nOption å’Œ Result çš„äº’è½¬Result æœ‰ä¸¤ä¸ªç»“æœ Ok å’Œ Errï¼ŒOption åŒ…å« Some å’Œ None\n\nResult è½¬ Optionï¼Œè½¬æ¢å³å°† ok å’Œ err éƒ½è½¬ä¸º Some\n\nerr(): Err -&gt; Some\n\nok(): Ok -&gt; Some\n\n\n\n\n123456789let f = File::open(&quot;hello.txt&quot;).err();if f.is_some() &#123;    println!(&quot;no file&quot;);&#125; let f = File::open(&quot;hello.txt&quot;).ok();if f.is_none() &#123;    println!(&quot;no file&quot;);&#125;\n\n\nOption è½¬ Result\n\nok_or()\n\n\n\n","slug":"rust-basic","date":"2024-10-22T16:00:00.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"}]