[{"id":"6aaea4836c6acb6130648711cb680200","title":"create-basic-program","content":"Create A Basic Program\n分别创建 dApp端（client端）和 合约端 目录\n\n12cargo new clientcargo new program\n\n\n\n\n接下来会同时对两个目录进行功能书写，顺序不定，写一步对一步\n\n先在 client 仓库下用编写测试代码的方式测试合约功能，首先我们为 client 添加下所需的 dependencies\n1cargo add solana-client solana-sdk\n\n\n建立与Solana网络交互的桥梁——RPC\n读取本地 wallet keypair 文件作为此次与链上交互的支付方（payer）\n由 client 端生成 生成 mint_account keypair，用于传给 合约端 进行 创建铸币账户+初始化账户 的操作\n\n123456789#[test]fn test_fn() &#123;    // 建立与Solana网络交互的桥梁——RPC    let client = RpcClient::new(&quot;http://127.0.0.1:8899&quot;);    // 此次链上操作的支付方 为本地密钥对账户    let payer = read_to_string(&quot;/Users/wuwenqi/.config/solana/id.json&quot;).expect(&quot;FAILED&quot;);    // 生成 mint_account keypair    let mint = Keypair::new(&quot;&quot;);&#125;\n\n\n创建 fn create_mint 用于执行 创建账户和初始化账户 相关的指令\n\n构建具体指令，调用 solana_sdk 提供的执行指令的方法，对指令进行调用和传参\n\n构建创建mint的指令，指令参数 program_id, accounts 参照该指令对应的合约端对应程序参数进行传递\n\n创建合约端对应指令，client端调用执行指令的函数传参需要参照合约端指令接收的参数传入\n\n合约端只有一个入口函数，我们会定义一个统一的入口处理器以及指令枚举\n指令枚举用于定义各种代币的操作指令及参数\n入口处理器解析指令data来匹配指令枚举，得出具体执行哪个指令函数\n定义指令枚举需要用到内部提供的 Borsh 库自动实现对指令data的序列化反序列化操作，不用手动对数据做处理和解析\n\n\n合约端使用 solana_program::program::invoke 之类的方法执行定义的指令\n\nclient端通过创建于合约端的通信桥梁——RPC_Client 来创建交易、发送及确认交易实现调用对应的合约端程序\n\n合约端会有两个具体指令\n\ncreate_mint：用于创建mint账户，及初始化账户\nmint_token：用于token转账\n\n\n\nrust program 端 — create_mint\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273pub fn create_mint(accounts: &amp;[AccountInfo], decimals: u8) -&gt; ProgramResult &#123;       // 创建迭代器，用于读取传入的账户列表       let accounts_iter = &amp;mut accounts.iter();       // 支付账户       let payer = next_account_info(accounts_iter)?;       // mint账户（代币账户）       let mint_account = next_account_info(accounts_iter)?;       // 拥有铸币权限的账户       let mint_authority = next_account_info(accounts_iter)?;       // 用于存储租金的账户       // initialize_mint 指令需要这个账户       let sysvar_rent = next_account_info(accounts_iter)?;       // 系统程序，the owner of wallet_account       let system_program = next_account_info(accounts_iter)?;       // 系统程序，负责管理mint_account和token_account，提供了创建和管理这些账户的指令       let token_program = next_account_info(accounts_iter)?;       // mint账户所需空间       let mint_space = Mint::LEN;       // 创建mint账户需要的租金       let rent_lamports = Rent::minimum_balance(&amp;Rent::default(), mint_space);       // 创建Mint账户       let create_mint_ix = create_account(           payer.key,           mint_account.key,           rent_lamports,           mint_space as u64,           // 该字段owner指的是当前被创建账户的所有者程序，即只有该owner程序才能写入或修改该账户           token_program.key,       );       // 和当前指令读取账户列表的顺序保持一致       let accounts_info = &amp;[           payer.clone(),           mint_account.clone(),           system_program.clone(),           token_program.clone(),       ];       _ = invoke(&amp;create_mint_ix, accounts_info);       msg!(&quot;Create mint account successfully!&quot;);       // 初始化Mint账户       let initialize_mint_ix = initialize_mint(           token_program.key,           mint_account.key,           mint_authority.key,           None,           decimals,       );       match initialize_mint_ix &#123;           Ok(ix) =&gt; &#123;               let accounts_info = &amp;[                   token_program.clone(),                   mint_account.clone(),                   mint_authority.clone(),                   sysvar_rent.clone(),               ];               _ = invoke_signed(&amp;ix, accounts_info, &amp;[]);               msg!(&quot;Initialize mint account successfully!&quot;);           &#125;           Err(e) =&gt; &#123;               msg!(&quot;Intialize mint account failed, &#123;&#125;&quot;, e);               panic!(&quot;Error&quot;)           &#125;       &#125;       return Ok(());   &#125;\n\n\n\nrust_client 端 — create_mint\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051fn create_mint(    client: &amp;RpcClient,    program_id: &amp;Pubkey,    payer: &amp;Keypair,    mint_account: &amp;Keypair,    mint_authority: &amp;Pubkey,    decimals: u8,) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; &#123;    let accounts = vec![        // payer        AccountMeta::new(payer.pubkey(), true),        // mint_account        AccountMeta::new(mint_account.pubkey(), true),        // mint_authority        AccountMeta::new_readonly(*mint_authority, false),        // system_rent        AccountMeta::new_readonly(sysvar::rent::id(), false),        // system_program        AccountMeta::new_readonly(system_program::id(), false),        // token_program        AccountMeta::new_readonly(spl_token::id(), false),    ];    let instruction_data = borsh::to_vec(&amp;TokenInstruction::CreateMint &#123; decimals &#125;).unwrap();    // 构建创建mint的指令    let create_mint_ix = Instruction &#123;        accounts,        program_id: *program_id,        data: instruction_data,    &#125;;    let recent_blockhash = client.get_latest_blockhash()?;    // 创建交易并为其添加指令    let tx = Transaction::new_signed_with_payer(        &amp;[create_mint_ix],        Some(&amp;payer.pubkey()),        &amp;[payer, mint_account],        recent_blockhash,    );    // 发送和确认交易    match client.send_and_confirm_transaction(&amp;tx) &#123;        Ok(sig) =&gt; &#123;            println!(&quot;Mint Address: &#123;&#125;&quot;, mint_account.pubkey());            println!(&quot;Transaction Signature: &#123;&#125;&quot;, sig);        &#125;        Err(e) =&gt; &#123;            eprintln!(&quot;Transaction failed: &#123;:?&#125;&quot;, e);        &#125;    &#125;;    return Ok(());&#125;\n\n\n\n\n\nhttps://solana.com/docs/core/cpi   需要理解这篇内容！！Cross Program Invocation（CPI）CPI 指的是当一个程序调用另一个程序的指令们。这个机制允许Solana程序的可组合性。\n","slug":"create-basic-program","date":"2025-03-20T05:42:13.000Z","categories_index":"","tags_index":"solana","author_index":"Marnie"},{"id":"4b5a0f639775a39c3a751526b5f7688f","title":"spl-token-contract","content":"Solana SPL Token 合约简单实现\n\n\n\n\n\n\n\n\n可参考官方实战案例：https://solana.com/developers/courses/native-onchain-development/program-state-management\nSolana 项目结构核心文件\n\nprocessor.rs：核心业务逻辑，处理指令。\nstate.rs：定义账户的状态和拓展字段。\ninstruction.rs：定义各种代币操作的指令。\nerror.rs：定义了程序可能抛出的错误。\nlib.rs：程序入口点，汇总各个模块。\n\n涉及账户在Solana的账户体系中，账户主要分为三大类：原生账户、程序账户 和 数据账户\n\n程序账户：是用于存储可执行的程序，简单来说就是一些指令，负责处理交易过程中的一些逻辑。\n数据账户：是用于存储账户数据的，简单来说就是原本链上都是 stateless 的，如果需要数据管理就对应创建一个账户用来存储数据。\n原生账户：由 Solana Labs 内部提供的所属于系统的账户，用于提供 Solana 网络的核心功能如创建账户、分配空间、分配所有权等。\n\n一般 xxx_program 则表示 某某程序账户 或 系统账户，xxx_account 则表示 某某数据账户。每个数据账户都有一个 owner 字段，表示属于哪个程序账户所有，只有 owner 字段的账户才有权修改数据账户的数据。\n常用非数据账户：\n\nSystem Program：\n原生账户，创建账户、分配空间、分配所有权等操作。\n分配所有权是指当系统账户创建出新账户后，原本属于系统账户所有，可以修改它的所有者为其他账户。\n所有 钱包账户 的 owner 都为原生账户，所以系统账户才能对钱包账号进行转账操作。\n\n\nToken Program：\nSPL（Solana Program Library） 提供的用于管理 Mint Account 和 Token Account 的一个程序账户。\nToken Program 是 Token Account 的 owner。\n\n\nAssociated Token Program：\n用于追踪 ATA 和 钱包地址关联的程序账户。\nATA 的 owner 是 Associated Token Program。\n\n\n\n常用数据账户：\n\nRent Account：\n属于 Sysvar Accounts 中的一类，本质上是一个数据账户，用于存储和 Rent 相关的数据信息。\nRent Account 的 owner 为 System Program。\n\n\nMint Accout：\n存储某个代币元数据的账户。\nowner 为 创建代币 的 program ID。\n\n\nAssociated Token Account：\n属于 Token Account 中的一种，用于管理 某个钱包地址 和 某个 Mint 之间的关联数据。\nowner 为 SPL 提供的 Associated Token Program。\n\n\nWallet Account：\n某个钱包，交易使用其公钥地址。\nowner 为 System Program。\n\n\n\n在 Solana 区块链上，创建一个 mint账户（铸币账户）并分发给某个钱包账户会有以下步骤：\n\n创建铸币账户（Mint Account），用于创建某个新代币，铸币账户存储代币相关的元数据，如发行量等。\n创建代币账户（Token Account），代币账户是某个个体所持有某个代币数量及所有权的账户。\n分发代币（Mint Tokens），将某个铸币账户和某个代币账户进行关联，并更新铸币账户的发行量、代币账户的持有量等。\n\n官方给出的关系图\n\nclient 端（Rust）\nrpc_client：创建 RPC 客户端，建立和区块链网络通信的桥梁\nread_keypair_file: 获取本地 wallet address\n\n\n合约端（Rust）\nsolana_program::system_instruction::create_account\n\n在Solana区块链上，创建一个mint账户（铸币账户）涉及到多个关键账户。以下是每个账户的作用：\n创建 Mint Account相关账户\n\nmint_account: 铸币账户\n\n\n创建 Token Account相关账户’\n\nmint_account：关联的铸币账户\nassociated_token_account: ATA 账户\n\n","slug":"spl-token-contract","date":"2025-03-15T03:25:30.000Z","categories_index":"","tags_index":"solana","author_index":"Marnie"},{"id":"862a15ca9d7f5ce192b03b7aed288867","title":"solana-token","content":"Solana 上的代币代币是代表对各种资产所有权的数字资产。代币化使得财产权的数字化成为可能，是管理「可替代和不可替代资产」的基本组成部分。\n\n可替代代币代表同类型和同价值的可互换和可分割的资产（如 USDC）。\n不可替代代币（NFT）代表不可分割的资产的所有权（如 艺术品）。\n\n代币就是我们平常所提到的 token。\nSPL（Solana Program Library）\nToken Program（代币程序）是系统程序，无需关心\nMint Account（铸币账户）负责 token 的发行和销毁\nToken Account（代币账户）用户这边的账户\nAssociated Token Account（关联代币账户）\n\n关系\n\nToken Program 是系统程序，负责管理 Mint Account 和 Token Account，提供了创建和管理这些账户的指令（instructions）。\nMint Account 是存储了代币元数据的账户，每个 Token Account 都会关联到一个 Mint Account，表示该账户存储的是哪种代币。\nToken Account 是存储了用户代币余额的账户，并关联到一个 Mint Account，每个用户对每种代币都有一个独立的 Token Account。\nSystem Program 用于创建账户、分配账户空间并支付租金。\n\nKey Points\nToken 代表对可替代资产和不可替代资产的所有权。\nToken Program 包含在网络上与可替代资产和不可替代资产交互的所有指令。\nToken Extension Program 是 Token Program 的一个新版本，在保持了下同样的核心功能外还包括了一些额外的功能。\n一个 Mint Account 代表一种唯一的代币，且存储了诸如发行量等的元数据。（可以理解为Mint说的就是某个代币。）\n一个 Token Account 用于追踪个体账户对某个特定代币的所有权。（某个账户持有某个Mint的相关数据。）\n一个 ATA 账户指的是一个用某个钱包地址和 Mint Account 地址由系统派生出的 Token Account 的地址。（一般我们在实现合约代码的时候，都是 client端创建出一个 ATA 账户，用于自动处理当前钱包和Mint Token账户之间的关联，由系统自动管理账户。基础的 Token Account 适用于手动管理账户的场景，一般我们使用不到。）\n\nMint Account 铸币账户Mint Account 是每个 SPL Token 的核心账户，负责代币的定义和管理。它包含了代币的全局属性，比如总供应量和小数位数。每个代币都由一个独立的 Mint Account 来表示。\n属性\n\nDecimals：小数位数，定义代币的最小单位，通常是 0 到 9。\nSupply：供应量，代币的当前总供应量。\nMint Authority：一个拥有铸造权限的公钥（Pubkey），可以铸造新的代币的账户。\nFreeze Authority：冻结权限，可以冻结或解冻代币账户的权限（可选）。\n\n功能\n\n铸造代币：当 Mint Authority 执行铸币操作时，新的代币会增加到总供应量中，并分配给指定的 Token Account。\n销毁代币：减少总供应量。\n\nToken Account 代币账户Token Account 是用于持有特定 SPL Token 的账户。每个用户或者合约如果想要持有某种 SPL Token，必须有一个与该 Token 对应的 Token Account。不同的代币有不同的 Token Account，账户之间无法混用。\n属性\n\nAmount：余额，账户中持有代币的数量。\nOwner：账户拥有者，控制该账户的用户或合约地址。\nMint：关联的铸币账户，该账户与哪个 Mint Account 相关联。\nDelegate：代理账户，可以被授权管理该账户的其他账户（可选）。\nState：状态，账户是否处于冻结状态。\n\n功能\n\n接收和发送代币：Token Account 可以接受其他账户的代币，并通过转账指令将其发送给其他账户。\n代理权限管理：可以设置 Delegate 来授权第三方管理该账户的代币（多签）。\n\nAssociated Token Account 关联代币账户Associated Token Account（ATA）是 Token Account 的一种特殊类型，简化了 SPL Token 的账户管理。ATA 是自动与一个钱包地址绑定的账户，每个钱包地址和每个代币的 Mint（关联的铸币账户） 对应一个唯一的 Token Account，因此该账户类型极大简化了代币管理。\n特点\n\n唯一性：每个钱包地址只能有一个和某个 Mint 关联的 ATA。\n自动生成：Solana 提供了工具来自动生成 ATA，开发者不需要手动管理账户。\n\n功能\n\n自动处理钱包地址与代币账户之间的关联，方便用户管理不同的 SPL Token。\n\n创建 Token用命令创建 SPL Token\n1234567891011// 申请一个新钱包地址(私钥)solana-keygen new --outfile ~/.config/solana/t1.json// 设置当前使用该钱包地址// solana config set --keypair ~/.config/solana/t1.json// 创建 spl tokenspl-token create-token// 查看 spl token 账户spl-token account-info --address 5S3WQTHLJDkLZZutdhkqkyQgWLcCcBEM7NeyL8BphhmW\n\n\n\n每个 SPL Token 的创建会关联一个 Mint Account 作为其核心账户，上面的 account-info 就是该 token 关联的 Mint Account 信息。\n创建 Token Account创建完 SPL Token 后，我们再创建一个 Token Account 持有该 SPL Token。create-account 需要提供铸币账户的地址，即 token 关联的 Mint Account 地址，可以从上面的 token account-info 中拿到对应的 Mint 地址。这种由工具 create-account 自动生成的 Token Account 被称为 ATA。且每个钱包地址只能有一个和某个 Mint 关联的 ATA。\n1spl-token create-account 5S3WQTHLJDkLZZutdhkqkyQgWLcCcBEM7NeyL8BphhmW\n\n新创建的账户地址：\n\n复制该账户地址可以上网站查询 Account 信息：\n\n非 ATA 账户创建\n12// &lt;TOKEN_MINT_ADDRESS&gt; [ACCOUNT_KEYPAIR] 除了关联 Mint 地址，还需要提供关联钱包地址（私钥）spl-token create-account 1CV2MDTfGroptxCHAhEKTLzFf16cLtrHnc4SrnzeiLo /Users/wuwenqi/.config/solana/t1.json \n\n\n\n\n&#x2F;&#x2F; BRGy9tKRVz2p2wZaDk6UUBR54CkNrV1edvRqEXHqwdcP\n对 Token Account 进行 token 转账\n给 ATA 进行转账\n12// spl-token mint &lt;TOKEN_MINT_ADDRESS&gt; &lt;TOKEN_AMOUNT&gt;spl-token mint 1CV2MDTfGroptxCHAhEKTLzFf16cLtrHnc4SrnzeiLo 100\n\n\n\n给 Token Account 进行 token 转账\n12// spl-token mint &lt;TOKEN_MINT_ADDRESS&gt; &lt;TOKEN_AMOUNT&gt; -- &lt;RECIPIENT_TOKEN_ACCOUNT_ADDRESS&gt;spl-token mint 1CV2MDTfGroptxCHAhEKTLzFf16cLtrHnc4SrnzeiLo 100 -- BMYskNiRNNiwQbw59p2kgKQADGVhtfbvF3V144jG73si\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"solana-token","date":"2025-03-14T05:09:58.000Z","categories_index":"","tags_index":"solana","author_index":"Marnie"},{"id":"80ed7c116b6e6514a2ce292980fb566a","title":"solana-accounts","content":"Solana Account ModelAccount Types\n数据账户，用来存储数据\n系统所有账户\n程序派生账户（PDA）\n\n\n程序账户，用来存储可执行程序\n原生账户，指 Solana 上的原生程序，e.g. System,Stake,Vote …\n\nKey Points\n账户是用来存放数据的\n每个账户都有一个独一无二的地址（public_key）\n每个账户大小不能超过 10MB（space）\n账户大小是静态的\n账户数据存储需要付租金（rent_epoch）\n默认的账户所有者是“系统程序”\n\nFields\n\ndata：存储着账户数据的字节数组。当账户为可执行程序时，则存储需要被执行的程序，若不是则存储只读的账户数据。\nexecutable：是否为可执行程序。\nlamports：账户余额。\nowner：该账户的所有者 public_key（或者叫 program ID）。\nrent_epoch：现已被弃用的字段，原设计配合 Solana 租金机制，用于记录定期需要像账户收取的租金。\n\n12345678910111213pub struct Account &#123;    /// lamports in the account    pub lamports: u64,    /// data held in this account    #[cfg_attr(feature = &quot;serde&quot;, serde(with = &quot;serde_bytes&quot;))]    pub data: Vec&lt;u8&gt;,    /// the program that owns this account. If executable, the program that loads this account.    pub owner: Pubkey,    /// this account&#x27;s data contains a loaded program (and is now read-only)    pub executable: bool,    /// the epoch at which this account will next owe rent    pub rent_epoch: Epoch,&#125;\n\n\n\nLamportsLamport 是 Solana 网络中最小的不可分割的单位，即最小的原生代币单位（Lamport 是以计算机科学家 Leslie Lamport 的名字命名的，他是分布式系统领域的先驱）。1 SOL &#x3D; 1,000,000,000 Lamports（即 10 亿 Lamports），Solana 上所有费用都是最终以 Lamport 为单位交易的。由于 Lamport 足够的小，所以允许 Solana 网络处理非常小的金额（对外是 SOL），确保计算的精确性。\nNative Programs 原生程序对应上面说的账户类型 —— 原生所有账户，包括了一系列实现了 Solana 网络核心功能的程序，这些程序都被称为原生程序。\nSystem Program 系统程序所有新账户都归 System Program 所有，系统程序负责处理以下一些关键人物：\n\n创建新账户：只有系统账户可以创建新账户。\n空间分配：设置每个账户，数据字段需要的字节容量。\n分配程序所有权：系统账户一旦创建了一个账户，它能将指定的程序所有者重新分配给不同的程序账户。这就是为什么自定义程序可以拿到系统程序创建的新账户的所有权。\n\n所有 钱包账户 是 Solana 链上最简单的 系统所属账户。只有 系统所属账户 才能被作为交易的支付方进行支付\n\nPDA 程序派生账户 Program Derived Address由某一个程序派生出的账户，一般用于存储 账户数据或需执行的程序 所创建。只有派生父级程序（某个智能合约）才能操作该 PDA 账户，且没有 私钥，所以保证了数据安全性。\nSysvar AccountsLifecycle of an account\n项目实战常用命令\n12345678910// 添加 solana 相关库cargo add solana_clientcargo add solana_client// 生成新的账户公钥solana-keygen new -o  ~/.config/solana/id2.json// 配置切换至新账户solana config set --keypair ~/.config/solana/id2.jso\n\n\n\n转账相关实践\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162use std::str::FromStr;use solana_client::rpc_client::RpcClient;use solana_sdk::pubkey::Pubkey;use solana_sdk::signature::read_keypair_file;use solana_sdk::signer::Signer;use solana_sdk::system_instruction;use solana_sdk::transaction::Transaction;// solana address// pubkey1xxxxxx：500,000,000,000,000,000 lamports = 500 SOL// pubkey2xxxxxxfn main() &#123;    // 创建solana连接    let rpc_url = &quot;http://127.0.0.1:8899&quot;;    let client = RpcClient::new(rpc_url);    // 指定你要查询的余额账户公钥    // 接受空投账户    let account_pubkey = Pubkey::from_str(&quot;pubkey1xxxxx&quot;).unwrap();    // sender 发送方：需要用自己的私钥对该笔交易进行签名，以证明交易的合法性    let sender = read_keypair_file(&quot;/Users/[username]/.config/solana/id.json&quot;).expect(&quot;failed&quot;);    // receiver 接收方    let receiver_pubkey = Pubkey::from_str(&quot;pubkey2xxxxx&quot;).unwrap();    // 空投数量：最小单位 lamports，1 SOL = 1_000_000_000 lamports    let amount = 1_000_000_000; // 1 SOL    match client.request_airdrop(&amp;account_pubkey, amount) &#123;        Ok(signature) =&gt; println!(&quot;领取空投成功，交易签名：&#123;&#125;&quot;, signature),        Err(e) =&gt; eprintln!(&quot;领取空投失败：&#123;&#125;&quot;, e),    &#125;    // 获取账户余额    match client.get_balance(&amp;account_pubkey) &#123;        Ok(balance) =&gt; println!(&quot;账户余额：&#123;&#125; lamports&quot;, balance),        Err(e) =&gt; eprintln!(&quot;获取账户余额失败：&#123;&#125;&quot;, e),    &#125;    // 创建转账指令    let transfer_instruction =        system_instruction::transfer(&amp;sender.pubkey(), &amp;receiver_pubkey, amount);    // 创建交易：先获取最后一个区块哈希值    let recent_blockhash = client.get_latest_blockhash().unwrap();    let transaction = Transaction::new_signed_with_payer(        &amp;[transfer_instruction],        Some(&amp;sender.pubkey()),        &amp;[&amp;sender],        recent_blockhash,    );    // 发送与确认交易    let result = client.send_and_confirm_transaction(&amp;transaction);    match result &#123;        Ok(signature) =&gt; println!(&quot;发送成功，交易签名：&#123;&#125;&quot;, signature),        Err(e) =&gt; eprintln!(&quot;交易失败：&#123;&#125;&quot;, e),    &#125;&#125;\n\n\n\n","slug":"solana-accounts","date":"2025-03-11T17:14:06.000Z","categories_index":"","tags_index":"solana","author_index":"Marnie"},{"id":"4924e3fdb08216102217b9102664f654","title":"solana-development","content":"Solana 合约开发添加 Solana 智能合约依赖\n1cargo add solana-program\n\n修改 Cargo.toml  添加 [lib]\n[lib] 部分（即 Library）一般是用来配置当前 package 作为 library 被其他库或者可执行的东西引用时的一些配置。\n1234[lib]crate-type = [&quot;cdylib&quot;, &quot;lib&quot;]// 默认 &quot;lib&quot;, 表示当前 package 作为一个 Rust Library 使用// &quot;cdylib&quot; 表示当前 package 可以作为一个兼容 C语言的 Library 使用\n\n当标注了 &quot;cdylib&quot; ，在编译后会生成可以被 non-Rust 程序使用的不同类型文件，如 .so on Linux, .dylib on macOS, or .dll on Windows。\nlib crate 和 binary crate 有什么区别？智能合约（Smart Contract）是一种运行在区块链上的程序，用于自动执行、验证或强制执行合约条款。\n在 Solana 中，Program 程序指的就是 合约，Instruction 指令是一个合约或者程序的基本操作单元，它定义了程序需要执行的具体操作以及所需数据。每个 Instruction 需要包含以下信息：\n\n程序 ID：调用程序的公钥。\n账户列表：Instruction 操作所需的所有账户。\n指令数据：需要传给程序的特定数据，用于指定程序的具体行为。\n\nInstruction 指令所有合约的交互都从一个函数开始，这个函数被称为 入口函数：\n1234567pub fn process_instruction(    program_id: &amp;Pubkey,    accounts: &amp;[AccountInfo],    instruction_data: &amp;[u8],) -&gt; ProgramResult &#123;    Ok(())&#125;\n\n\n\nprocess_instruction 有 3 个参数：\n\nprogram_id: 调用程序的公钥 public_key\naccounts: 合约需要交互的所有账户\ninstruction_data: 需要传给合约的数据\n\n返回 Ok(()) 表明合约调用全部成功。\ncargo build-sbf 构建合约\n在区块链上，所有的操作或者说交互都需要由 transaction（转账） 实现\nAnchor 框架Anchor 框架使用 Rust 宏来减少样板代码量和简化编写 Solana 程序所必须得常用安全检查实现。\n一个 Anchor 程序主要使用到的宏包含：\n\ndeclare_id: 指定程序的链上地址\n#[program]: program 是一个属性宏，指定含有程序指令 instruction 逻辑的模块\n#[derive(Accounts)]: Accounts 是一个 trait，它可以应用于某个结构体，让该结构体可以用来表示指令所需的账户列表\n#[account]: 也是一个属性宏，应用 account 结构体，为程序创建自定义的账户类型\n\ndeclare_id!(program ID)默认，program ID  是 /target/deploy/your_program_name.json 生成的密钥对中的公钥（public key），如果需要修改，直接更新文件后，执行 anchor keys sync 同步密钥。一般如果是 clone repository 的状况，就需要手动修改密钥对 after cloning。\n#[derive(Accounts)]Define instruction accounts 定义指令交互需要的账户及账户类型。Anchor 内部提供了很多种账户类型，可以按需使用，也支持 custom account structures。\nAccount&lt;T&gt;自定义账户类型需要使用 Account&lt;T&gt; wrapper 包裹，它是一个包装器，在 Solana 账户工作时会提供额外的功能和安全性。\n\nDeserialization 反序列化：Account 类型会自动的将账户数据反序列化进你的自定义类型。不需要你手动转化原始账户数据。\nOwnership Check 所有权校验：Anchor 需要确保账户被正确的程序拥有，如果不是预期得程序，会抛出错误。\nType Safety 类型安全性：通过包裹 Account 类型，确保账户数据符合预期的类型。\n\n#[account] attribute区块链上的程序都被称为「智能合约」，智能合约内的所有实体或者说和指令需要操作的对象都定义为「账户」。所以当我们编写合约代码时，需要定义指令交互所需要的账户及其类型，而如果我们需要使用自定义账户类型就需要标注 #[account] 告诉 Anchor 这是一个自定义账户类型，Anchor 自身提供的账户类型某种程度上已经做了很多处理，而自定义账户类型就需要手动提供一些设置信息来通过必要的一些检查和安全性校验。而为了简化这些事情，Anchor 就提供了 #[account] 宏来表示这是一个账户类型，且为其实现了一些方法可供调用，快速设置信息。\n这个宏实现了许多特征，主要的功能包含：\n\nAssign Program Owner：当创建一个账户类型时（创建账户意味着这不是内置的账户类型），账户的程序 Owner 自动会被设置为 declare_id 接收的 program ID。\nSet Discriminator 设置鉴别器：初始化账户时，会添加到账户数据的前 8 个字节，它是一个唯一的 8 个字节鉴别器，特定于表示账户类型。这个有助于区分账户类型并用于账户验证。\nData Serialization and Deserialization 数据序列化和反序列化：账户数据会根据账户类型被自动序列化和反序列化。\n\n关于账户类型，Anchor 提供了很多 Account Constraints，用于简化自定义账户类型需要提供的一些属性，这些属性是通过账户类型校验和安全性检查必不可少的。\n和 web2 的区别web2 中数据都是存储在数据库中，但在 web3 的世界观中，和传统的 中心化数据库 不一样，是 去中心化数据 存储的一个概念。像在 Solana 这样的区块链平台上，数据是存储在 账户（Accounts） 中的，而每个账户都会有一个唯一的地址（public_key），通过公钥就能查询到相关的账户数据。\n\n程序账户（Program Accounts）：存储程序的代码和状态。\n数据账户（Data Accounts）：存储用户和程序的数据。\n\nPDA（Program Derived Address）程序派生地址PDA 是一种由程序生成的地址，它与用户的 public_key 和 某个种子（seed）相关联。通过 PDA，可以确保每个用户关联的数据账户地址是唯一的，并且可以通过用户的 public_key 推导出来。\nTest 流程本地起一个测试服务 solana-test-validator，编写完成测试代码，执行 anchor test --skip-local-validator，每次测试完成后会返回一个 signature，该 signature 是此次验证的唯一标识，由它去 explorer.solana.com 上查看相关日志。\n\n\nClient Program使用 Solana 钱包适配器整合前端时，你需要设置 AnchorProvider 和 Program 。\n练习通过 Anchor 框架实现一个 todo 项目，并部署到 devnet\n\n \n新建 todo\n\n \n查看 todo\n\n \n删除 todo item\n\n\n","slug":"solana-development","date":"2025-02-28T07:40:06.000Z","categories_index":"","tags_index":"solana","author_index":"Marnie"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"区块链是什么？\n一个区块链代表“一个分布式的数据库，它储存了一个连续可增长有序记录列表，称之为块”。这些块通过加密学（cryptography）被链接在一起。每一块都包含了前一块加密哈希值，一个时间戳和交易数据（transaction data）。\n一个区块链是一个去中心化的、分布式和公共的数字账本（ledger）用来记录多台电脑之间的交易，这样在不改变后续区块和网络共识的情况下，这些记录是无法通过追溯修改的。\n区块头区块体区块哈希\n交易流程\n交易验证\n共识机制\nPoW\n智能合约（dApp RPC）\n去中心化网络（P2P）\n\n钱包的作用？？\n跟链上交互 存储资产\nairdrop 空投\nSolana airdrop 5 申领 5 个空投\nRPC 是什么\n练习\n练习 solana-cli 的常见用法\n切换到 devnet\n\n 创建多个钱包\n 领取空投\n 通过 cli 实现各个钱包之间转账交易\n 查看账户余额\n 通过区块浏览器查看交易记录\n\n1234567891011// 1. 创建钱包solana-keygen new// 2. 领取空投// 创建一个本地 test validatorsolana-test-validator// 领取5个空投 localnetsolana airdrop 5// 领取10个空投 devnetsolana airdrop 10 --url devnet\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"solana-build-up","date":"2025-02-26T03:36:38.000Z","categories_index":"","tags_index":"solana","author_index":"Marnie"},{"id":"f864dad737968a616c4c3f1e607829b4","title":"trading-view-chart","content":"在 TradingView 图表 中，Symbol（符号） 是一个核心概念，用于表示一个特定的 金融工具 或 资产。每个 Symbol 代表一个可以在图表上显示和分析的交易品种，例如股票、加密货币、外汇货币对、商品、指数等。\n\nSymbol 的含义\n唯一标识符：\n\nSymbol 是金融工具的唯一标识符。例如：\n股票：AAPL（苹果公司）、TSLA（特斯拉）。\n加密货币：BTCUSD（比特币兑美元）、ETHUSD（以太坊兑美元）。\n外汇货币对：EURUSD（欧元兑美元）、GBPJPY（英镑兑日元）。\n商品：XAUUSD（黄金）、CL（原油期货）。\n指数：SPX（标普 500 指数）、NASDAQ（纳斯达克指数）。\n\n\n\n\n数据源：\n\nSymbol 与特定的数据源相关联，数据源提供该金融工具的历史价格、实时价格、成交量等信息。\n\n\n图表显示：\n\n在 TradingView 图表中，选择一个 Symbol 后，图表会显示该金融工具的价格走势、技术指标、成交量等信息。\n\n\n\n\nSymbol 的组成在 TradingView 中，Symbol 通常由以下部分组成：\n\nTicker（代码）：\n\n金融工具的简称或代码。例如，AAPL 是苹果公司的股票代码。\n\n\nExchange（交易所）：\n\n金融工具所在的交易所。例如，NASDAQ:AAPL 表示纳斯达克交易所的苹果公司股票。\n\n\nType（类型）：\n\n金融工具的类型。例如，stock（股票）、crypto（加密货币）、forex（外汇）、index（指数）等。\n\n\n\n\nSymbol 的使用场景\n图表分析：\n\n用户可以通过输入 Symbol 来加载特定金融工具的图表，进行技术分析、绘制趋势线、添加指标等操作。\n\n\n交易：\n\n如果 TradingView 与经纪商集成，用户可以通过 Symbol 直接在该金融工具上进行交易。\n\n\n观察列表：\n\n用户可以将多个 Symbol 添加到观察列表中，方便跟踪它们的价格变化。\n\n\n警报：\n\n用户可以为特定 Symbol 设置价格或技术指标警报。\n\n\n\n\nSymbol 的格式Symbol 的格式取决于金融工具的类型和交易所。以下是一些常见的格式：\n\n股票：\n\nTICKER:EXCHANGE。例如，AAPL:NASDAQ 表示纳斯达克交易所的苹果公司股票。\n\n\n加密货币：\n\nTICKER。例如，BTCUSD 表示比特币兑美元。\n\n\n外汇货币对：\n\nCURRENCY1CURRENCY2。例如，EURUSD 表示欧元兑美元。\n\n\n商品：\n\nTICKER。例如，XAUUSD 表示黄金兑美元。\n\n\n指数：\n\nTICKER。例如，SPX 表示标普 500 指数。\n\n\n\n\nSymbol 的配置在自定义数据源或 TradingView 集成中，Symbol 的配置通常通过 resolveSymbol 方法实现。以下是一个示例：\nresolveSymbol 方法示例1234567891011121314151617resolveSymbol(symbolName, onSymbolResolvedCallback, onResolveErrorCallback) &#123;  const symbolInfo = &#123;    name: symbolName,    ticker: symbolName,    description: &#x27;Apple Inc.&#x27;, // 描述    type: &#x27;stock&#x27;, // 类型    session: &#x27;0900-1600&#x27;, // 交易时段    timezone: &#x27;America/New_York&#x27;, // 时区    minmov: 1, // 最小价格变动    pricescale: 100, // 价格精度    has_intraday: true, // 是否支持日内数据    supported_resolutions: [&#x27;1&#x27;, &#x27;5&#x27;, &#x27;15&#x27;, &#x27;60&#x27;, &#x27;D&#x27;], // 支持的分辨率    volume_precision: 2, // 成交量精度    data_status: &#x27;streaming&#x27;, // 数据状态  &#125;;  onSymbolResolvedCallback(symbolInfo);&#125;\n\n\nSymbol 的重要性\n数据加载：\n\nSymbol 是加载金融工具数据的关键。TradingView 通过 Symbol 从数据源获取价格、成交量等信息。\n\n\n图表功能：\n\nSymbol 决定了图表上显示的内容，包括价格走势、技术指标、成交量等。\n\n\n交易集成：\n\n如果 TradingView 与经纪商集成，Symbol 是执行交易的基础。\n\n\n\n\n总结在 TradingView 图表中，Symbol 是表示特定金融工具的唯一标识符。它决定了图表上显示的数据和功能，是 TradingView 的核心概念之一。通过正确配置和使用 Symbol，用户可以在 TradingView 上分析各种金融工具的价格走势并进行交易。\n","slug":"trading-view-chart","date":"2025-02-23T15:13:18.000Z","categories_index":"","tags_index":"","author_index":"Marnie"},{"id":"f2e9bd63ae70d3e67dc2ed334f1346f1","title":"solana_basic","content":"epoch（epək）  Epoch Timestamp\nruntime 模块\nprograms 模块\nnft 兴起\nnft 是什么？\n代币到底是什么？\nSolana的架构和名词概念更多名词概念都可以参考官网 documentation\nSOLSCAN 是干什么的？\nAccounts 账户区块链里的账户指的是一个「钱包地址」\n钱包\nphantom\nsolflare\nbackpack\n\n一个账户下会有很多不同类型的资产，如 SOL、USDC、其他 …，每一个资产下面都是一个 「合约」，或者一个 「System的合约」。\n开发中会涉及到生成钱包的功能\n合约类似于合同，合约生成之后会有和它做交互的接口，\n验证器 Validator用于节点搭建的时候\n区块浏览器钱包怎么用\nAddress类似账户地址\naddress 和 钱包地址是一个东西 么？？\nTransfer转账，类似银行转账，需要提供一个接收地址\ndApp这是啥？？\nToken有合约生成之后的东西被称为 token，一般理解为 代币（或者通证）。比如 Solana 生态中的「系统代币」叫「SOL」，系统代币对应的是系统合约\nFee一笔交易中所需的费用\nBlock区块的高度，每一个区块都是往前走的，以时间往上递增\n租约每个账户在生成之后，是需要向平台支付托管费用的，这个收取费用的载体称为「租约」。类似传统市场中的信用卡卡年费，这也是平台盈利的一个途径。\n签名 Signature在一笔交易成功时，是需要有 Sign 和 Submit 的行为的，用于将你的钱包授权给某个 dApp，让合约拥有操作你钱包的权限。每个链为了保证钱包的安全性，就会增加签名的一个约束，签名指的就是有没有做这个授权的状态。\n签名是怎么签的？？Sign和Submit是在哪个环节发生？？\n8 大核心技术POH，Tower BFT，Sealevel，CloudBreak，Gulf Stream，Turbine，Pipelining，Archivers\n共识是啥意思？？\nAccount\nSolana 上有三种类型的账户：\n数据账户存储数据\n程序账户存储可执行程序\n原生账户\n数据账户有两种类型：\n系统拥有的账户\nPDA（程序派生地址）账户，存储智能合约 &#x3D;&gt; 状态\n","slug":"solana-basic","date":"2025-02-14T10:28:25.000Z","categories_index":"","tags_index":"solana","author_index":"Marnie"},{"id":"d644caf05d644047d4c92cde0f070d6e","title":"并发 Concurrency","content":"Concurrency in Rust在 Rust 中，并发（Concurrency）是一项核心功能，旨在安全高效的同时执行多个任务。\nSpawning Thread默认代码中的任务都是在主线程中执行的，Rust 在标准库中提供了 thread 模块，提供了操作线程的能力。\nCreating new thread123456789101112131415161718192021222324252627282930use std::thread::spawn;fn main() &#123;  spawn_thread();&#125;pub fn spawn_thread() &#123;    let thread_fn = || &#123;        let mut x = 0u128;        for i in 1..50_000_000 &#123;            x += i;        &#125;        println!(&quot;worker get x = &#123;&#125;&quot;, x);    &#125;;      println!(&quot;Starting new worker thread...&quot;);    let handle = spawn(thread_fn);    let handle2 = spawn(thread_fn);   loop &#123;        if handle.is_finished() &amp;&amp; handle2.is_finished() &#123;            println!(&quot;Worker 1,2 are completed...&quot;);            break;        &#125;    &#125;      println!(&quot;Worker threads are all finished...&quot;);    println!(&quot;Main thread has finished...&quot;);&#125;\n\nstd::thread::spawn(closure)std::thread::spawn 方法用于创建工作线程，接受一个闭包，闭包内写需要在该线程内执行的任务，该方法返回一个 JoinHandle 结构体。默认主线程上的任务和工作线程是随机执行的，无法固定执行顺序，工作线程依赖于主线程创建，主线程一旦退出后，即使有未执行完的工作线程上的任务，也会直接结束。\nJoinHandle 结构体提供了一些方法，其中就有阻止主线程终结的 join 方法，调用该方法可以阻止主线程的结束，它会等到该工作线程所有任务完成后再退出。\njoin 方法上面的例子我们在主线程写了一个 loop 函数来一直执行，直到 worker thread（handle+handle2） 执行完毕。is_finished() 方法是 JoinHandle 提供的用于查询工作线程是否结束的方法。除此之外用 join 能让主线程等待工作线程的执行。\n12345let handle = spawn(thread_fn);let handle2 = spawn(thread_fn);handle.join();handle2.join();\n\n\n\nThread variables 线程变量spawn 方法接收一个闭包，我们在学闭包部分的时候有提过，闭包的特性就是可以访问父级作用域内定义的变量，被称为 capturing variables，所以我们在新线程闭包函数内是可以访问父级作用域的变量的。比如下图例子：\n\nprint_age 闭包内使用了父级作用域的 user 变量，这时 Rust 会尝试像父级作用域借用 user，然而就会出现报错上的这个问题：Rust 并不知道这个闭包会存活多久或者更进一步，因为这个闭包是传入 spawn 方法创建新线程时用的，Rust 并不知道这个新线程会存活多久，所以它无法确认被借用的 user 一定是存在的（比如子线程借用变量，主线程销毁了变量），便得到了上面的报错。\n所以关于线程中使用外部变量有两种解决方案：\nmove closure 使用 move 关键字将变量的数据所有权转移到闭包内这相当于告诉编译器将变量转移到线程内作用域，线程结束后会自动 drop 变量。\n123456789use std::thread::spawn;let mut m = 10;let thread_fn = move || &#123;  m += 1;  println!(&quot;m = &#123;&#125;&quot;, m);&#125;;spawn(thread_fn);\n\n上面的 move closure 只适用于只需要在子线程内使用的变量，若在子线程结束后还需要使用的变量我们就需要改用 thread::scope 方法。\nstd::thread::scope普通的 threads 是 non-scoped threads，使用 thread::scope 提供一个 Scope 对象，用该对象提供的 spawn 方法支持创建带作用域的线程，它会确保等待这个 scope 内创建的所有线程的任务都执行完毕后才会离开当前作用域，这种自动等待的机制便让编译器可以推断变量借用的生命周期，不需要再手动转移变量所有权。\n1234567891011121314use std::thread::scope;let user = Person &#123;  name: String::from(&quot;Mark&quot;),  age: 20,&#125;;let print_name = || &#123;  println!(&quot;My name is &#123;&#125;.&quot;, user.name);&#125;;scope(|s| &#123;  s.spawn(print_name);&#125;);\n\n\n\n\n\nMessage Passing with MPSC channels线程间的通信方式为：Message Passing 消息传递。消息传递的载体是 channel ，channel 分为一个发送方（transmitter）一个接收方（receiver）。\n使用 mpsc::channel 函数创建 channel，mpsc meanings multiple producer single consumer（多生产者单消费者）。\n通信原则默认情况，channel 间消息通信都需要遵守多生产者单消费者的原则，这是为了防止数据竞争（data racing），可以有多个线程进行生产消息，但是消费或者说接收、处理消息的线程只能有一个。\n12345use std::sync::mpsc;// 创建一个 channellet (tx, rx) = mpsc::channel();// tx：发送方，rx：接收方\n\n\n\n多个生产者 multiple producers创建 channel 后，默认得到一个生产者一个消费者，如果需要使用多个线程进行消息生产的场景，我们可以使用 clone() 方法克隆原生产者，来创建该 channel 多个生产者。\n123456789use std::sync::mpsc;// 创建一个 channellet (tx, rx) = mpsc::channel();// 使用 Sender::clone 方法，clone一个生产者（符合channel多个生产者的主旨）let tx2 = mpsc::Sender::clone(&amp;tx);// 或者 clone trait 方法let tx3 = tx.clone();\n\n\n\n单个消费者 single consumer生产者向 Channel 中发送 message，消费者&#x2F;接收方 则可以从 Channel 中获取数据，常见使用 rx.recv() 获取。\n1234567let (tx, rx) = mpsc::channel();for received in rx &#123;  // Receiver实现了iterator trait  // 在fn next()的实现里内部会自动调用.recv()  println!(&quot;Main thread received String &#123;&#125;&quot;, received);&#125;\n\n\n\n手动释放发送方 manually drop transmitter当我们 发送方&#x2F;生产者 的逻辑写完后，需要手动调用 drop(tx) 释放 tx，避免造成无限循环查询 rx （rx.recv()）导致的子线程无法结束而阻塞主线程，发送方一旦被 drop 那么会自动与接收方断开连接（disconnect），recv() 结果会是 Err。**recv() 会阻塞主线程知道获取到 message 或达到终结条件**。\n线程间通过创建 Channel 进行通信，通信期间可以传递 state 实现内存共享。但 Channel 是单所有权，一旦通过 Channel 传入某个线程的 state ，所有权就转移到了接收线程中，就无法被其他线程再使用了。而共享内存是类似多所有权的概念，多个线程可以访问同一个内存，下面就来认识一下，如何在多个线程间共享数据。\nSharing data within multiple threads如上段结尾提到的一样，为了数据安全性的考虑，我们需要遵守只能存在一个线程消费（读取）消息的原则（单所有权）。但如果就是遇到了需要多个线程里都可能使用一个消息的场景，即多生产者多消费者（多所有权），我们也是可以支持的，但始终遵守同一时间只能存在一个真实消费消息的线程。需要使用 Mutex 互斥锁 + Arc 智能指针  ：\nMutex 用来防止多线程下的数据竞争，Arc 智能指针用来实现数据共享及多线程下需要共享的数据的安全性。\nMutex 互斥锁 是什么Mutex 让多个线程并发的访问同一个值变成了排队访问：同一时间，只允许一个线程A访问该值，其它线程需要等待A访问完成后才能继续。\n这就很符合我们 mpsc 的原则，一般单线程中我们并不需要使用互斥锁，单线程中本来就需要遵守所有权的限制，很大程度的避免了同时读写的场景。所以互斥锁的场景一般都是用于多线程访问同一个值。\nMutex 怎么使用创建12// 创建一个 Mutex 结构体变量let m = Mutex::new(5);\n\nMutex 是一个数据结构，它会类似 Box 智能指针一样持有数据。\n访问访问内部的数据需要使用 lock() 方法向 Mutex 变量申请一个锁，该方法会挂起当前线程，直到获取到锁，一旦有某一条线程获取到了锁，其他线程获取锁便会被阻塞，直到已经获取锁的线程将锁释放，这样便可以保证，同时只会有一条线程在操作数据。\nlock() 方法返回类型为 LockResult&lt;MutexGuard&gt;，一个用 Result 包裹的 MutexGuard 智能指针，所以要访问内部数据需要先使用 unwarp() 得到智能指针，再按照具体类型操作内部数据。\n1234567891011// 创建了一个Mutexlet score = Mutex::new(100);// lock()得到Resultlet unlocked_data = score.lock();// unwrap()得到MutexGuardlet mut data = unlocked_data.unwrap();// 操作datadata.add_assign(20);println!(&quot;My score is &#123;&#125;.&quot;, data);\n\n\n\n那么，如果同时有两个线程都在申请锁，哪个线程会成功呢？我们尝试用代码还原一下场景：\n12345678910111213141516171819202122232425262728293031323334353637383940414243use std::&#123;ops::AddAssign, sync::Mutex, thread::scope&#125;;pub fn test_mutex() &#123;    // 创建了一个 Mutex    let score = Mutex::new(100);    // 这里申请了锁    let unlocked_data = score.lock();    let mut data = unlocked_data.unwrap();    data.add_assign(20);    println!(&quot;My score is &#123;&#125;.&quot;, data);    // 释放上一个锁，✨ 这里如果不释放那么下面的线程里是无法申请到锁的    drop(data);    let my_func = || &#123;        println!(&quot;Thread 1 is waiting for mutex lock.&quot;);        let mut data = score.lock().unwrap();        for i in 1..=10 &#123;            data.add_assign(i);            println!(&quot;Thread 1 is adding &#123;&#125; and score is &#123;&#125;&quot;, i, data);        &#125;    &#125;;    let my_func2 = || &#123;        println!(&quot;Thread 2 is waiting for mutex lock.&quot;);        let mut data = score.lock().unwrap();        for i in 1..=10 &#123;            data.add_assign(i);            println!(&quot;Thread 2 is adding &#123;&#125; and score is &#123;&#125;&quot;, i, data);        &#125;    &#125;;    scope(|s| &#123;        s.spawn(my_func);        s.spawn(my_func2);    &#125;);    println!(&quot;The score is &#123;&#125;.&quot;, score.lock().unwrap());&#125;\n\n运行结果如下：\n\n可以看到，两个线程都在申请锁，但执行顺序一定是一个锁用完了释放了之后下一个锁才会继续。\n我们的目标是在多线程下实现共享一个消费者数据，除了使用 Mutex 互斥锁保证多线程下数据的同步访问，防止数据竞争（data racing）外，还需要使用智能指针实现数据共享，前面学习过在一条线程里我们使用 Rc 智能指针来实现一个资源拥有多个所有者，在多线程下是使用 Arc 智能指针，具体用法我们在练习部分再进行应用。\n练习1\n\nprocess_file 函数：接收 file_path，打印 file_content\n\n主线程：tx（发送方），假设有 10 个 file_path 要处理，遍历它们调用 clone 来创建多个生产者，模拟并发性的发送 file_path\n\n子线程（工作线程）：rx（接收方&#x2F;消费者），调用 process_file 函数，按照题意需要创建多个工作线程去接受消息，即会有多个线程需要借用消费者。在工作线程内 loop 访问接收方，根据接收方结果处理消息，直到没有可获取的消息为止\n\n最多同时处理 4 个文件：主线程中同时创建4个工作线程，每个工作线程都去访问消费者，处理消费者接收到的消息\n\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788fn process_file(path: &amp;str) &#123;    let mut file_name = String::from(path);    file_name.push_str(&quot;.txt&quot;);    println!(&quot;📔 Processing file: &#123;&#125;&quot;, file_name);&#125;fn practice() &#123;    let (tx, rx) = mpsc::channel();    // ✨创建多线程下共享的rx    let rx = Arc::new(Mutex::new(rx));    // 创建10个file_path    let mut file_paths = vec![];    for i in 1..=10 &#123;        file_paths.push(format!(&quot;&#123;&#125;&quot;, i));    &#125;    // main thread 中 clone 多个 transmitter（sender）    for path in file_paths &#123;        // ✨按照题意：使用多线程实现文件处理的并发性，主线程作为生产者向通道发送文件路径        let cloned_tx = tx.clone();        // 多生产者 multiple transmitter        cloned_tx.send(path.clone()).unwrap();        // 加点延时，看起来有效果的样子        thread::sleep(Duration::from_millis(100));    &#125;    // 创建多个子线程（工作线程）来处理消息    // 处理消息：调用 process_file 函数    // rx是接收方，是Arc智能指针包裹的Mutex互斥锁    // 共享rx：Arc::clone(&amp;rx)    // ✨按照题意我们需要创建多个线程去使用rx    // 最多同时处理4个文件    // handles用来存储创建后的线程    let mut handles = vec![];    // 同时创建4个线程    for i in 0..4 &#123;        println!(&quot;🔋 Worker thread &#123;&#125; get starting ...&quot;, i + 1);        // 创建共享的接收方，Reference count +1        let shared_receiver = Arc::clone(&amp;rx);        let consumer = move || &#123;            loop &#123;                // 申请锁-&gt;访问receiver                let unlocked_receiver = shared_receiver.lock();                // 拿到用Mutex存储的receiver                let receiver = unlocked_receiver.unwrap();                println!(&quot;🔄 Attempting to receive message from channel ...&quot;);                // 拿到receiver的结果                let receive_result = receiver.try_recv();                match receive_result &#123;                    Ok(msg) =&gt; &#123;                        // 拿消息对象中的内部数据                        println!(&quot;✅ Consumer received: &#123;&#125;&quot;, msg);                        process_file(&amp;msg);                        // 加点延时，看起来有效果的样子                        thread::sleep(Duration::from_millis(300));                    &#125;                    Err(mpsc::TryRecvError::Empty) =&gt; &#123;                        // No message received within the timeout                        println!(&quot;❓ Consumer: No message available immediately.&quot;);                        break;                    &#125;                    Err(mpsc::TryRecvError::Disconnected) =&gt; &#123;                        // Channel is disconnected, meaning all senders are dropped                        println!(&quot;❎ Consumer: Channel disconnected, exiting.&quot;);                        break;                    &#125;                &#125;            &#125;        &#125;;        // 因为我们需要借用variables，我们使用scope方法处理生命周期的问题        let handle = spawn(consumer);        handles.push(handle);    &#125;    // blocking main thread to wait for worker thread    // 遍历handles，手动调用join()来阻塞主线程的终结等待工作线程任务完成    for handle in handles &#123;        handle.join().unwrap();        println!(&quot;🪫 Worker thread is finished.&quot;);    &#125;    println!(&quot;✅ All files have processed.&quot;);&#125;\n\n\n\n\n\n练习2\n\n错误提示 —— 当前类型（ TaskSign ）需要是实现了 Send trait 的类型。Send trait 是一种标记（marker）特征，实现了该特征的类型会被编译器识别为 “线程安全的”（thread-safe），这是因为我们将标准的 “一个 receiver” 共享在多个线程之间，这个行为会被认为是不安全的（unsafe）。据查询，大部分内置类型都自动实现了 Send 特征，部分类型或者自定义类型需要手动加上 Send 特征。\nSend Trait一个标记特征，表示允许线程间转移所有权，基本上所有类型都实现了这个特征，除如 Rc 智能指针等的单线程类型除外，自定义类型可以通过派生实现 Send 特征。\nSync Trait同上，也是一个标记特征，表示允许由多线程访问，和 Send 一样基本所有类型都实现了这个特征。如果 T 实现了 Sync ，那么 &amp;T  肯迪实现了 Send ，或者说 T 实现了 Sync 只有是 &amp;T 实现了 Send 的情况下。因为 T 可以被多线程访问那它一定需要共享给多个线程，它必须是可以被传递到多个线程间的，一定是允许转移所有权的。\nSync 和 Send 都是为了保证数据安全、防止数据竞争所定义的一些规则。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118use std::&#123;    sync::&#123;        mpsc::&#123;self, Receiver, Sender&#125;,        Arc, Mutex,    &#125;,    thread::&#123;sleep, spawn, JoinHandle&#125;,    time::Duration,&#125;;struct Task &#123;    id: usize,&#125;impl Task &#123;    fn new(id: usize) -&gt; Self &#123;        Task &#123; id &#125;    &#125;    fn run(&amp;self) &#123;        println!(&quot;✅ Executing task &#123;&#125;&quot;, self.id);        sleep(Duration::from_secs(1));    &#125;&#125;struct Worker &#123;    id: usize,    // JoinHandle&lt;T&gt;, T refers to return value type of spawn()    handle: JoinHandle&lt;()&gt;,&#125;enum TaskSign &#123;    Task(Task),    End,&#125;type SharedReceiver = Arc&lt;Mutex&lt;Receiver&lt;TaskSign&gt;&gt;&gt;;// 工作线程池// 控制内部工作线程的工作和停止struct WorkerThreads &#123;    threads: Vec&lt;Worker&gt;,&#125;impl Worker &#123;    fn new(id: usize, handle: JoinHandle&lt;()&gt;) -&gt; Self &#123;        Worker &#123; id, handle &#125;    &#125;&#125;impl WorkerThreads &#123;    fn new() -&gt; Self &#123;        WorkerThreads &#123; threads: vec![] &#125;    &#125;    // 新增一个工作线程，每个工作线程的任务是持续查询 receiver    fn add_worker(&amp;mut self, receiver: SharedReceiver) -&gt; usize &#123;        let index = self.threads.len();        println!(&quot;🔑 New worker thread &#123;&#125;&quot;, index + 1);        let handle = spawn(move || loop &#123;            match receiver.lock().unwrap().recv() &#123;                Ok(TaskSign::End) =&gt; &#123;                    println!(&quot;🚦 Worker thread &#123;&#125; getting end signal.&quot;, index + 1);                    // 接收到停止信号，终结循环                    break;                &#125;                Ok(TaskSign::Task(task)) =&gt; &#123;                    println!(                        &quot;⏩ Worker thread &#123;&#125; is processing the task &#123;&#125;.&quot;,                        index + 1,                        task.id                    );                    task.run();                                  &#125;                Err(e) =&gt; &#123;                    eprintln!(&quot;❌ Worker thread &#123;&#125; error: &#123;&#125;&quot;, index + 1, e);                &#125;            &#125;        &#125;);        let worker = Worker::new(index, handle);        self.threads.push(worker);        index    &#125;    // 停止所有工作线程，向所有工作线程发送停止标志    fn stop(&amp;self, transmitter: &amp;Sender&lt;TaskSign&gt;) -&gt; () &#123;        for _ in 0..self.threads.len() &#123;            transmitter.send(TaskSign::End).unwrap();        &#125;    &#125;&#125;pub fn main() &#123;    // 工作线程池    let mut worker_thread_pool = WorkerThreads::new();    let (send_tx, send_rx) = mpsc::channel::&lt;TaskSign&gt;();    let shared_rx = Arc::new(Mutex::new(send_rx));    for _ in 0..4 &#123;        // create worker threads        worker_thread_pool.add_worker(Arc::clone(&amp;shared_rx));    &#125;    for i in 0..10 &#123;        let id = i + 1;        if id == 6 &#123;            WorkerThreads::stop(&amp;worker_thread_pool, &amp;send_tx);            println!(&quot;🎯 Main thread has sended end signal on task &#123;&#125;.&quot;, id);        &#125; else &#123;            let task = Task::new(id);            send_tx.send(TaskSign::Task(task)).unwrap();            println!(&quot;🧱 Main thread has sended task &#123;&#125;.&quot;, id);        &#125;    &#125;    for worker in worker_thread_pool.threads &#123;        worker.handle.join().unwrap();    &#125;    println!(&quot;✅ All tasks are finished !!&quot;);&#125;\n\n\n\n重点实现分析：\n\n创建了一个工作线程池结构体，来管理子线程的创建和停止，停止意味着向所有子线程发送停止信号。\n子线程负责持续向 receiver 查询任务，当子线程接收到停止信号时，则终结循环。\n收集所有子线程返回的 joinHandle，分别调用 join() 方法以阻塞主线程，等待子线程的执行。\n优雅停止的秘诀：在子线程的loop循环中判断是否还能接续接收任务，若不行则跳出循环，不再接收新任务。\n\n练习3\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115use std::&#123;    sync::&#123;        mpsc::&#123;self&#125;,        Arc, Mutex,    &#125;,    thread::&#123;sleep, spawn, JoinHandle&#125;,    time::Duration,&#125;;type TaskBody = Box&lt;dyn Fn() -&gt; String + Send + Sync&gt;;struct Task &#123;    id: i32,    body: TaskBody,&#125;impl Task &#123;    fn new(id: i32, body: TaskBody) -&gt; Self &#123;        Task &#123; id, body &#125;    &#125;&#125;struct Scheduler &#123;    threads_num: usize,    task_queue: Arc&lt;Mutex&lt;Vec&lt;Task&gt;&gt;&gt;,    // JoinHandle&lt;T&gt;，T为线程返回值类型    // worker_threads: Vec&lt;JoinHandle&lt;()&gt;&gt;,&#125;impl Scheduler &#123;    fn new(size: usize) -&gt; Self &#123;        Scheduler &#123;            threads_num: size,            task_queue: Arc::new(Mutex::new(vec![])),            // worker_threads: vec![],        &#125;    &#125;    // 向调度器添加任务：插入任务队列，等待被执行    fn add(&amp;mut self, task: Task) &#123;        let cloned_task_queue = Arc::clone(&amp;self.task_queue);        let mut task_queue = cloned_task_queue.lock().unwrap();        task_queue.push(task);    &#125;    // 开启调度：创建出多个线程，进行任务分发工作    // 任务分发：将任务队列中的任务分到多个线程中执行，    // 线程内每次任务执行完成后，都将结果通过channel发送给接收方    // 结果收集：如何判断所有线程执行完毕？    // a1：收集 JoinHandle，手动调用 xx.join()    // 每个线程回返回一个 JoinHandle 结构体，推入线程池 worker_threads    // 调度器等待 worker_threads 所有任务执行完毕，调用 receiver 拿到所有结果并打印    // a2: 持续调用 rx.recv()    // 该方法会阻塞主线程，反正每次调用结果都会发送给rx，那么直接持续调用rx.recv()即可    fn schedule(&amp;self) &#123;        let (tx, rx) = mpsc::channel();        // 创建多个线程：每次同时启用4个线程工作        for thread_id in 1..=self.threads_num &#123;            let cloned_task_queue = Arc::clone(&amp;self.task_queue);            // 克隆发送方的原因是因为move关键字会将使用到的transmitter所有权转移到线程内部，后续无法使用            // 所以每次需要克隆一个发送方给【当前次】逻辑使用            let cloned_transmitter = tx.clone();            // println!(&quot;Created thread &#123;thread_id&#125; ...&quot;);            spawn(move || loop &#123;                if cloned_task_queue.lock().unwrap().is_empty() &#123;                    println!(&quot;Task queue is empty.&quot;);                    // 停止调度                    break;                &#125;                // 这里有个问题，我们需要在多个工作线程中访问&quot;任务队列&quot;，所以它必须是线程安全的&amp;&amp;可以共享的                let task = &#123;                    let mut task_queue = cloned_task_queue.try_lock().unwrap();                    task_queue.remove(0)                &#125;;                // 还有待执行的任务                println!(&quot;Thread &#123;&#125; start to execute task &#123;&#125;&quot;, thread_id, task.id);                // 线程内每次任务执行完成后，都将结果通过channel发送给接收方                cloned_transmitter.send((task.body)()).unwrap();            &#125;);            // 将线程返回的JoinHandle推入线程池            // self.worker_threads.push(handle);        &#125;        // 手动释放发送方，不阻塞主线程        drop(tx);        // 获取结果：在所有任务完成后，收集并打印每个任务的执行结果        // 这里需要写一个监听，当任务都完成后自动打印执行结果        // 这里可以使用 while 一直调用 recv 阻塞        while let Ok(task_result) = rx.recv() &#123;            println!(&quot;Task is completed, &#123;&#125;&quot;, task_result);        &#125;    &#125;&#125;pub fn main() &#123;    let mut scheduler = Scheduler::new(4);    // 向调度器添加任务    for id in 1..=10 &#123;        let task = Task::new(            id,            Box::new(move || &#123;                // println!(&quot;I&#x27;m task &#123;id&#125;, executing...&quot;);                // 🌟 模拟任务耗时导致线程占用/忙碌：以此触发调用其他线程工作                sleep(Duration::from_secs(1));                String::from(format!(&quot;task_id=&#123;id&#125;&quot;))            &#125;),        );        scheduler.add(task);    &#125;    scheduler.schedule();&#125;\n\n","slug":"concurrency","date":"2025-01-28T13:38:22.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"acc0e87b34830b962966d84f538705e6","title":"Rust Test","content":"Unit Test单元测试\n1234567891011121314151617181920212223242526272829303132333435363738394041pub fn add(left: u64, right: u64) -&gt; u64 &#123;    left + right&#125;#[cfg(test)]mod tests &#123;    // 导入当前包所有的内容    use super::*;    #[test] // 属性宏：表示这是一个单元测试    fn it_works() &#123;        let result = add(2, 2);        assert_eq!(result, 4, &quot;result is &#123;&#125;&quot;, result);    &#125;    #[test]    fn feature_sum2() &#123;        let result = add(2, 2);        assert_eq!(result, 4, &quot;✨✨✨ result is &#123;&#125;&quot;, result);    &#125;    #[test]    fn feature() -&gt; Result&lt;(), ()&gt; &#123;        Err(())    &#125;    #[test]    // 📌 显式的标记下面的单测是会发生panic的，panic不会影响单测通过    // expected设置期待的panic message，若不匹配则单测失败    #[should_panic(expected = &quot;error2&quot;)]    fn test_todo() &#123;        panic!(&quot;error2&quot;);    &#125;    #[test]    #[ignore] // 显式的忽略某个单元测试    fn test_3() &#123;        unimplemented!();    &#125;&#125;\n\n\n\nIntegration Test集成测试\n在与 src 目录同级下创建 tests 目录，存放集成测试（integration test）的文件。test 目录下的每一个文件都会被编译成一个单独的 crate，crate 名就是文件名。运行命令 cargo test 会执行当前 package 下所有的单元测试和集成测试。\ncargo testcargo test --test [TEST_CRATE_NAME] 用于执行单个集成测试文件。\ncargo test [TESTNAME] 用于执行某个单元测试（提供函数名）。\ncargo test -- --ignored 用于执行所有标记 ignore 的单元测试。\ncargo test --doc 用于执行所有文档测试。\ncargo test --examples [TESTNAME] 用于执行所有&#x2F;指定 Examples 测试。\n在集成测试目录下，如果需要抽公共模块，需要单独再建一个目录如 common，在新建目录下创建文件。\nDoc Tests文档测试\n/// 为函数标注文档测试的注释。\n123456789101112/// Add to number/// # Examples/// ```rust/// assert_eq!(rust_lib::add(1,1),2)/// ```/// # Panic/// # Errorspub fn add(left: u64, right: u64) -&gt; u64 &#123;    left + right&#125;// rust_lib 为当前 cargo 配置文件下的 package name，需要把 “-” 转换成 “_”\n\n\n\n//! 为模块标注文档测试的注释，模块注释只能写在文件头部。通常是用来写模块说明的\n12345678910//! #utils//! A module helper you//! ```rust//! assert_eq!(rust_lib::utils::sum(1,1),2)//! ```pub mod utils &#123;    pub fn sum(a: u8, b: u8) -&gt; u8 &#123;        a + b    &#125;&#125;\n\n\n\n\n\nBenches [unstable __ TODO]基准测试（性能测试）**unstable **状态\nExamples当我们需要为当前 rust 代码提供一些 demo 时，可以与 src 同级创建 examples 目录，下面可以放多个 demo 文件，每个文件里可以提供一些自己的单元测试代码。\n12345678910111213141516171819// examples/a.rsuse rust_lib::add;fn main() &#123;    let sum = add(1, 1);    assert_eq!(sum, 2);&#125;#[test]fn feature_a() &#123;    //&#125;#[test]fn feature_b() &#123;    //&#125;\n\n\n\ncargo test --examples a 用于执行 a 文件下的所有单元测试。\ncargo test --examples feature_a 用于执行 examples 目录下最后一个名为 feature_a 的单元测试。\n#[cfg(test)]属性宏，用于告诉编译器这部分代码是测试代码，测试代码是只有运行 cargo test 才会被执行的代码，cargo build 时不会执行。\nEngineering Spec 工程规范\n练习\n配置 github\n\n\n\n\n\n\n\n\nGithub Actions 参考:  https://docs.github.com/en/actions/writing-workflows/using-workflow-templates\n在 github 上新建一个仓库，将本地仓库与之关联，点击 Actions 选择一个模板，按照 publish crate 步骤对模板进行修改。\nPuiblishing on crates.ioBefore your first publish: Need Login!!\n需要登录才能够发布到官方市场。我们这里用 Github Actions 自动发布的话，就需要去 crates.io 上拿一个 token（登录凭证）存到 github 仓库的 settings 中，然后在 ci 脚本里可以使用。\ncrates.io 首次用 github 登录后，会自动往对应邮箱发送验证邮件，只有通过邮箱校验才能用脚本进行发布。验证完成后 https://crates.io/settings/tokens 在这个页面生成 token。\n\n将生成的 token 复制，再到 Github 仓库下 &gt; Settings &gt; Secrets and variables &gt; Actions 选择 New repository secret，将 token 存入。\n\n\n这里填写的 secrets name 就是之后在 ci 文件里会用到的变量名。\nPublish a crate\n\n\n\n\n\n\n\n\n文档参考：https://doc.rust-lang.org/cargo/reference/publishing.html#packaging-a-crate\nKeep in mind: \ncrate 名在市场上不能重复，已经存在的包名发布会失败。包名指的是 Cargo.toml 配置文件中设置的 package name。\nMake sure you have filled the following fields:\n\n补充相关字段，创建 README.md\n12345678910111213// Cargo.toml[package]name = &quot;publish-crate-with-github-actions-demo&quot;version = &quot;0.1.0&quot;edition = &quot;2021&quot;license = &quot;MIT&quot;description = &quot;This package is used for test publish a crate with github actions&quot;homepage = &quot;https://marniewu.github.io/post/rust-test&quot;repository = &quot;https://github.com/MarnieWu/publish-crate-demo&quot;readme = &quot;README.md&quot;[dependencies]\n\n123// README.md# Publish a crate with Github Actions\n\n\n\nPackaging a crate打包\ncargo publish 包含以下步骤：\n\n对你的 package 进行一些校验检查。\n压缩你的源代码为一个 .crate 文件。\n提取 .crate 文件到一个二进制目录下并验证它是否可以编译。\n上传 .crate 文件至 crate.io。\n在添加之前，注册表会对上传的包做一些额外的检查。\n\n注册表：指的是平台提供的一个可被下载的包的清单 list，它维护了所有平台上可用的包以及它们的版本、依赖和描述等等信息。\n运行 cargo publish --dry-run  在发布前检查是否存在 warnings 和 errors，如果有配置 Cargo 镜像的需要注释掉用官方的源才能发布。\n\n按提示应该是文件未提交，我们先提交下并同步到 github。再次运行，通过检查 ✅。\n下面我们把命令行配置到 ci 文件中，让它通过 Github Actions 的 CI 结合，进行自动发布。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445# This is a basic workflow to help you get started with Actionsname: PUBLISHING ON crates.io# Controls when the workflow will runon:  # Triggers the workflow on push or pull request events but only for the &quot;main&quot; branch  push:    branches: [&quot;main&quot;]  pull_request:    branches: [&quot;main&quot;]  # Allows you to run this workflow manually from the Actions tab  workflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:  # This workflow contains a single job called &quot;publish&quot;  publish:    name: Publish    # The type of runner that the job will run on    runs-on: ubuntu-latest    env:      # ✨ 这里是我们前面在仓库设置的 token      CRATES_TOKEN: $&#123;&#123; secrets.CRATES_TOKEN &#125;&#125;      RUST_CHANNEL: &quot;stable&quot;    # Steps represent a sequence of tasks that will be executed as part of the job    steps:      - uses: actions/checkout@v4      # Install Rust toolchain      - name: Install Rust toolchain        run: |          rustup update --no-self-update $&#123;&#123; env.RUST_CHANNEL &#125;&#125;          rustup component add --toolchain $&#123;&#123; env.RUST_CHANNEL &#125;&#125; rustfmt rust-src          rustup default $&#123;&#123; env.RUST_CHANNEL &#125;&#125;      # Before publishing check warnings and errors      - name: Publishing check        run: cargo publish --dry-run      # Publish to crates.io      - name: Publish to crates.io        run: cargo publish --token $&#123;CRATES_TOKEN&#125;\n\n\n这就是没有校验邮箱会报的错误，验证后手动 re-run ci。\n\nci 成功，我们去 crates.io 上查找一下有没有对应的包，搜索 package_name 包名。\n\n\n成功搜到，完成 ✅\n（TODO：后续还可以按需加上 version bumping, git tagging 等功能）\n","slug":"rust-test","date":"2025-01-27T02:12:05.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"dffe4aa96c5d22cd6989d498cd57fa66","title":"迭代器 Iterators","content":"What are iterators?迭代器是 Rust 中用来处理集合的方式，允许遍历和操作序列值。\nIterator TraitIterator Trait 会提供 next() 方法，用于返回用 Option 包裹的序列的下一个 item，直到没有元素可以返回了，即返回 None。Trait 内部设置了关联类型，实现时声明具体类型。\n1234trait Iterator &#123;  type Item;  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;&#125;\n\n\n\nLaziness 惰性的迭代器分为创建和消费两部分\n1234let numbers = vec![1, 2, 3, 4, 5];// 这既是创建了一个迭代器let nums_iter = numbers.iter();\n\n\n\n迭代器是懒惰的，在没有消费迭代器之前，不会产生任何的消耗，即创建语句并不会真实被执行。\n1234// 下面是创建了一个迭代器let nums_iter = numbers.iter();// 下面是消费了一个迭代器let nums: Vec&lt;_&gt; = nums_iter.collect();\n\n\n\nTypes of Iterators迭代器分为三种类型：\n\n迭代器本身：实现了 Iterator Trait 的迭代器都被称为普通迭代器，它们能使用 next() 方法对序列遍历直到返回 None 。\n迭代器适配器：会创建并返回一个新的迭代器的方法，被称为迭代器适配器。如 map、filter、take 等。\n消耗适配器：将一个迭代器转换成集合并返回的方法，被称为消耗适配器。如 collect、sum、fold 等。\n\nAssociated Methods常用的创建迭代器的三种方法\niter()：创建一个借用集合中每个元素的迭代器，原集合可以继续使用1234let vec = vec![1, 2, 3];for item in vec.iter() &#123;    println!(&quot;&#123;&#125;&quot;, item);&#125;\n\n\n\ninto_inter()：创建会转移集合中每个元素所有权的迭代器，原集合不能再继续使用1234let vec = vec![1, 2, 3];for item in vec.into_iter() &#123;    println!(&quot;&#123;&#125;&quot;, item);&#125;\n\n\n\niter_mut()：创建一个可变借用每个元素的，迭代过程中每个元素都支持修改，原集合可以继续使用1234let mut vec = vec![1, 2, 3];for item in vec.iter_mut() &#123;    *item += 1; // Increment each element&#125;\n\n\n\nExampleswhile loop1234567let my_vec = vec![1, 2, 3, 4, 5];let mut my_iter = my_vec.iter();// while loopwhile let Some(next) = my_iter.next() &#123;  println!(&quot;&#123;&#125;&quot;, next);&#125;\n\n当使用  while loop 时，因为每次都是外部调用的 .next() 控制迭代器的遍历，所以需要将 iterator 声明成可变的，才能操作内部状态。\nfor...in1234567let my_vec = vec![1, 2, 3, 4, 5];let my_iter = my_vec.iter();// for loopfor v in my_iter &#123;  println!(&quot;&#123;&#125;&quot;, v);&#125;\n\nfor...in  遍历迭代器是由循环内部控制的迭代器状态，所以无需外部的可变声明。\n练习\n1234567891011121314151617181920212223242526272829303132333435363738394041424344fn main() &#123;    let fib = Fibonacci::new();    let first_ten: Vec&lt;u32&gt; = fib.take(10).collect();    println!(&quot;First 10 Fibonacci numbers: &#123;:?&#125;&quot;, first_ten);&#125;#[derive(Debug)]struct Fibonacci &#123;    prev: u32,    curr: u32,&#125;/** * 实现一个结构体 Fibonacci，并为它实现 Iterator trait。 * 在 next 方法中生成下一个斐波那契数。 * 编写一个测试函数，输出前 10 个斐波那契数。 * take 方法是一个迭代适配器，用于限制生成的数量。 */impl Fibonacci &#123;    fn new() -&gt; Fibonacci &#123;        Fibonacci &#123; curr: 0, prev: 0 &#125;    &#125;&#125;impl Iterator for Fibonacci &#123;    type Item = u32;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;        if self.prev == 0 &amp;&amp; self.curr == 0 &#123;            // first one number            self.curr = 1;        &#125; else if self.prev == 0 &amp;&amp; self.curr == 1 &#123;            // first two number            self.prev = 1;        &#125; else &#123;            // normally            let prev = self.prev;            self.prev = self.curr;            self.curr += prev;        &#125;        Some(self.curr)    &#125;&#125;\n\n","slug":"iterators","date":"2025-01-21T10:15:44.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"eb08d875d225f31121fe8b5a6e855210","title":"项目和包 Packages and Crates","content":"TODO …","slug":"packages_and_crates","date":"2025-01-20T06:25:41.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"b174df949a1c3f84910009414c4b737f","title":"npm_and_pnpm","content":"TODO …","slug":"npm-and-pnpm","date":"2025-01-17T16:47:09.000Z","categories_index":"","tags_index":"","author_index":"Marnie"},{"id":"0e16d47ce0f8c7e02c11662ec70d0b06","title":"闭包 Closures","content":"What are Closures?Rust 中的闭包本质是一个匿名函数，它有三个特点：\n\n可以被存储在变量中\n可以当做参数传给某个函数\n可以当做某个函数的返回值\n\n这都是普通函数不能做到的，一会儿我们可以写一个对比的例子，先来看下闭包的语法和使用。\nClosure Syntax1|parameters| body\n\n\nParameters：参数需要用竖线包裹，可以为空 ||\nBody：闭包主体，默认需要用 &#123;&#125; 包裹 |...| &#123; ... &#125;，如果只有一句表达式（expression），可以省略括号 |...| println!(&quot;test&quot;)\n\nExamplesSimple Closure123let add = |a: i32, b: i32| -&gt; i32 &#123; a + b &#125;;let result = add(2, 3);println!(&quot;The sum is &#123;&#125;.&quot;, result); // Output: The sum is 5.\n\n简单的闭包就和普通函数表现一致，我们定义时也可以不声明类型，按照第一个调用的闭包会产生自动的类型推断。\nNo Parameters, one line body12let greet = || println!(&quot;Hello, world!&quot;);greet(); // Outputs: Hello, world!\n\n\n\nCapturing Variables12345let x = 10;let add_to_x = |y: i32| -&gt; i32 &#123; y + x &#125;;let result = add_to_x(5);println!(&quot;The result of adding 5 to &#123;&#125; is: &#123;&#125;&quot;, x, result); // Outputs: The result of adding 5 to 10 is: 15\n\n\n\nMulti Lines1234567let squared_sum = |x: i32, y: i32| -&gt; i32 &#123;  \tlet sum = x * y;  \tsum * sum&#125;;let result = squared_sum(2, 3);println!(&quot;Result = &#123;&#125;&quot;, result); // Outputs: Result = 64\n\n\n\nCompared to standard functionsDon’t have to sepcify data types of the closure’s arguments可以不定义闭包的参数类型，它会根据实际调用（invoke）传入的参数类型进行类型推断（data type infering）。\nAs same as, the returning type also can be empty, complier will infer the data type through its invoking.同样的，返回类型也可以不定义，编译器会通过其调用推断数据类型。\nCapturing Variables闭包和函数还有一个大差异 —— 闭包可以访问其所在作用域内的变量。Standard functions can not access the varibales which are defined out of this function.\n12345678910pub fn test_closures() &#123;    let add = |x: i32, y: i32| x + y;    let number = 5;    fn test_standard_function() &#123;        println!(&quot;&#123;&#125;&quot;, number); // ❌ get error    &#125;    add(number, 10);&#125;\n\n\n而闭包不同于标准函数，它提供了 inherit（继承）的能力，在闭包内可以访问父级作用域（parent scope）用内定义的变量，这也被称为变量捕获（capturing variables），捕获有三种形式：\n\n引用捕获（默认）：闭包对变量进行借用\n可变引用捕获：闭包对变量进行可变的借用\n按值：上两种都是对变量的借用，如果想直接拥有数据的所有权，需要使用 move 关键字转移所有权，所有权转移后的变量不能再后续被使用\n\nExamplesCapturing By Reference（Default)12345let x = 10;let add_to_x = |y: i32| -&gt; i32 &#123; y + x &#125;;let result = add_to_x(5);println!(&quot;The result of adding 5 to &#123;&#125; is: &#123;&#125;&quot;, x, result); // Outputs: The result of adding 5 to 10 is: 15\n\n\n\nCapturing By Mutable Reference可变借用的前提是被借用的变量也得是 mutable 的，闭包也定义成 mutable\n12345678let mut x = 10;let mut add_to_x = |y: i32| -&gt; i32 &#123;  \tx += 5; // mutation  \tx + y&#125;;let result = add_to_x(5);println!(&quot;x = &#123;&#125;&quot;, x); // Outputs: x = 15\n\n\n\nCapturing By Value（move）对于实现了 Copy trait 的数据类型变量的移动和赋值都不会发生所有权转移，是值的复制。所以测试 move 需要使用没有实现 Copy trait 的数据类型\n1234let x = String::from(&quot;Test&quot;); // no implements Copy traitlet foo = move || println!(&quot;&#123;&#125; is moved&quot;, x);foo();println!(&quot;&#123;&#125;&quot;, x);\n\n\nmove 了什么东西？使用 move 闭包的目的是为了将闭包内捕获的变量的值的所有权转移到闭包内部，需要转移所有权的原因是因为在不同作用域内定义的变量有着不同的生命周期，若是再更长的生命周期内借用了短生命周期的变量，会导致报错，为了避免错误我们就可以使用 move 闭包直接将所有权转移到闭包内，一经转移外部则不能再使用。\nTypes of the closures闭包适用的场景一般是当做 callback functions 或者用于 iterators 中，在将闭包作为参数时我们需要定义闭包的类型。按照“你使用闭包需要干什么”可以将闭包的类型分为三种，it’s matched the three ways of 👆🏻Capturing Varibales.\nFn（Reference capturing）普通闭包，可以调用一次或多次，但不修改变量\n\nFnMut（Mutable reference capturing）你会在闭包内修改一个定义在闭包外部的变量，可以调用一次或多次，就用 FnMut\n123456789101112131415struct Person &#123;  first_name: String,  last_name: String,&#125;fn main() &#123;  let mut p1 = Person &#123;    first_name: &quot;Wu&quot;.to_string(),    last_name: &quot;Marnie&quot;.to_string(),  &#125;;  // ✨ 如果你需要在闭包中修改某个外部变量，那么这个闭包也需要定义成 mutable  let mut change_name = |new_last_name: &amp;str| p1.last_name = new_last_name.to_string();  change_name(&quot;Marnieeee&quot;);  println!(&quot;After changed: &#123;&#125;&quot;, p1.last_name);&#125;\n\n\n\n如上是正确输出，我们现在修改下例子，我们再调用一次 change_name 会发现有如下报错：\n\ncannot borrow p1.last_name as immutable because it is also borrowed\n这是使用闭包时需要遵守的一个规则，因为我们上文说过，闭包有权捕获其环境内的变量，所以编译器如果发现还存在闭包调用，相当于闭包还存在对某个变量的借用，那在最后一个闭包调用结束前，这个被借用的变量都不能被其他地方借用。\n我们可以将闭包的操作放一起，最后进行输出就遵循了规则：\n\n\nFnOnce只能调用一次的闭包，这个类型和 FnMut 的区别在于调用次数，它们都可以在内部修改变量，但 FnOnce 只允许调用一次，这个类型一般是结合我们上面提到的 move 转移所有权的场景，因为被闭包捕获的变量的所有权，随着闭包的执行被转移了，在闭包调用后不可被访问，而所有权也就只能被转移一次，所以需要转移所有权的闭包需要定义为 FnOnce。\n练习\n\n\n\nnew初始化方法，将传入的回调函数（即闭包）存入结构体以后调用，并初始化各字段\nget_page接收 user_id 和 article_id，调用 is_rendered_page 判断是否存在过\n\n若存在：返回存下来的 page_content\n若不存在：调用 fetch_query 渲染，并更新 page_content\n\nis_rendered_page比较存下来的 user_id + article_id 和 当前请求的是否一致\nrender_page调用初始化的闭包，传入 user_id 和 article_id，得到 page_content，并更新所有字段\n完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576pub fn home_work() &#123;    let mut page_cache = PageCache::new(|user_id: &amp;str, article_id: u32| -&gt; String &#123;        println!(            &quot;Rendering page for user &#123;&#125; and article &#123;&#125;&quot;,            user_id, article_id        );        format!(            &quot;Rendered HTML for user &#123;&#125; and article &#123;&#125;&quot;,            user_id, article_id        )    &#125;);    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user1&quot;, 42));    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user1&quot;, 42));    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user2&quot;, 42));&#125;// 需要使用“比较”功能，派生“比较”特征#[derive(PartialEq)]struct PageCache&lt;T&gt;where    T: Fn(&amp;str, u32) -&gt; String,&#123;    fetch_page: T,    value: Option&lt;String&gt;,    user_id: Option&lt;String&gt;,    article_id: Option&lt;u32&gt;,&#125;/** * 闭包能干什么？ * 1. as callback function * 2. capturing surrounding variables (important!!) */impl&lt;T&gt; PageCache&lt;T&gt;where    T: Fn(&amp;str, u32) -&gt; String,&#123;    fn new(fetch_page: T) -&gt; PageCache&lt;T&gt; &#123;        // 初始化时，先将传入的闭包存下来当做 fetch_page 方法        // 闭包接收 user_id and article_id, 返回 page_content        PageCache &#123;            fetch_page,            value: None,            article_id: None,            user_id: None,        &#125;    &#125;    fn is_rendered_page(&amp;self, user_id: &amp;str, article_id: u32) -&gt; bool &#123;        self.article_id.is_some_and(|id| id == article_id)            &amp;&amp; self.user_id.as_deref().is_some_and(|id| id == user_id)    &#125;    fn render_page(&amp;mut self, user_id: &amp;str, article_id: u32) &#123;        self.user_id = Some(user_id.to_string());        self.article_id = Some(article_id);        // self.fetch_page 是一个闭包 即一个 function        let page_content = (self.fetch_page)(user_id, article_id);        // println!(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, user_id, article_id, page_content);        self.value = Some(page_content);    &#125;    fn get_page(&amp;mut self, user_id: &amp;str, article_id: u32) -&gt; String &#123;        if !self.is_rendered_page(user_id, article_id) &#123;            self.render_page(user_id, article_id);        &#125;        // unwrap 获取 Option 的 inner value，但是会转移所有权        // self 是 mutable 的，mutable 结构体内部的 fields 不允许转移所有权        // 所以先 as_ref() 变成普通借用后调用 unwrap，此时 借用的变量调用 unwrap 返回的还是个借用的值        // 因此再用 clone() 将值复制返回        self.value.as_ref().unwrap().clone()    &#125;&#125;\n\n\n\n\n","slug":"closures","date":"2025-01-16T12:15:31.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"764bca6314ff5edd2be26b3adc313bc1","title":"宏 Marcos","content":"Declarative macrosWhat is macro_rules!?macro_rules! 用于定义声明式宏（declarative macros），它主要包含两个部分 —— 模式 + 拓展的代码\n模式指的是，它允许定义指定的标识（token），当调用者输入了与指定标识相匹配的内容，则命中该模式。\n每个模式允许定义与之匹配的可执行代码，这被称为拓展的代码，当模式被命中之后则会执行其拓展的代码。\n这是 macro_rules! 的工作模式，使用上类似于 match 匹配的多分支。\nmacro_rules!‘s Syntax1234567891011// 注释负责导出#[macro_export]macro_rules! macro_name &#123;  \t// pattern 模式 expansion 拓展的代码  \t(pattern) =&gt; &#123; expansion; &#125;;&#125;// 调用的三种方式macro_name!();macro_name![];macro_name!&#123;&#125;;\n\n\nmarco_export: 使用该注释将宏导出，只有被导出的宏才能被当前作用域使用或是引入其他作用域使用；\nmacro_name：宏的名字，调用时加感叹号调用 macro_name! ;\npattern: 定义需要匹配的输入的结构；\nexpansion：定义匹配后需要的代码；\n\nPattern matching上面说了 pattern 指的是定义指定的 token（标识）让输入（input）去匹配：\n1234567891011#[macro_export]macro_rules! greet &#123;    ($name:expr) =&gt; &#123;      println!(&quot;Hello, &#123;&#125;!&quot;, $name);    &#125;;&#125;fn main() &#123;    greet!(&quot;Mark&quot;);    greet!(&quot;Film&quot;);&#125;\n\n模式中使用 $xxx:expr 这样的语法来定义，expr 可以匹配任何 Rust 表达式，除了这个 macro 中还提供了多个可以使用的 token 我们可以了解下，具体需要用到的时候再查就是了。\nToken types\nexpr: Matches any valid Rust expression. This includes literals, variables, function calls, and more.\nstmt: Matches a statement, which can be a full statement like an assignment or a control flow statement (e.g., if, for, etc.).\npat: Matches a pattern, which is used in pattern matching (e.g., in match statements).\nty: Matches a type, such as i32, String, or any user-defined type.\nident: Matches an identifier, which is typically a variable name or function name.\npath: Matches a path, which can be a simple identifier like foo, or fully qualified paths like std::mem::replace.\nmeta: Matches meta items, which are used in attributes (e.g., #[derive(Debug)]).\ntt: Stands for “token tree” and matches any sequence of tokens. This is the most flexible option and can match anything from expressions to types to identifiers.\nvis: Matches visibility qualifiers (e.g., pub, private, etc.), which control the visibility of items.\n\n除了指定 token 之外，宏的参数还是可变参数（与函数不一样），我们可以写对应的或者是多个匹配来实现参数的可变。\n多个匹配：123456789101112131415161718fn main() &#123;    greet!();    greet!(&quot;Mark&quot;);    greet!(&quot;Film&quot;);&#125;#[macro_export]macro_rules! greet &#123;    // 入参空    () =&gt; &#123;        println!(&quot;Hello, world!&quot;);    &#125;;    // 入参非空    ($name:expr) =&gt; &#123;        println!(&quot;Hello, &#123;&#125;!&quot;, $name);    &#125;;&#125;\n\n\n可重复（repetition）参数模式：123456789101112131415161718192021#[macro_export]macro_rules! create_vec &#123;    ($($value:expr),*) =&gt; &#123;        &#123;            println!(&quot;外层 --- start&quot;);            let mut vec = Vec::new();            $(&#123;                println!(&quot;&#123;&#125;&quot;,$value);                vec.push($value);                println!(&quot;每次匹配到的输入都会执行&quot;);            &#125;)*            println!(&quot;外层 --- end&quot;);            vec        &#125;    &#125;;&#125;fn main() &#123;    let my_vec = create_vec![1, 2, 3];&#125;\n\n$($value:expr), * 中  * 表示 zero or more 可以匹配0或多次，还可以是 + at least one 至少匹配一次，? zero or one 零次或1次。\n注意上面的代码，可以看到 expansion  的部分我们有两个大括号，那是因为宏的概念本身是为了让我们定义对指定输入的固定行为，也就是 expansion，因为输入和输出都是固定的，所以在编译期间就会将宏调用替换成匹配到的 expansion。\n对于 expansion ，由于不同的宏调用上下文，比如它在一个赋值语句中被调用 let a = macro_name!(); ，那 expansion 的执行结果它一定是一个值，一个值意味着它可能是一个表达式（expression）或一段包含多个语句（statement）且有返回值的代码块（code block）。如果是一个独立的宏调用 macro_name!();，那么 expansion 就可以是一个单独的语句，这就是不同上下文对 expansion 的限制。\n语句（statements）指的是一切代表某个操作行为的代码句子，可能是赋值、执行等等，其中有返回值的语句被称为表达式（expression），比如 a + b / add(1, 2) ，而用大括号包裹的1至多组语句被称为代码块（code block）。\n再说回上面代码示例，如果  expansion 是代码块就需要再套上一层大括号，其中可以用 $(...)* 语法糖包裹每次匹配到符合指定条件的输入 （$value） 时需要执行的语句，它会被替换成等价的配有不同输入的多个语句：\n123456789// 比如： create_vec![1, 2, 3]// 替换前：$(println!(&quot;&#123;&#125;&quot;, $value))*// 替换后：println!(&quot;&#123;&#125;&quot;, 1);println!(&quot;&#123;&#125;&quot;, 2);println!(&quot;&#123;&#125;&quot;, 3);\n\n\n\n编译期间替换代码\n\n\n\n\n\n\n\n\n再提一下\n宏之所以好用是因为它在运行时不会产生损耗，因为声明宏使用的匹配模式是定义后就固定了的，编译期间就能将每个宏调用等价替换成命中匹配后的拓展代码。这里说的不会产生运行时的损耗，说白了就是代码在执行期间并不会因为逻辑而发生变化，没有会变的逻辑。\nProcedural macros派生宏、属性宏、函数宏\n派生宏我们常用的 derive 后使用的 crate 就是派生宏。\n注释：#[proc_macro_derive]\n函数宏注释：#[proc_macro]\n常用函数宏：\n12345678910111213141516171819202122232425#[test]fn macro_fn() &#123;    // 读取文件内容    let file_content = include_str!(&quot;../Cargo.toml&quot;);    // 获取环境路径    let env_path = env!(&quot;PATH&quot;);    // 拼接字符串    let str = concat!(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);    // 条件编译    if cfg!(target_os = &quot;mac&quot;) &#123;        //    &#125;    panic!(&quot;manually panic!&quot;);    println!(&quot;111&quot;);&#125;#[test]fn echo() &#123;    // 以后实现的代码    todo!();    unimplemented!();&#125;\n\n\n\n属性宏注释：#[proc_macro_attribute]\n编译期间计算和生成代码派生宏用于处理比声明宏给为复杂的业务，每个过程宏都必须有一个单独的 crate，被当做插件一样在别的 crate 中使用。所以过程宏和声明宏一样，都是编译期间计算和生成对应的代码并将调用的地方替换，并无运行时损耗。\n练习\n先定义三个声明宏的壳子：1234567891011121314151617181920fn main() &#123;    assert_eq!(repeat!(&quot;x&quot;, 3), &quot;xxx&quot;);    assert_eq!(sum!(1, 2, 3, 4, 5), 15);    assert_eq!(max_value!(1, 8, 9), 9);&#125;#[macro_export]macro_rules! repeat &#123;    ($value:expr) =&gt; &#123;&#125;;&#125;#[macro_export]macro_rules! sum &#123;    ($value:expr) =&gt; &#123;&#125;;&#125;#[macro_export]macro_rules! max_value &#123;    ($value:expr) =&gt; &#123;&#125;;&#125;\n\n\n\n分析并实现宏：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * repeat!(&quot;x&quot;, 3) * 第一个入参：字符或字符串 C * 第二个入参：数字 N * 返回：将 C 重复 N 次拼接 */#[macro_export]macro_rules! repeat &#123;    ($str:expr,$num:expr) =&gt; &#123;&#123;        let mut s = String::from(&quot;&quot;);        for _ in 0..$num &#123;            s.push_str($str);        &#125;        s    &#125;&#125;;&#125;/** * sum!(1, 2, 3, 4, 5) * 入参：不固定数量的数字 * 返回：这些数字的和 */#[macro_export]macro_rules! sum &#123;    ($($value:expr),*) =&gt; &#123;&#123;        let mut v = 0;        $(v=v+$value;)*        v    &#125;&#125;;&#125;/** * max_value!(1, 8, 9) * 入参：不固定数量的数字 * 返回：入参中最大的数字 */#[macro_export]macro_rules! max_value &#123;    ($($value:expr),*) =&gt; &#123;&#123;        let mut max = 0;        $(max=if $value&gt;max &#123;$value&#125; else &#123;max&#125;;)*        max    &#125;&#125;;&#125;\n\n","slug":"marcos","date":"2025-01-13T14:29:24.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"bf66738dcbdc4a39018dfff1579fc70a","title":"特征 Trait","content":"孤儿规则impl T for A : 为 A 实现特征 T , 那么 A 或者 T 至少有一个是在当前作用域中定义的。\n1234fn main &#123;  // ❌ Clone 和 String 都是标准库中定义的，而不是当前 crate 中定义的，无法使用 impl 关键字  impl Clone for String &#123;&#125;&#125;\n\n\n签名 signature 和重载 overridetrait 中，可以只定义签名，也可以定义方法的默认行为。在具体实现中定义的方法会重载特征中默认的方法。\n当我们在调用某个方法时，会先找自身结构体中是否有对应实现，若没有则向上🔼找特征中的该方法。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Post 结构体struct Post &#123;    name: String,    author: String,&#125;// Weibo 结构体struct Weibo &#123;    username: String,    content: String,&#125;// Summary 特征trait Summary &#123;    fn summarize_author(&amp;self) -&gt; String;    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;Read more from &#123;&#125;...&quot;, self.summarize_author())    &#125;&#125;// 为 Post 实现 Summary 特征impl Summary for Post &#123;    fn summarize_author(&amp;self) -&gt; String &#123;        self.author.clone()    &#125;    // fn summarize(&amp;self) -&gt; String &#123;    //     format!(&quot;文章&#123;&#125;，作者是&#123;&#125;&quot;, self.name, self.author)    // &#125;&#125;// 为 Weibo 实现 Summary 特征impl Summary for Weibo &#123;    fn summarize_author(&amp;self) -&gt; String &#123;        format!(&quot;@&#123;&#125;&quot;, self.username)    &#125;    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;&#123;&#125;发表了微博&#123;&#125;&quot;, self.username, self.content)    &#125;&#125;fn main() &#123;    let post = Post &#123;        name: &quot;trait_study&quot;.to_string(),        author: &quot;marnie&quot;.to_string(),    &#125;;   // Post 中只有 summarize_author 这一个方法的实现   // 所以当调用 summarize 方法时会找到其原特征中的对应方法    println!(&quot;&#123;&#125;&quot;, post.summarize_author());    println!(&quot;&#123;&#125;&quot;, post.summarize());    let weibo = Weibo &#123;        username: String::from(&quot;marnie&quot;),        content: String::from(&quot;正在学习 Trait 特征&quot;),    &#125;;   // 因为 Weibo 中分别对以下两个方法进行了重写，会覆盖特征中的默认方法    println!(&quot;&#123;&#125;&quot;, weibo.summarize_author());    println!(&quot;&#123;&#125;&quot;, weibo.summarize());&#125;\n\n\n泛型的使用在特征中使用泛型trait AAA&lt;T&gt; 使用到传入的泛型的地方，必须手动标注类型\n特征接收的泛型是给特征方法所使用的，在具体实现了特征的结构体调用方法时，需要手动的标注泛型的实际类型，让编译器知道调用哪个类型实现的方法\n123456789101112131415161718192021222324252627282930313233// 特征 Convert 用于转换类型trait Convert&lt;T&gt; &#123;    fn convert(&amp;self) -&gt; T;&#125;// 我们定义一个结构体来实现 Convert 特征// 元组结构体（tuple）struct MyInt(i32);// 对 MyInt 实现了两种类型的特征impl Convert&lt;i32&gt; for MyInt &#123;    fn convert(&amp;self) -&gt; i32 &#123;        self.0 as i32    &#125;&#125;impl Convert&lt;String&gt; for MyInt &#123;    fn convert(&amp;self) -&gt; String &#123;        self.0.to_string()    &#125;&#125;fn main() &#123;    let my_int = MyInt(5);    // 必须手动加上类型标注    let output: i32 = my_int.convert();    println!(&quot;&#123;&#125;&quot;, output);    // 必须手动加上类型标注    let output: String = my_int.convert();    println!(&quot;&#123;&#125;&quot;, output);&#125;\n\n\n\n在方法中使用泛型impl&lt;T&gt; AAA for BBB ==&gt; impl&lt;T&gt; for BBB\n在方法中使用泛型指的是 —— 当我们某个特征方法需要使用泛型，它本质上就是将指定类型传给方法，和特征、和结构体其实无关，使用上和在结构体中使用泛型是一个方式。\n一种更疯狂的用法，该泛型既是方法需要用的也是特征要用的，会是下面定义的样子：\n123impl&lt;T&gt; Convert&lt;T&gt; for MyInt &#123; // ...&#125;\n\n当 trait 中加入了泛型，让我们拥有了针对不同场景进行不同类型实现的能力。但如果我们想控制 —— 特征的实现是可以支持多种类型的，但只能有一种类型的具体实现，这个时候泛型就做不了这样的约束了，Rust 针对需要这种约束的场景提供了一个新的方式 —— 关联类型。\n关联类型关联类型是在签名时不固定类型，在实现中指定需关联的类型，且不能有多次指定（即多种实现），编译器会在第一次以后得实现上报错。\n123456789101112131415161718192021222324252627282930313233- trait Convert&lt;T&gt; &#123;-     fn convert(&amp;self) -&gt; T;- &#125;+ trait Convert &#123;+     // 这是关联类型 Output+     type Output;+     // Self::Output 使用关联类型+     fn convert(&amp;self) -&gt; Self::Output;+ &#125;struct MyInt(i32);- impl Convert&lt;i32&gt; for MyInt &#123;-     fn convert(&amp;self) -&gt; i32 &#123;-         self.0 as i32-     &#125;- &#125;- impl Convert&lt;String&gt; for MyInt &#123;-     fn convert(&amp;self) -&gt; String &#123;-         self.0.to_string()-     &#125;- &#125;+ impl Convert for MyInt &#123;+     type Output = i32;+     fn convert(&amp;self) -&gt; Self::Output &#123;+         self.0+     &#125;+ &#125;\n\n\n\n如果关联了不止一个类型，就会得到下面的报错：\n\nTrait 关联类型的默认类型A&lt;B = T&gt; T 为 A 关联类型 B 的默认类型\n我们先实现一个简单的 add 函数，功能是将两个参数相加，并返回结果：\n1234567891011use std::ops::Add;// 作用：将两参数相加，并返回结果fn add&lt;T: Add&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T &#123;  a + b&#125;fn main() &#123;  let sum = add(10, 20);  println!(&quot;&#123;&#125;&quot;, sum);&#125;\n\n\n这里用了一个内部特征 Add，它支持泛型且默认值为 Self，Self 指的是当你没有指定传入类型时它就默认为你正在调用的实现了 Add 特征的当前类型。\n\n12345678910111213141516171819202122// 举个例子struct Point &#123;  x: i32,  y: i32,&#125;// ✨ 并没有指定 Add 的泛型，Self 则为当前类型 Pointimpl Add for Point &#123;  // ✨ 关联类型没有默认值，必须手动指定  type Output = Point;    fn add(self, rhs: Self) -&gt; Self::Output &#123;    Point &#123;      x: self.x + rhs.x,      y: self.y + rhs.y,    &#125;  &#125;&#125;let p1 = Point &#123; x: 10, y: 20 &#125;;let p2 = Point &#123; x: 20, y: 30 &#125;;let p3 = p1.add(p2);\n\n\n再回到前面我们手动实现的 add 函数，我们再用不同类型来试验一下泛型：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Add 特征在 Meters 上的多态实现impl Add&lt;Kilometers&gt; for Meters &#123;    type Output = Meters;    fn add(self, rhs: Kilometers) -&gt; Self::Output &#123;        println!(            &quot;&#123;&#125;km, &#123;&#125;m, &#123;&#125;m&quot;,            rhs.0,            rhs.0 * 1000 as f64,            self.0 + (rhs.0 * 1000 as f64)        );        Meters(self.0 + (rhs.0 * 1000 as f64))    &#125;&#125;// Add 特征在 Meters 上的多态实现impl Add for Meters &#123;    type Output = Meters;    fn add(self, rhs: Meters) -&gt; Self::Output &#123;        Meters(self.0 + rhs.0)    &#125;&#125;// Add 特征在 Kilometers 上的多态实现impl Add&lt;Meters&gt; for Kilometers &#123;    type Output = Kilometers;    fn add(self, rhs: Meters) -&gt; Self::Output &#123;        println!(            &quot;&#123;&#125;m, &#123;&#125;km, &#123;&#125;km&quot;,            rhs.0,            rhs.0 / 1000 as f64,            self.0 + (rhs.0 / 1000 as f64)        );        Kilometers(self.0 + rhs.0 / 1000 as f64)    &#125;&#125;// Add 特征在 Kilometers 上的多态实现impl Add for Kilometers &#123;    type Output = Kilometers;    fn add(self, rhs: Self) -&gt; Self::Output &#123;        Kilometers(self.0 + rhs.0)    &#125;&#125;let m = Meters(600 as f64);let km = Kilometers(10 as f64);let total_m = m.clone().add(km.clone());let total_km = km.add(m.clone());println!(&quot;total meters = &#123;:?&#125;m&quot;, total_m.0);println!(&quot;total kilometers = &#123;:?&#125;km&quot;, total_km.0);\n\n\n当 Trait 作为参数传递时，如何进行类型声明 —— Trait Bound 特征约束\nTrait Bound 特征约束假设当前有一个特征 Summary\n12345trait Summary &#123;  fn summarize(&amp;self) -&gt; String;&#125;// TODO：实现 notify 函数，用于实现了 Summary 特征的类型进行通知（调用 .summarize 方法）\n\n&lt;T: U&gt; 用于约束泛型 T 必须是实现了 U 特性的类型，但该函数只能接受一种泛型的具体类型\n1234567891011121314// 单个参数fn notify&lt;T: Summary&gt;(item: &amp;T) &#123;  item.summarize();&#125;// 多参数fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;  item.summarize();&#125;// 省略 Weibo，Post 定义，它们均是实现了 Summary 特征的结构体// 只能传入一种类型notify(Weibo &#123;&#125;, Weibo &#123;&#125;); // ✅notify(Weibo &#123;&#125;, Post &#123;&#125;); // ❌\n\n\n\nimpl T 用于表示实现了 T 特性的类型，比起 &lt;T: U&gt; 更灵活，可以传入不同的实现了同一特征的类型\n1234567891011121314151617fn notify(item: &amp;impl Summary) &#123;  item.summarize();&#125;// 返回类型同样也能使用fn foo() -&gt; impl Summary &#123;  // ...&#125;// 多参数fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) &#123;  item.summarize();&#125;// 省略 Weibo，Post 定义，它们均是实现了 Summary 特征的结构体// 可以传入多个类型notify(Weibo &#123;&#125;, Post &#123;&#125;);\n\n\n\n多重约束 &lt;T: A + B&gt; &#x2F; impl A + B 表示同时实现了 特征A 和 特征B 的类型where 语法糖当约束复杂时，可以使用 where 语法糖在函数后面写类型约束\n1234567fn notify2&lt;T, U&gt;(item1: T, item2: U)where  T: Summary + Display,  U: Summary + Display + Debug,&#123;  // ...&#125;\n\n\n\nderive 派生特性当一个类型没有实现某个 trait 但又想使用该特性的方法，可以使用 #[derive(AAA)] 派生特性的语法，会自动实现该特征和继承其方法的默认行为。如果一个结构体派生了某个特征，那么该结构体的每个字段都需要实现了这个特征，不然无法对齐特征，使用其功能。\nCopy Trait 复制特征这里介绍一个常用特征 Copy ，通常我们使用 let b = a，因为所有权的控制，赋值会将 a 的值的所有权转移给目标变量 b，在赋值语句之后，a 将不能再被使用。\n但如果是实现了 Copy 特征的类型，在赋值操作时会调用 Copy 特征的功能，不会转移所有权，会将值复制一份赋值给目标变量，这样一来等号左边和右边的变量就是两个独立变量，不会互相影响。一般内置基本类型都已经实现了 Copy 特征。\n12345678struct Meters(i32);fn main() &#123;    let b = Meters(10);    let a = b;    println!(&quot;&#123;:?&#125;&quot;, b);&#125;\n\n\n我们使用派生特性加上 Copy 特征，报错就解决了：\n123456789#[derive(Debug, Copy)]struct Meters(i32);fn main() &#123;    let b = Meters(10);    let a = b;    println!(&quot;&#123;:?&#125;&quot;, b);&#125;\n\n\n练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960trait Item &#123;    type Output;    fn summarize(&amp;self) -&gt; Self::Output;&#125;struct Apple &#123;    name: String,&#125;struct Weibo &#123;    author: String,    content: String,&#125;impl Item for Apple &#123;    type Output = String;    fn summarize(&amp;self) -&gt; Self::Output &#123;        self.name.to_string()    &#125;&#125;impl Item for Weibo &#123;    type Output = String;    fn summarize(&amp;self) -&gt; Self::Output &#123;        format!(&quot;@&#123;&#125;:&#123;&#125;&quot;, self.author, self.content)    &#125;&#125;struct Container &#123;    // 💙 注意点    items: Vec&lt;Box&lt;dyn Item&lt;Output = String&gt;&gt;&gt;,&#125;impl Container &#123;    fn iterator(&amp;self) &#123;        // 💙 注意点        for item in self.items.iter() &#123;            println!(&quot;&#123;&#125;&quot;, item.summarize())        &#125;    &#125;&#125;fn main() &#123;    let apple = Apple &#123;        name: String::from(&quot;Marnie&quot;),    &#125;;    let weibo = Weibo &#123;        author: String::from(&quot;Marnie&quot;),        content: String::from(&quot;sky...&quot;),    &#125;;    let container = Container &#123;        // 💙 注意点        items: vec![Box::new(apple), Box::new(weibo)],    &#125;;    container.iterator();&#125;\n\n\nTrait Object 用 dyn 关键字\nTrait Object 是动态类型，编译时没有固定大小，需要用智能指针包裹（赋予其一个栈内的固定大小）使用\n遍历向量 Vec 使用 xxx.iter()\n含关联类型的声明方式 XXX&lt;Output = T&gt;\n\n","slug":"trait","date":"2025-01-05T14:56:40.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"9fb78f735ce3a3f25bf1795a347b0649","title":"智能指针2 Smart Pointers 2","content":"Rc 智能指针Rust 所有权机制要求一个值只能有一个所有者，如果出现需要共享数据的情况，也就是说一个数据资源拥有多个所有者，或者说一个资源需要被多个对象引用，Rust 设计了 Rc 智能指针来做相应实现。\nRc&lt;T&gt;Rc 是引用计数（Reference counting）的意思，顾名思义就是记录一个数据资源被引用的次数，以此来确定该数据是否正在被使用。当引用次数归零后，就代表该数据不再被任何使用，因此可以被清理释放。在离开某个作用域时，如引用对象被 drop 了那引用次数也会对应减去。\nRc::new我们使用 Rc::new(data) 创建一个新的 Rc&lt;T&gt; 智能指针，并赋值给某个变量。\nRc::clone我们使用 Rc::clone(Rc&lt;T&gt;) 创建出一个新的 Rc&lt;T&gt; 智能指针，指向堆内存上那个被共享的 Rc&lt;T&gt; 智能指针。使用 clone 可以在不转移所有权的条件下得到 owned value，而不是某个值的引用。\nOwned Valuelet x = 5 我们把 x 称为 variable 变量，5 称为 owned value 即 数据值，此时 变量 x 拥有 数据 5 的所有权。\nRc::strong_count新建的 Rc&lt;T&gt; 智能指针初始引用计数为1，每被 clone 一次就会相应 +1，调用 Rc::strong(Rc&lt;T&gt;) 会返回传入的 Rc&lt;T&gt; 智能指针当前被引用的次数。\nStrong Reference 强引用Rc 是 strong reference 强引用，强引用指的是会参与引用计数的引用，参与引用计数意味着每被引用一次，该数据的被引用次数就会加一，只要被引用次数不为0，那这块数据对应的资源就不会被释放。\n比如 c 是一个 Rc 变量，它被 a 和 b 引用着，那只有 a 和 b 的引用都被 drop 了之后，c 对应的内部数据资源才会被清理。这里就会出现一个问题，因为强引用会参与引用计数，它会直接影响到内存释放的逻辑，当产生循环引用时，比如 a 引用 b，c 引用 d，b 和 d 之间存在互相引用，本来 a 离开作用域后应该将 b 释放的，但是因为 d 还有对 b 的引用所以这块资源并不能释放，同样的 c 离开作用域后应该将 d 释放的，但 d 还存在被 b 引用着也无法被释放，这就会产生内存泄漏问题。为了避免内存泄漏，当我们遇到循环引用的场景时我们需要用 weak reference 弱引用来替代，下面说明一下相关用法。\nWeak Reference 弱引用Rc::downgrade使用 Rc::downgrade(&amp;Rc&lt;T&gt;) 得到一个 Rc 引用的弱引用，弱引用不参与引用计数，它只是 Rc 在处理循环引用上的一个解决方案。而也因为不参与引用计数，所以无法保证被引用的对象一定是存在的，当需要访问它对应的数据时，需要使用 xx.upgrade() 将其转换为强引用类型，且该强引用被引用的对象还存在时，才可以访问。\n12345678910111213let t = Rc::new(String::from(&quot;Hello&quot;));let weak_t = Rc::downgrade(&amp;t);// upgrade 得到强引用的对象match weak_t.upgrade() &#123;  // 若强引用对象还存在  Some(t) =&gt; &#123;    println!(&quot;&#123;&#125;&quot;, t);  &#125;  // 强引用对象不存在  _ =&gt; &#123;&#125;&#125;;\n\n共享资源之后还安全么？我们之前学习过，Rust 中设计所有权机制就是为了保证数据资源的使用安全，一个数据资源只有一个所有者，就能规避掉对一个数据同时进行读写的状况。\n而也是因为所有权的限制，在很多实际场景中，会让开发者因为所有权转移的规则而头疼，导致代码总是无法编译通过、报错。于是乎，Rc 智能指针的诞生让开发者可以更轻松的实现对一个数据资源的共享且不违背所有权规则的底层原因 —— 数据读写安全，它提供了“创建指向同一块资源的多个指针”的能力，以及一些相关的功能（如：引用计数）。查看 Rc 的内部实现就可以发现，它在创建时其实是把数据装在了一个 Box 智能指针中（让不确定大小的数据类型变成有大小的数据类型，有大小的数据类型指的是为其在栈上申请一块空间，并在栈上拥有一个固定大小的指针指向这块内存），然后又在外面套了一层自己的壳，而在 Rc 智能指针这一层并没有提供修改内部数据的方法，所以即使是共享资源，多个对象可以访问一块内存资源，内存中的数据也还是安全的，它只是一个不可变的引用。\n但是往往，需要 share data 的场景 和 修改的场景 都是伴随出现的，我们遇到 共享 + 修改 时需要配合 RefCell 使用。\nRefCell一般在共享数据的场景下，如果还需要支持对原数据进行修改，我们就可以使用 RefCell。RefCell 是让你拥有对数据修改能力的结构体，即便这个数据是 immutable 的。它和可变引用的区别是，可变引用依然遵守一个所有者的原则，一个数据的可变引用和不可变引用是不能同时存在的。我们可以看下例子：\n\n如报错所示，因为引用本身还是遵守 ownership 的原则，不可能同时存在两种类型的引用，这是违背数据安全的，在编译时就可以校验出来。说回 RefCell ，我们看到前面引用存在着严格的借用关系，当我们需要借用的地方变多时，就会很难在写代码时就整理出明确的借用关系。此时就可以用 RefCell，它没有编译时的借用关系校验，而是运行时校验，介绍下它的常用内容。\nRefCell::new创建一个新的内部可变的 RefCell 结构体\n123use std::cell::RefCell;let data = RefCell::new(5);\n\nborrow()得到某个 RefCell 的不可变借用\n1let r1 = data.borrow();  // Immutable borrow\n\nborrow_mut()得到某个 RefCell 的可变借用\n12let mut r2 = data.borrow_mut();  // Mutable borrow*r2 += 1; // Modify through mutable borrow\n\nRefCell 的限制RefCell 也有一个使用规则，在运行时不能同时存在着可变借用和不可变借用。\n如下图的示例，我们可以看到虽然我们创建了可变借用和不可变借用，并有同时存在的时刻，但这并没有触发编译报错：\n\n我们运行代码，可以看到报错信息 “already borrowed”：\n\nInterior Mutability 内部可变性内部可变性指的是即使变量本身定义的是非可变变量，使用 RefCell 也能改变其内部的数据。\n练习\n实现：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091use std::&#123;    cell::RefCell,    rc::&#123;Rc, Weak&#125;,&#125;;fn main() &#123;    home_work();&#125;#[derive(Debug)]struct User &#123;    name: String,    // friends 用户列表 Vec&lt;User&gt;    // a、b 存在互相引用 需要定义成 Weak 智能指针 Vec&lt;Weak&lt;User&gt;&gt;    // a、b 的 friends 需要有可变性 Vec&lt;Weak&lt;RefCell&lt;User&gt;&gt;&gt;    friends: RefCell&lt;Vec&lt;Weak&lt;User&gt;&gt;&gt;,&#125;impl User &#123;    fn new(name: &amp;str) -&gt; Rc&lt;User&gt; &#123;        Rc::new(User &#123;            name: String::from(name),            friends: RefCell::new(vec![]),        &#125;)    &#125;    // 因为我们需要拿到 user 内部的 friends 数据，所以此时需要用 Rc 而不是 Weak，Weak 无法得到内部数据    fn add_friend(self: &amp;Rc&lt;User&gt;, other: Rc&lt;User&gt;) &#123;        // 需要检查other和self是否已经是朋友，若不是则push进friends列表        // 如何检查 friends 列表，已知 friends 列表是一个 Weak&lt;User&gt; list        let weak_other = Rc::downgrade(&amp;other.clone());        let is_friend = self            .friends            .borrow()            .iter()            .any(|user| weak_other.ptr_eq(user));        if is_friend &#123;            println!(&quot;&#123;&#125; and &#123;&#125; are already friends.&quot;, self.name, other.name);            return;        &#125;        if !is_friend &#123;            println!(&quot;&#123;&#125; add friend &#123;&#125;&quot;, self.name, other.name);            // 若不是朋友，更新 friends 列表            self.friends.borrow_mut().push(weak_other);            other.friends.borrow_mut().push(Rc::downgrade(self));        &#125;    &#125;    fn list_friends(self: &amp;Rc&lt;User&gt;) &#123;        let mut output = String::from(format!(&quot;The friends of &#123;&#125; are &quot;, self.name).as_str());        for item in self.friends.borrow().iter() &#123;            match item.upgrade() &#123;                Some(friend) =&gt; output.push_str(format!(&quot;&#123;&#125;,&quot;, friend.name).as_str()),                None =&gt; &#123;&#125;            &#125;        &#125;        output.pop();        println!(&quot;&#123;&#125;&quot;, output);    &#125;&#125;/** * 实现一个简单的社交网络系统，包含用户和朋友的关系。 * 用户结构：每个用户拥有一个名字和一个朋友列表 * 添加朋友：支持在两个用户之间建立朋友关系 * 展示朋友关系：能够展示每个用户的朋友列表 * 循环引用：处理用户之间的双向引用，确保不产生循环引用 */fn home_work() &#123;    let a = User::new(&quot;Milk&quot;);    let b = User::new(&quot;Mark&quot;);    let c = User::new(&quot;Film&quot;);    a.add_friend(b.clone());    a.add_friend(c.clone());    b.add_friend(a.clone());    b.add_friend(c.clone());    c.add_friend(a.clone());    c.add_friend(b.clone());    a.list_friends();    b.list_friends();    c.list_friends();    // println!(&quot;a = &#123;:?&#125;&quot;, a);    // println!(&quot;b = &#123;:?&#125;&quot;, b);    // println!(&quot;c = &#123;:?&#125;&quot;, c);    // println!(&quot;a rc = &#123;:?&#125;&quot;, Rc::strong_count(&amp;a));    // println!(&quot;b rc = &#123;:?&#125;&quot;, Rc::strong_count(&amp;b));    // println!(&quot;c rc = &#123;:?&#125;&quot;, Rc::strong_count(&amp;c));&#125;\n\n运行结果：\n\n","slug":"smart-pointers-2","date":"2024-12-05T03:36:40.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"be46c1c387f4b8a2a5d0ca8494de6c20","title":"生命周期 Lifetime","content":"作用生命周期即指一个变量的有效作用范围，它和 Scope 的概念听起来会有点类似。Scope（作用域）规定了变量能被访问的范围，超出了定义作用域的地方是不能访问作用域内定义的变量的。而 Lifetime（生命周期）是针对引用变量的，它表示一个引用变量可存活的范围，简单说也就是，如果我压根不存在引用的变量，那我遵循作用域的限制就够用了。但是一旦出现了引用和被引用的关系，单纯作用域的概念不够使用，可能会产生悬垂引用之类的问题，于是 Rust 为了确保所有操作都是内存安全的，制定了生命周期的一套概念。\n悬垂指针 Dangling Pointer悬垂指针指的是引用了内存已被释放的变量，如下：\n12345678910111213fn main() &#123;    let r;    &#123;        let x = 5;        r = &amp;x;        // 🌟 drop(x) 这里在离开代码块前有一步隐藏的自动释放 x    &#125;    // r 指向的引用 x 在离开代码块后就会被释放    // 则以下代码访问 r 即产生了一个悬垂指针（dangling pointer）    // —— 访问了已被释放内存的变量    println!(&quot;This is a dangling pointer &amp;r &#123;&#125;&quot;, &amp;r);&#125;\n\n悬垂引用的本质是变量的存活时间，也可以说是作用域链长度，通常来说，存活时间更长的变量去引用比它存活时间短的变量就会容易发生这类问题，Rust 编译期间就会检查出每个变量的有效作用范围，来避免这类异常。\n函数中的生命周期我们来实现一个函数 longer，接收两个字符串切片，然后返回长度更大的字符串切片：\n1234567891011121314fn longer(a: &amp;str, b: &amp;str) -&gt; &amp;str &#123;    if a.len() &gt; b.len() &#123;        a    &#125; else &#123;        b    &#125;&#125;fn main() &#123;    let s1 = String::from(&quot;Hello&quot;);    let s2 = &quot;Rust&quot;;    let s3 = longer(s1.as_str(), s2);    println!(&quot;The longer string is &#123;&#125;&quot;, s3);&#125;\n\n我们得到如图的报错提示：\n\nMissing lifetime specifier 缺少生命周期标注，这是为什么？我们上段有讲过，Rust 需要确保所有操作都是内存安全。而如何确保？就会需要足够的信息来分析生命周期，确保只会有短生命周期引用长生命周期的情况。所以，在 Rust 中每个变量都会有它自己的生命周期，代表它能存活多久。\n那么讲回我们上面的 longer 函数，函数参数是两个变量 a 和 b，如果该函数没有返回值的情况下，那么这两个入参引用在函数执行完成后就无法被访问了，这是可以理解的。但我们现在给函数指定了返回一个字符串切片类型的变量，此时 Rust 编译器并不能分析出到底是返回入参 a 还是入参 b 还是别的什么情况，这些都是运行时才能确定的，这就导致了在静态编译期间 Rust 编译器判断不出返回值操作内存是否是安全的，这种状况对 Rust 来说是不允许的。\n于是就需要开发者手动的显式标注生命周期，让编译器在编译时至少了解返回的变量对应的是哪个生命周期，以此来通过编译期间的安全检查。\n📢 注意，生命周期标注并不会对变量的实际生命周期造成任何影响，仅是告知编译器及通过编译期间检查。\n生命周期标注 Lifetime Specifier写法：半个单引号 &#39;a\n123&amp;i32 // 一个引用&amp;&#x27;a i32 // 具有显式生命周期标注的引用&amp;&#x27;a mut i32 // 具有显式生命周期标注的可变引用\n\n我们来修改下 longer 函数，对它加上显式的生命周期标注：\n1234567891011121314151617// 显式的告诉编译器，a,b,返回值 都属于同一个生命周期// 因为返回值要么是 a 要么是 b// 生命周期标注和泛型一样，也需要前置声明 &lt;&#x27;a&gt; 后才能使用fn longer&lt;&#x27;a&gt;(a: &amp;&#x27;a str, b: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;    if a.len() &gt; b.len() &#123;        a    &#125; else &#123;        b    &#125;&#125;fn main() &#123;    let s1 = String::from(&quot;Hello&quot;);    let s2 = &quot;Rust&quot;;    let s3 = longer(s1.as_str(), s2);    println!(&quot;The longer string is &#123;&#125;&quot;, s3);&#125;\n\n运行结果，如下：\n\n那么可能会有疑惑，为什么我们之前的练习中，都没有需要显式生命周期标注的 case 呢？那是因为 Rust 编译器本身有自动推理生命周期的功能，并且如我们上面提到的“每个变量都有其对应的生命周期”，实际上我们定义的函数也会通过编译器被翻译，函数的每个入参都会被自动加上其对应的生命周期参数，而当我们并没有出现无法分析生命周期的情况时，在编译器自动推理能力范围内的 case 就不需要手动加上生命周期标注。\n这是因为，如果函数压根没有返回值，自然就不需要生命周期标注的加持了。如果有返回值，假设函数的返回值是引用类型，那么它也只可能有两种来源：\n\n函数某个入参的生命周期\n函数内某个新建变量的生命周期\n\n对于第一种情况，如果只有一个入参，那也就不需要生命周期标注（✨ 生命周期标注通常是出现在拥有多个生命周期的情况下的）。 而第二种情况，这是明显的悬垂指针，新建变量的生命周期仅在函数内部，函数外是无法对其进行引用的，直接会被编译器拒绝。\n这种无需手动进行生命周期标注的能力被称为 “生命周期消除（Lifetime Elision）”，是编译器为了简化开发者的使用而自动运用的。具体的，会自动使用生命消除能力需要符合三条具体规则，可以参考一下截图要求：\n（一般情况，只要编译器能通过编译，则证明无需手动进行生命周期标注）\n\n对 生命周期标注 的总结生命周期标注就是将函数的多个引用参数和返回值的作用域进行关联，一旦关联到一起后，Rust 便可以拥有充分的信息来分析和确保我们的操作是内存安全的。\n结构体中的生命周期当结构体中存在引用类型时，也会存在需要显式生命周期标注的 case：\n12345// 结构体加上生命周期标注struct Example&lt;&#x27;a, &#x27;b&gt; &#123;  x: &amp;&#x27;a str,  y: &amp;&#x27;b str,&#125;\n\n方法中的生命周期给 Example 结构体加上方法（methods）：\n1234567891011121314151617// 结构体加上生命周期标注struct Example&lt;&#x27;a, &#x27;b&gt; &#123;    x: &amp;&#x27;a str,    y: &amp;&#x27;b str,&#125;impl&lt;&#x27;a, &#x27;b&gt; Example&lt;&#x27;a, &#x27;b&gt; &#123;    // 这里我们并不需要标注因为我们的入参上含有 &amp;self 或者 &amp;mut self，    // 其实就是符合了我们上面指出过的第一种 case，该方法有引用类型的返回值，    // 无论是什么引用类型，只可能是来源于入参。    // 此时如果仅一个入参，那么它的返回值生命周期一定是 self 的生命周期，    // 且无论返回值有多少个，都一定只有一个生命周期。也就不需要手动添加生命周期标注了，    // self 的生命周期 —— 即当前 Example 结构体实例会被直接赋予给这个方法的返回值。    fn get_self(&amp;self) -&gt; &amp;Example &#123;        self    &#125;&#125;\n\n手动约束生命周期另外还有一种手动约束多个生命周期的语法 —— &#39;a: &#39;b 表示 &#39;a 活的比 &#39;b 时间长，用于当方法引用了多个生命周期的情况下，因为如果返回了一个较大的生命周期会产生悬垂引用，需要手动表明生命周期之间的关系：\n12345678910111213141516// beforeimpl&lt;&#x27;a&gt; MyStruct&lt;&#x27;a&gt; &#123;  // 方法返回值为&#x27;b, 且该方法引用了&#x27;a, 那么只有 &#x27;b 存活时间一定比 &#x27;a 短才不会引起悬垂引用。  // Rust 编译器并不能知道两者关系，需要手动加上生命周期约束。  fn foo&lt;&#x27;b&gt;(&amp;&#x27;a self, other: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123;   self.name &#125;&#125;// afterimpl&lt;&#x27;a: &#x27;b, &#x27;a&gt; MyStruct&lt;&#x27;a&gt; &#123;  fn foo&lt;&#x27;b&gt;(&amp;&#x27;a self, other: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123;   self.name &#125;&#125;\n\n特殊生命周期标注静态生命周期&#39;static 标注是指这是一个静态生命周期，拥有静态生命周期的引用就表示可以和整个程序存活的一样久。\n1let s: &amp;&#x27;static str = &quot;我没啥优点，就是活得久，嘿嘿&quot;;\n\n在 Rust 中，字符串字面量默认就是 静态生命周期，即不管字符串字面量定义在哪，它的生命周期默认都是整个程序存活期间。这里我们可以结合一个复杂点的例子来对比看下字符串字面量的生命周期和普通生命周期的差异。\n有如下两个函数，分别都返回第二个入参，对应也都加上了生命周期标注：\n1234567fn example&lt;&#x27;a&gt;(a: &amp;&#x27;a str, b: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;    b&#125;fn example2&lt;&#x27;a&gt;(a: &amp;&#x27;a i32, b: &amp;&#x27;a i32) -&gt; &amp;&#x27;a i32 &#123;    b&#125;\n\n我们写两个一样的 case，一个用字符串字面量测试 对应 example，一个用 i32 类型测试 对应 example2：\n123456789101112131415161718192021let s1 = &quot;Hello&quot;; // &#x27;staticlet result = &#123;  let s2 = &quot;Rust&quot;; // &#x27;static  let result = example(s1, s2);  result&#125;;// result 持有对 s2 的引用// 尝试能否访问println!(&quot;result is &#123;&#125;&quot;, result);let n1 = 3;  // i32let result = &#123;  let n2 = 9;  // i32  let result = example2(&amp;n1, &amp;n2);  result&#125;;// result 持有对 n2 的引用// 尝试能否访问println!(&quot;result is &#123;&#125;&quot;, result);\n\n编辑器有如下报错：\n\nn2 does not live long enough 可以看到 case2 外面的 result 持有了对 n2 的引用，那么就意味着 n2 的生命周期应该长于外部的 result，但 n2 是代码块内部定义的变量，它的存活范围仅在代码块内部，则无法通过编译检查。\n而同一个状况，因为 case1 中用到的是字符串字面量，字符串字面量本身的生命周期就是整个程序期间，这才通过了编译器的检查。\n占位符默认匹配生命周期当我们在实现方法时，如果并没有涉及多生命周期的情况，或者说都满足生命消除规则的条件下，其实就表示我们并不是很关心这个生命周期，这时候我们 impl  声明可以使用 _ 占位符来表示默认匹配的那个生命周期，不需要给定一个具体的生命周期标注名了，因为在内层方法的实现上我们也不需要用到手动标注。\n1234567891011struct Counter&lt;&#x27;a&gt; &#123;    count: &amp;&#x27;a mut i32,&#125;// 占位符匹配默认的生命周期// 该 Counter 结构体实例就一个生命周期impl Counter&lt;&#x27;_&gt; &#123;    fn add(&amp;mut self) &#123;        *self.count += 1;    &#125;&#125;\n\n练习巩固上面的理解，请修复下面的函数声明：\n\n改动代码如下：\n123456789101112131415fn test_lifetime_mut() &#123;  fn insert_value&lt;&#x27;a, &#x27;b: &#x27;a&gt;(my_vec: &amp;mut Vec&lt;&amp;&#x27;a i32&gt;, value: &amp;&#x27;b i32) &#123;    // ✅ 结论：my_vec 拥有对 value 的引用 =&gt; &#x27;b: &#x27;a 为函数添加生命周期约束通过编译器检查    my_vec.push(value);  &#125;    &#123;    // ✅ 根据上述结论，y 必须早于 x 定义    let y = 2;    let x = 1;    let mut my_vec = vec![&amp;x];    insert_value(&amp;mut my_vec, &amp;y);    println!(&quot;&#123;my_vec:?&#125;&quot;);  &#125;&#125;\n\n成功运行！\n\n","slug":"lifetime","date":"2024-12-04T10:16:46.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"ab26d33d9183b3dac0ad2f16b85bf6b4","title":"泛型 Generics","content":"函数中使用泛型泛型是实现让一个功能函数支持不同类型的手段，我们称之为多态。在不支持泛型时，我们可能会写出如下代码：\n1234567891011fn add_i32(a: i32, b: i32) -&gt; i32 &#123;    a + b&#125;fn add_f64(a: f64, b: f64) -&gt; f64 &#123;    a + b&#125;fn add_i8(a: i8, b: i8) -&gt; i8 &#123;    a + b&#125;\n\n上面是多个类型的 add 函数，因为类型的限制，我们需要为每种类型单独写一个函数。有了泛型之后，可以省去这样冗余的代码，泛型的声明格式：\n使用泛型参数，有一个先决条件，必需在使用前对其进行声明。\n使用前声明的意义是：表示我这个函数拥有多少泛型参数，如\n123fn add&lt;T&gt; // 表示当前 add 函数拥有一个泛型参数 Tfn foo&lt;T, R&gt; // 表示当前 foo 函数拥有两个泛型参数 T，R\n\n延用 add 函数，我们完善泛型声明后如下：\n\n我们得到了一个报错，cannot add T to T 因为泛型参数 T 可以是任何类型，但并不是所有类型都可以做加法这个行为，所以我们还需要对泛型参数 T 进行特征（Trait）限制，以表示这个类型是可以进行相加的。\n我们输入 add 可以看到相关的特征提示，add 特征也是支持泛型的，按照提示的示例，我们修改函数声明。\n\nAdd 是 use std::ops::Add 引入的，Add&lt;Output = T&gt; 我们把泛型参数 T 传入 Trait Add 的泛型声明中，整个泛型的声明就完成了。\n\n下面我们再尝试写一个复杂点的例子，实现一个输出数组中最大值的函数。\n123456789101112131415161718192021222324/** * 1. 声明泛型参数 T * 2. list 为类型为 T 的数组，用指针类型让数组参数在编译时期有一个确定的大小 * 3. 返回值为 T类型值 的引用 */fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T &#123;    // 默认最大值为数组第一个元素    let mut max = &amp;list[0];    // 遍历后续数组，逐个比较，出现更大的值则替换    for i in 1..list.len() &#123;        // 这里需要注意，需要限制泛型参数 T &lt;T: std::cmp::PartialOrd&gt;，要拥有比较大小的特征        if max &lt; &amp;list[i] &#123;            max = &amp;list[i];        &#125;    &#125;    max&#125;fn main() &#123;    let number_list = vec![1, 5, 9, 4, 7];    let max = largest(&amp;number_list);    println!(&quot;largest number is &#123;&#125;&quot;, max);&#125;\n\n运行后结果如下：\n\n结构体中使用泛型基于上面泛型的理解，我们直接看声明：\n1234567891011struct Point&lt;T&gt; &#123;  x: T,  y: T,&#125;// 上述类型声明表示，结构体 Point 的 fields 都是同一个类型的fn main() &#123;    let p1 = Point &#123; x: 1, y: 2 &#125;;  // Point&lt;i32&gt;    let p2 = Point &#123; x: 1.0, y: 2.0 &#125;;  // Point&lt;f64&gt;&#125;\n\n那么当我们需要 x, y 不同类型时，我们可以声明第 2 个泛型参数 U，如下：\n123456789101112struct Point&lt;T, U&gt; &#123;  x: T,  y: U,&#125;fn main() &#123;    let p1 = Point &#123; x: 1, y: 2 &#125;;  // Point&lt;i32&gt;    let p2 = Point &#123; x: 1.0, y: 2.0 &#125;;  // Point&lt;f64&gt;     // 这样既可以支持相同类型的情况，也可以支持不同类型的情况   let p3 = Point &#123; x: 1, y: 2.0 &#125;; // Point&lt;i32, f64&gt;&#125;\n\n枚举中使用泛型123456789enum Option&lt;T&gt; &#123;    Some(T),    None,&#125;enum Result&lt;T, E&gt; &#123;    Ok(T),    Err(E),&#125;\n\n方法中使用泛型123456789101112struct Point&lt;T, U&gt; &#123;    x: T,    y: U,&#125;// 这里 Point&lt;T, U&gt; 被视为一种结构体类型，所以在实现其方法时，// 也需要通过 impl&lt;T, U&gt; 提前声明泛型参数列表impl&lt;T, U&gt; Point&lt;T, U&gt; &#123;    fn x(&amp;self) -&gt; &amp;T &#123;        &amp;self.x    &#125;&#125;\n\n我们再加入一个复杂点的方法 mixup，功能是传入另一个 Point，然后输出它们交叉后的新 Point。交叉指的是，取原 Point 的 x 和传入 Point 的 y，组成一个新的 Point。\n123456789101112131415161718192021impl&lt;T, U&gt; Point&lt;T, U&gt; &#123;    fn x(&amp;self) -&gt; &amp;T &#123;        &amp;self.x    &#125;    // mixup 方法入参需要泛型参数 T2, U2   // 所以需要提前声明泛型参数列表 mixup&lt;T2, U2&gt;   // 返回值类型为交叉后的 Point&lt;T, U2&gt; 结构体类型    fn mixup&lt;T2, U2&gt;(self, other: Point&lt;T2, U2&gt;) -&gt; Point&lt;T, U2&gt; &#123;        Point &#123;            x: self.x,            y: other.y,        &#125;    &#125;&#125;fn main() &#123;    // 这里 mixup 并不需要手动传入类型，会根据入参 Point&lt;T2, U2&gt; 类型自动做类型推断    let p4 = p1.mixup(Point &#123; x: 9.0, y: &quot;Hello&quot; &#125;);    println!(&quot;p4.x = &#123;&#125;, p4.y = &#123;&#125;&quot;, p4.x, p4.y);&#125;\n\n运行结果，如下：\n\nconst 泛型意思是 常量的泛型，在诸如当我们只希望控制参数类型为一个整数 i32 数组，但数组长度不需要固定的情况可以使用，看具体例子：\n12345678910111213// usize 表示索引类型fn display_array&lt;const N: usize&gt;(list: &amp;[i32; N]) &#123;    println!(&quot;&#123;:?&#125;&quot;, list);&#125;fn main() &#123;    // 打印一个数组    let a1 = [1, 2, 3];    display_array(&amp;a1);    let a2 = [9, 8, 7, 6];    display_array(&amp;a2);&#125;\n\n运行结果，如下：\n\n泛型代码的性能使用泛型给开发者带来了很多便利，在开发效率上无疑是提效的。而泛型代码虽然输入是一种模式，但是经由 Rust 编译器，实际会被翻译成 n 种，所有可支持的情况都会有一份代码，这个翻译的过程被称为 单态化，即声明时是 多态的，编译后即变为 单态。同时也就意味着，在运行时其实是不会因为泛型带来任何增加的开销的，因为编译期间都生成好了，对应的调用代码调用的也就是那一份翻译后的代码。所有的开销都是在编译期间产生的（编译时间及编译后文件大小会有所增加），运行期间无损，仍然保持高效。\n","slug":"generics","date":"2024-12-02T13:12:41.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"3b2621a700dd1210cc1c1a2ba961dd42","title":"First Project","content":"Getting Started安装 anchor —— Solana 智能合约框架\n1.用 cargo 安装 avm ，Anchor 版本管理器\n1cargo install --git https://github.com/coral-xyz/anchor --tag v0.30.1 anchor-cli\n\n2.使用 avm 安装最新版本 anchor\n1avm install latest\n\n3.检查安装好的版本\n1anchor --version\n\nTrouble Shooting\nerror: no such command: build-sbf\n12cargo buildcargo build-sbf --force-tools-install\n\n\n\n","slug":"first-project","date":"2024-11-01T08:06:44.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"2e2bd34ffcfc46d5575f7c18eed689f5","title":"智能指针 Smart Pointers","content":"首先理解，指针是什么？指针是一个存储了内存地址（memory address）的变量，该内存地址引用或者指向了内存中另外的数据。\n在 Rust 中最常见的指针就是引用（reference），引用变量向被它引用的变量借用（borrow）它指向的数据，这意味着它们自身是没有对该数据的所有权（ownership）的。\n引用只包含一个指向被引用变量的指针，除此之外，引用就再无其他功能了。而 Rust 是静态编译语言，在编译期间就需要确定变量数据的大小以及何时释放。所以设计了智能指针，在普通指针的基础上，还包含了当前长度（len）、最大长度（capacity）等字段，这些都是用来确定指针类型指向的那块数据所需的内存 size 的字段。像是我们之前用过的 String 、Vec 都是智能指针数据类型。\n不同于普通指针，智能指针是具有所有权的指针，且实现了 Deref（解引用）和 Drop（清理）两个 trait（特征），这使得他们可以像指针一样解引用并在离开作用域是自动清理资源。这是对智能指针是什么的一个大致概括，具体功能可以通过后面更多的实际例子去理解更为自然。\n为什么存在智能指针？性能管理 — 处理大体量的数据栈是我们用于快速读写的内存空间，并不适合存储过大的数据。相对来说，简单的数据类型会被分配在栈上，但针对简单却大体量数据，我们就不应该再继续存储在栈上了，栈溢出会引起程序的崩溃。\n1234567/*大体量数据，长度为 1_000_000 的数组，数组默认是分配的栈内存*/let arr_stack = [0; 1000000];for i in arr_stack &#123;  println!(&quot;&#123;&#125;&quot;, i);&#125;\n\n运行代码，我们会得到如下报错：\n\n正如前面所说 —— 栈溢出，程序中止运行了。\n处理更复杂的数据结构Rust 是静态编译语言，这意味着它在编译时期就是需要知道每个数据所需内存大小，而针对一些复杂的数据结构，如递归结构、分享结构【❓TODO 这是啥】等，是没有固定大小的，而智能指针就是为了解决这一问题设计的。\n举个例子，常规 enum ，因为一次只会使用 enum 的某一个值，所以该 enum 的所需内存大小取决于其下面内存占用最大的一个枚举值。\n12345678910enum Message &#123;  Quit,  Move &#123; x: i32, y: i32 &#125;,  Write(String),  ChangeColor(i32, i32, i32),&#125;// enum Message 中所需内存最大的是 ChangeColor，// 则该 enum 所需内存为 ChangeColor 所需的内存大小let a = Message::Quit;\n\n更复杂的数据结构，递归 enum 类型\n1234enum List &#123;  Cons(i32, List), // 动态大小，无法确定 size  Nil,&#125;\n\n对于递归 enum 来说，基于我们前面计算 enum 大小的方式，会发现我们并不能知道哪个是内存大小最大的枚举值，递归的枚举值是动态的，所以我们无法得出递归类型的数据大小。\n【TODO】在普通指针基础上，完善更多的功能❓TODO：所有权、悬垂指针、动态大小？\n【TODO】RC 智能指针智能指针是 Rust 确保其安全性的一种方式。智能指针是一种包裹了数据和提供了一些额外功能的数据结构，例如所有权（ownership）和引用计数（reference counting）。Rust 设计了多种智能指针的数据类型，适用于多种不同的场景。\nBox Smart PointerBox 智能指针是 Rust 中智能指针的一种，它是在栈上拥有固定大小的指针，但其指向的数据，在堆上可以是任意大小的数据。所以当我们使用了 Box 智能指针，我们是可以在编译时就知道所需内存大小的。因此上面说到的编译时无法计算内存大小的问题，便就迎刃而解了。\n我们将改写上面递归 enum 的例子，用 Box 智能指针来解决问题：\n12345678910111213// 将递归嵌套的 List 类型改写成 Box&lt;List&gt; 智能指针类型// 智能指针在栈侧是拥有固定大小的指针，可以顺利通过编译enum List &#123;  Cons(i32, Box&lt;List&gt;),  Nil,&#125;use List::&#123; Cons, Nil &#125;;fn main() &#123;  // Box::new() 创建 Box 智能指针类型变量  let list = Cons(1, Box::new(Cons(2, Box::new(3, Box::new(Nil)))));&#125;\n\n智能指针之所以功能强大，还因为 Rust 为其实现了两种特征（trait），Deref Trait 和 Drop Trait，让我们一起了解下。\nThe Deref TraitDeref Trait 解引用是为了让智能指针能像普通指针一样使用而实现的特征（trait）。这句话有两个关键点：\n\n什么是 trait（特征）？\n\n什么叫像普通指针一样使用？\n\n\n我们逐一了解一下：）\nTraits 特征 特征（traits）是 Rust 设计出可以让不同类型拥有相同行为（behavior）的一种实现，在描述某种或者说某类行为时可以包含1个或者多个方法（methods），即特征就是我们用来使得不同类型能够共享（sharing）同一批方法的手段。\n我们看一下 trait 的例子：\n123456pub trait TraitA &#123;  fn method_A(&amp;self) -&gt; String;  fn method_B(&amp;self) -&gt; String &#123;    String::from(&quot;Hello&quot;)  &#125;;&#125;\n\n一般我们描述 trait 时，会包含一个或多个方法的签名，如果对方法写了具体实现，则作为该方法的默认行为。我们也可以在具体类型上重写（overwrite）特征下的方法，来自定义不同类型上的实现。\n1234567891011121314151617181920212223struct StructA &#123;    name: String,&#125;// once impl A for B means B is shared with all methods in Aimpl TraitA for StructA &#123;    // overwrite method_A of trait TraitA    fn method_a(&amp;self) -&gt; String &#123;        String::from([&quot;I&#x27;m&quot;, &amp;self.name].join(&quot; &quot;))    &#125;&#125;fn main() &#123;  let a = StructA &#123;    name: String::from(&quot;aaa&quot;),  &#125;;    // call the methods of trait  let name = a.method_a();  println!(&quot;&#123;&#125;&quot;, name);    a.method_b(); &#125;\n\nRust 定义很多内置的特征，并为我们提供了 derive 属性，用于在一个 struct 或 enum 上生成对某个 trait 的实现的相关代码，这里的代码就是将该 trait 所拥有的默认实现复制过来。这样我们就能快速的拥有一个 trait 的所有默认行为，内置的特征需要通过 use xxx 导入之后使用。\n像普通指针一样使用其实指的就是，可以对于指针变量使用 * 操作符，我们知道因为所有权的关系，我们只能对指针类型的变量进行借用：\n123let x = String::from(&quot;Hello&quot;); // Stringlet y = &amp;x; // &amp;Stringprintln!(&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;, x, y, x == y); // ❌ [ERROR] can&#x27;t compare `String` with `&amp;String`.\n\n这里编译会报错，因为第 3 行无法将不同类型的两个值进行比较，x 是 String 类型，而 y 是 a reference to String。\ny 就是借用了 x，借用就意味着其实就只是拿到了一个内存地址，那么当我们需要直接使用数据时（如：上面做比较的场景 x &#x3D;&#x3D; y）就需要用 * 操作符做解引用，拿到内存地址对应的数据：\n123let x = String::from(&quot;Hello&quot;); // Stringlet y = &amp;x; // &amp;Stringprintln!(&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;, x, y, x == *y); // ✅\n\n除了 * 操作符实现了 deref，还有包括我们经常使用的 . 操作符，是默认带有解引用功能的，通过例子看一下：\n\n可以看到，当我们在使用 . 操作符时，会得到自动解引用之后的结果（倒数第 2 行），并且最后一行我们看到，无论是多加了多少层的引用，都能得到最终指向的那块数据。这就是 . 操作符上带有的魔法之一 —— 自动解引用。\n为了更好的理解解引用特征，我们手动还原一个自己的 MyBox 智能指针类型。\n手动还原 Box 智能指针首先，MyBox 是一个结构体，它只有一个字段 —— 被他包裹的类型，且不需要字段名，即我们采用元组结构体（tuple struct）构造 MyBox。这里还需要使用泛型 T，被包裹的类型是由调用的时候传入的。\n\n\n\n\n\n\n\n\n\n这一部分需要补充泛型（generics）的内容，可以参考 https://course.rs/basic/trait/generic.html\n使用泛型的规范是，先声明 xxx&lt;T&gt; 后使用 structNameXXX(T)、functionNameXXX(x: T) 等。\n1struct MyBox&lt;T&gt;(T);\n\n接着实现 new 方法，在 Rust 中使用 impl 来定义方法，如 impl Circle ，泛型用 impl&lt;T&gt; Circle&lt;T&gt; 。\n12345impl&lt;T&gt; MyBox&lt;T&gt; &#123;    fn new(x: T) -&gt; MyBox&lt;T&gt; &#123;        MyBox(x)    &#125;&#125;\n\n下一步，在 MyBox 上实现 deref trait ，可以参考官网 Deref Trait 给出的示例实现：\n\n1234567impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123;    type Target = T;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123; // Target 就是目标类型 T        &amp;self.0 // 因为 MyBox 是元组结构体，对应的值 self.0    &#125;  // 注意：解引用并不会涉及所有权转移，返回的值还是一个引用值&#125;\n\n现在我们就可以在 MyBox 类型变量上使用解引用功能了，让我们试下:\n1234567fn main() &#123;    let n = MyBox::new(String::from(&quot;Marnie&quot;));    println!(&quot;&#123;:?&#125;&quot;, n);    let a = String::from(&quot;Marnie&quot;);    println!(&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;, a, *n, a == *n);&#125;\n\n\n以上就是模拟 MyBox 并实现 Deref Trait 的大致过程，当我们使用 *v 时，就会去 v 对应的类型 T 上找 deref 方法，即 *(v.deref())，所以但凡是实现了 Deref Trait 的类型变量都可以使用 * 操作符来解引用。\n在官网关于”使用 Deref Trait 将智能指针像常规引用一样对待”有很详细的介绍，细节可以更多的参考 https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait，这里再提一点比较重要的内容：\nImplicit Deref Coerions 隐式的强制解引用在 Deref Trait 相关内容下，有一个知识点叫 Deref coerion 强制解引用，意思是在某些场景下，Rust 会自动发生解引用。\n这里会发生自动解引用的场景是在变量作为参数传入方法 methods 或者函数 functions 时，若传入变量类型实现了 Deref Trait，变会发生自动解引用的行为。我们分析看下官方的例子：\n123fn hello(name: &amp;str) &#123;    println!(&quot;Hello, &#123;&#125;!&quot;, name);&#125;\n\n这里写了一个 hello 函数，接收 string slice 类型的参数，如果我们继续用前面 MyBox 的实例 n 传入 hello 函数 hello(&amp;n)，如：\n123456fn main() &#123;    let n = MyBox::new(String::from(&quot;Marnie&quot;)); // MyBox&lt;String&gt;    println!(&quot;&#123;:?&#125;&quot;, n);    hello(&amp;n); // 🤔...&#125;\n\n我们会发现，编辑器并没有提示任何编译错误，这里就是强制解引用的作用。\n首先，我们传入的 n 本身是个 MyBox&lt;String&gt; 类型，按照强制解引用的发生规则 —— 当我们将某个类型作为参数传入函数或者方法时，会自动发生解引用。MyBox类型的解引用实现我们前面已经还原了，那么这一步强制解引用就相当于调用 n.deref()，则 &amp;n 从 &amp;MyBox&lt;String&gt; -&gt; &amp;String，这么看起来还是不对呀，目标参数接收的是 String Slice，现在还只是 String。好，这里注意 📢，当类型上实现了 Deref Trait 的话强制解引用会一直继续自动发生，即可能发生连续的解引用。\n我们上一步强制解引用得到的是类型 String，在标准库里 String 也对应实现了 Deref Trait ，所以会再次做强制解引用，我们可以查看官网看到标准库中对于 String 上 Deref Trait 实现的签名描述：\n\n可以看到 String 的 deref 方法返回 string slice 类型，所以才满足了 hello 函数，并不会有编译问题。\n关于这个连续强制解引用，我尝试再用一些自定义的类型例子来验证一下是否如此：\n1234567891011121314151617181920212223242526272829303132333435363738394041use std::ops::Deref;struct TypeA(i32); // i32struct TypeB(TypeA); // TypeAstruct TypeC(TypeB); // TypeBimpl Deref for TypeA &#123;    type Target = i32;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;        println!(&quot;calling TypeA&#x27;s deref&quot;);        &amp;self.0    &#125;&#125;impl Deref for TypeB &#123;    type Target = TypeA;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;        println!(&quot;calling TypeB&#x27;s deref&quot;);        &amp;self.0    &#125;&#125;impl Deref for TypeC &#123;    type Target = TypeB;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;        println!(&quot;calling TypeC&#x27;s deref&quot;);        &amp;self.0    &#125;&#125;fn test(x: &amp;i32) &#123;    println!(&quot;I get &#123;&#125;&quot;, x);&#125;fn main() &#123;  let a = TypeA(0);  let b = TypeB(a);  let c = TypeC(b);    test(&amp;c);&#125;\n\n我写了上述的这些代码，企图验证是否会有连续的强制解引用发生。按照我上个段落的结论，我预想的 将 c 作为参数传入 test 函数，c 的类型 TypeC 上又有 deref trait 的实现，那么连续的强制解引用将会是 TypeC -&gt; TypeB, TypeC -&gt; TypeA, TypeA -&gt; i32，我们可以看到编译器首先并没有提示类型错误，我们再运行看看：\n\n如结果所示，印证了预想，那么这就是一个连续的强制解引用的过程。Rust 之所依提供这个隐含的功能就是为了让我们省去手动做”连续的类型转换”的过程。我们再强调一下，这个强制类型转换发生需要符合的条件：\n\n&amp;T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt;  T 上有返回类型为 U 的解引用实现\n&amp;mut T -&gt; &amp;mut U ===&gt; T: DerefMut&lt;Target=U&gt;  T 上有返回类型为 U 的可变解引用实现\n&amp;mut T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt; T 上有返回类型为 U 的解引用实现（可变的类型可以转换为不可变类型，但不可变不能转换成可变）\n\nThe Drop Trait除了 Deref Trait 外，智能指针还拥有 Drop Trait。Drop Trait 是 Rust 设计用于内存管理的特征，当一个变量超出 scope 之后，自动释放其占用的内存。Drop Trait 的实现和 Deref Trait 异曲同工，本质也是执行该 Trait 下对应的 drop method , 当我们需要自定义释放内存的场景就可以手动实现 drop method ，让我们一样用例子看一下：\n1234567891011121314151617181920212223use std::ops::Drop;#[derive(Debug)]struct CustomSmartPointer &#123;    data: String,&#125;impl Drop for CustomSmartPointer &#123;    fn drop(&amp;mut self) &#123;        println!(&quot;CustomSmartPointer of data &#123;&#125; is dropping...&quot;, self.data);    &#125;&#125;fn main() &#123;    let c1 = CustomSmartPointer &#123;        data: String::from(&quot;c1&quot;),    &#125;;    println!(&quot;&#123;:?&#125; is created.&quot;, c1);    let c2 = CustomSmartPointer &#123;        data: String::from(&quot;c2&quot;),    &#125;;    println!(&quot;&#123;:?&#125; is created.&quot;, c2);&#125;\n\n运行结果如下：\n\n结合所有权系统，当一个变量离开作用域以及不存在对其的任何引用，Rust 会自动释放变量占用的内存，这样就无需开发者手动管理内存。我们上面的代码就可以看到这个效果，内存释放是按照变量出栈顺序，即先进后出，创建顺序是 c1 -&gt; c2，销毁顺序则是 c2 -&gt; c1，如打印结果所示。\n这里有一点需要注意，因为 Rust 已经有一套合理管理内存的机制 —— 离开作用域内存会自动被释放，所以是不支持我们直接手动调用 xxx.drop() 来释放内存的，这样会导致双重释放内存的错误（a double free error）。\nTrait Objects虽然 Rust 强调静态类型编译，需要有明确的数据类型，但为了实现代码的多态性，Rust 也提供了一种方案可以动态调度（dynamic dispatch）类型，它就是 Trait Objects。首先我们理解一下什么是动态调度：\nDynamic dispatch 动态调度动态调度表示在编译时并不知道具体类型，而是在运行时才能确定类型。它与 static dispatch 相对，static dispatch 静态调度是指在编译时就已经确定了类型，一般我们没有特别处理的都属于静态调度，变量的类型是明确的，函数的入参类型也是确定的，所有的类型都是编译时就已经固定了的。而动态调度需要使用关键字 dyn ，来表示这是一个动态调度类型，我们需要结合 Trait Objects 这个概念一起使用。\nTrait Objects 是 Rust 提供应对有着同样行为的但所属不同类型的变量的事务，用官方的例子，比如我们现在要实现一个前端框架库，我们会拥有很多 components 组件，每个组件都是一个类型。\n因为组件会有很多种，比如 Button、Select、Input，我们在声明 components 类型的时候，首先它是个可以更改长度的 list，所以 components: vec![???]，好了，这里就有一个问题出现了！vec! 里面的类型并不是我们以往固定的某一种类型，它可能是 Button/Input/Select 等等，这种情况我们就需要使用动态调度，表示这里的类型不是某一个固定类型，是多种类型。\n具体使用方式，用 dyn 关键字表示这里是动态调度，dyn 后面跟的类型是一个 trait，dyn xxxTrait 则表示当前是一个 trait objects 类型。trait（特征）我们在上面有单独介绍，它用来描述某种行为，那么 trait objects 其实就是拥有同种行为的不同类型的对象，本质就是不同类型都对同一个 trait 进行了实现。我们上面这个组件的例子，就是 Trait Objects 的一个标准案例，组件本身都是不同的类型，但是它们都至少有某个或某些相同的行为，比如绘制功能，那么实现时就可以把绘制作为一个 trait，这些组件都有对于 绘制trait 的实现，这些组件便可以通过 dyn Draw 视为同一个 trait object 类型。但因为 trait 本身没有固定大小，所以它必须结合指针类型使用（指针类型拥有固定大小），如 Box&lt;dyn Draw&gt; 表示 Draw trait objects 类型。\n用这个场景，我们具体实现下代码来理解：\n1234567891011121314151617181920212223242526272829303132333435363738// 绘制traittrait Draw &#123;  fn draw(&amp;self);&#125;// Button类型struct Button &#123;  width: u32,  height: u32,  label: String,&#125;// Select类型struct Select &#123;  width: u32,  height: u32,  options: Vec&lt;String&gt;,&#125;// 都会继承绘制traitimpl Draw for Button &#123;  fn draw(&amp;self) &#123;    // do Button&#x27;s drawing stuff   &#125;&#125;// 都会继承绘制traitimpl Draw for Select &#123;  fn draw(&amp;self) &#123;    // do Select&#x27;s drawing stuff   &#125;&#125;// 框架库类struct Library &#123;  // components list  components: Vec&lt;Box&lt;dyn Draw&gt;&gt;, // a list of &quot;Draw trait objects&quot;&#125;\n\n这就是【动态调度 + trait objects】的使用方法，这种方式本质上其实是让我们有了可以同时使用不同的类型的能力，这就是动态调度的魔法。和泛型（generics）的不同之处就是这里，泛型只是声明时的多态，在调用时一次传入的还只是同一个类型，而动态调度是一次调用能传入多种类型，实现了真正的运行时多态。\n练习作业2\n实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163use std::ops::DerefMut;use colored::Colorize;fn main() &#123;    trait FileSystem &#123;        // type Output;        fn create_file(&amp;mut self, name: &amp;str) -&gt; &amp;Node;        fn create_folder(&amp;mut self, name: &amp;str) -&gt; &amp;Node;        fn list_contents(&amp;self);        fn find_folder(&amp;mut self, name: &amp;str) -&gt; Option&lt;&amp;mut Self&gt;;    &#125;    #[derive(Debug)]    enum Node &#123;        // 文件        File(String),        // 文件夹        Folder(FolderNode),    &#125;    #[derive(Debug)]    struct FolderNode &#123;        name: String,        contents: Vec&lt;Box&lt;Node&gt;&gt;,    &#125;    impl FileSystem for FolderNode &#123;        // 在当前文件夹下创建单个文件        fn create_file(&amp;mut self, name: &amp;str) -&gt; &amp;Node &#123;            self.contents.push(Box::new(Node::File(String::from(name))));            println!(&quot;/&#123;&#125; 添加文件 &#123;&#125;&quot;, self.name, name);            self.contents.last().unwrap()        &#125;        // 在当前文件夹下创建文件夹        fn create_folder(&amp;mut self, name: &amp;str) -&gt; &amp;Node &#123;            self.contents.push(Box::new(Node::Folder(FolderNode &#123;                name: String::from(name),                contents: vec![],            &#125;)));            println!(&quot;/&#123;&#125; 添加文件夹 &#123;&#125;&quot;, self.name, name);            self.contents.last().unwrap()        &#125;        // 返回值是一个可变的 FolderNode，因为可能需要继续修改 folder 内容        fn find_folder(&amp;mut self, target_name: &amp;str) -&gt; Option&lt;&amp;mut FolderNode&gt; &#123;            // 声明返回值为可变的，初始为 None            let mut target: Option&lt;&amp;mut FolderNode&gt; = None;            // 遍历子目录，iter_mut() 允许返回可变的遍历对象            for node in self.contents.iter_mut() &#123;                // deref_mut() 允许返回解引用后并可变的值                match node.deref_mut() &#123;                    Node::Folder(folder) =&gt; &#123;                        if folder.name == target_name &#123;                            target = Some(folder);                            break;                        &#125;                    &#125;                    _ =&gt; &#123;                        continue;                    &#125;                &#125;            &#125;            // log error            if target.is_none() &#123;                println!(&quot;&#123;&#125;&quot;, &quot;[ERR] Cannot find this folder!&quot;.red());            &#125;            target        &#125;        // 列出文件夹下所有文件和文件夹（递归 recursion）        fn list_contents(&amp;self) &#123;            println!(&quot;======== /&#123;&#125; 当前目录结构 ========&quot;, self.name);            // print current folder name            println!(&quot;/&#123;&#125;&quot;, self.name);            // 打印单个 node 下的内容，因为需要打印目录结构，子目录需要使用递归            fn print_node(level: usize, node: &amp;Node) &#123;                // 除 root 外（非根目录），目录结构前缀逐级添加 &#x27;|[][][][]&#x27;                let mut level_prefix = String::with_capacity(5 * level);                // level &gt; 1 need append space prefix                for _ in 1..(level) &#123;                    level_prefix.push_str(&quot;|    &quot;);                &#125;                match node &#123;                    // 当前 node 是文件，没有子目录                    Node::File(file_name) =&gt; &#123;                        // print current file name                        println!(&quot;&#123;&#125;&#123;&#125;&quot;, level_prefix, file_name);                    &#125;                    // 当前 node 是文件夹，子目录需要继续调用 print_node                    Node::Folder(folder) =&gt; &#123;                        // print current folder name                        println!(&quot;&#123;&#125;/&#123;&#125;&quot;, level_prefix, folder.name);                        folder                            .contents                            .iter()                            .for_each(|n| print_node(level + 1, n));                    &#125;                &#125;;            &#125;            match self.contents.len() &#123;                // 空文件夹                0 =&gt; &#123;                    return;                &#125;                // 当前为有内容的文件夹                _ =&gt; &#123;                    for (_, content) in self.contents.iter().enumerate() &#123;                        // 当前文件夹 level 1，子文件夹 initial level = 2                        print_node(2, &amp;content);                    &#125;                &#125;            &#125;            println!(&quot;================ END =================&quot;);            println!();        &#125;    &#125;    let mut root = FolderNode &#123;        name: String::from(&quot;root&quot;),        contents: Vec::new(),    &#125;;    // base on root    &#123;        root.create_file(&quot;file_1.txt&quot;);        root.create_file(&quot;file_2.txt&quot;);        root.create_folder(&quot;folder_1&quot;);        root.create_folder(&quot;folder_2&quot;);        root.list_contents();    &#125;    // base on root/folder_1    &#123;        let folder_1 = root.find_folder(&quot;folder_1&quot;).unwrap();        folder_1.create_file(&quot;file_11.txt&quot;);        folder_1.create_file(&quot;file_12.txt&quot;);        folder_1.create_folder(&quot;folder_11&quot;);        folder_1.list_contents();        let folder_11 = folder_1.find_folder(&quot;folder_11&quot;).unwrap();        folder_11.create_folder(&quot;folder_111&quot;);        folder_11.list_contents();    &#125;    // base on root/folder_2    &#123;        let folder_2 = root.find_folder(&quot;folder_2&quot;).unwrap();        folder_2.create_file(&quot;file_21.txt&quot;);        folder_2.create_file(&quot;file_22.txt&quot;);        folder_2.create_folder(&quot;folder_21&quot;);        folder_2.list_contents();    &#125;    root.list_contents();    &#123;        println!(&quot;Test finder_folder error case&quot;);        root.find_folder(&quot;not_exist&quot;);    &#125;&#125;\n\n运行结果\n","slug":"smart-pointers","date":"2024-10-24T07:41:13.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"},{"id":"1f5f42bbe18d84ce044c457f49d8e22c","title":"Rust 基础 Rust Basic","content":"入门 Getting StartedRust静态类型语言（statically typed）：在编译时就确定了所有表达式的类型\n强类型语言（strongly typed）：一切皆需要明确的类型声明\n\nrustc：rust 编译器（compiler）\n\n检查 rust 是否安装成功：rustup --version\n将某个 rust 文件编译成二进制（binary）文件：rustc &lt;file_name&gt;.rs\n\n\nrustup：rust 安装器和版本管理工具\n\nrustup update 升级 rust\nrustup doc 打开本地 rust 文档\n\n\n命名规则（naming rule）：蛇形式（snake_case）\n\n语句（statement）：一定要加分号（semicolon），表示执行某个操作但没有返回值的某个指令\n\n表达式语句：以分号结尾的表达式\n声明语句\n\n\n表达式（expression）：主要用于计算求值（expression-base language）\n\n\nCrate用 rust 写的库或者可执行程序 a rust library or executable program\ncrate.io - rust 官方包注册表\nCargorust 包管理器 rust package manager\n\n支持管理项目依赖 cargo update\n支持编译、运行项目 cargo build, cargo run\n支持上传 crates.io cargo publish\nCargo.toml：dependencies declaration file\n\n1234567891011// setup a new project dircargo new &lt;project_name&gt;// compile project [debug or release version]cargo build [--release]// compile project and execute [debug or release version]cargo run [--release]// update all dependencies (keep semi-version 0.8.5 -&gt; 0.8.latest)cargo update\n\n通用概念 Common Concepts变量 Variables默认都是不可变变量（immutable variables），不用声明类型\n12let x = 5;println!(&quot;The value of x is: &#123;&#125;&quot;, x);\n\n声明可变变量（mutable variables），在运行时才会确定变量的值\n12345let mut x = 5;println!(&quot;The value of x is: &#123;&#125;&quot;, x);x = 6; // 若这句不运行，则 x 值还是 5println!(&quot;The value of x is: &#123;&#125;&quot;, x);\n\n作用域规则 Scoping Rules作用域是一个变量在程序中的有效范围，从变量声明的点开始知道当前作用域的结束就是一个有效范围。\n作用域范围一般分为 函数作用域、代码块作用域。\n不可变变量、可变变量、常量都是遵循这个作用域规则\n123456789101112fn foo() &#123;  let foo_global_variable :i32 = 1;    &#123;    // the start of the block    let foo_local_variable :i32 = 2; // defined in current block, only can access in current block    println!(&quot;The value of foo_global_variable is: &#123;&#125;&quot;, foo_global_variable); // ✅ access anywhere within foo_block    println!(&quot;The value of foo_local_variable is: &#123;&#125;&quot;, foo_local_variable);  &#125; // the end of the block    println!(&quot;The value of foo_local_variable is: &#123;&#125;&quot;, foo_local_variable); // ❌ outer of the block&#125;\n\n遮蔽 Shadowinglet 不可变变量支持重定义（遮蔽 shadowing）：虽然是不可变变量，但是可以用过去的值重新赋值，且可更改类型（与 mut 的不同之处）\n12let spaces = &quot;   &quot;;let spaces = spaces.len();\n\n块内遮蔽（shadowing）也遵循作用域规则，块内重定义变量的操作结果对外是屏蔽的，在块外访问到的还是原值\n123456789101112fn foo() &#123;    let x: i32 = 1;    &#123;        // the start of the block       // 遮蔽（shadowing）        let x = x + 1;        println!(&quot;The value of x is: &#123;&#125;&quot;, x); // ✅ The value of x is: 2    &#125; // the end of the block    println!(&quot;The value of x is: &#123;&#125;&quot;, x); // ✅ The value of x is: 1&#125;\n\n常量 Constants声明常量必须要带类型（data types）注释（annotation），在编译时期就确定了变量的值，命名规范大写蛇形式（UPPER_SNAKE_CASE）\n编译后是直接替换值\n1234// u32: unsigned 32-bit integer 无符号32位整数const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;println!(&quot;&#123;&#125;&quot;, THREE_HOURS_IN_SECONDS); // 🎯 编译后：println!(&quot;&#123;&#125;&quot;, 60 * 60 * 3)\n\n静态变量 Static特点如上同常量\n作用域（scope）：在整个程序中共享，可以再多个线程之间共享 —— 即 全局变量！！\n编译后是指向引用地址\n123static A : i32 = 1; // 假设这个 static 变量分配的内存地址为 0x123println!(&quot;&#123;&#125;&quot;, A); // 🎯 编译后：存在对 A 的引用，指向 A 的内存地址\n\n数据类型 Data Types原始类型 Primitive Types整数型 Integer Types默认 i32\n如果可能是负数则用 i[bit]，反之用 u[bit]，位数由运行代码的电脑决定\n1// TODO: 二进制位数和[整/负]数大小范围的关系\n\n浮点数型 Floating-Point Types默认 f64\n12let x = 2.0; // f64let y: f32 = 3.0; // f32\n\n布尔型 The Boolean Types123// both are 👌🏻let a = true;let b: bool = true;\n\n文本类型 Textual Typeschar 字符型\nunicode 编码，1 char &#x3D; 4 bytes，默认单引号包裹的文字（单个文字）表示字符型变量，也可以显式声明类型,\n123let c = &#x27;z&#x27;;let z: char = &#x27;ℤ&#x27;;let heart_eyed_cat = &#x27;😻&#x27;;\n\n复合类型 Compound Types🕵🏻‍♂️ ：下面字符串类型建议看完所有权部分知识，再去理解比较好！！\nCharacter encoding format\nASCII：1 character &#x3D; 7 bits binary，total 128 characters（max decimal number of 7-bit binary number）\nUTF-8：1 character &#x3D; 1～4 bytes &#x3D; (1～4) x 8 bits，total 1,112,064 character\n\n🎯 TODO：Memory management &amp; ownership in Rust\nhttps://www.linkedin.com/pulse/memory-management-rust-amit-nadiger#:~:text=The%20.,string%20literals%20and%20other%20constants.\n【TODO】compile binary –&gt; read-only memory 是什么？\n【TODO】Machine words 是什么？\n【TODO】Rc smart pointer  reference counted pointer\nVisualizing memory layout of Rust’s data types\nString 文本字符串型一串动态长度的 UTF-8 编码序列，用来表示文本字符串。UTF-8 编码规则用 1～4 个字节表示一个字符，是默认拥有所有权的类型。\n动态分配大小所以存储在 heap 上，对应栈上的变量存储指针（ptr &#x3D; 内存地址）、长度（len &#x3D; 实际长度）、容量（capacity &#x3D; 可用长度）。\n123456789// String 类型值内置了修改和其他的各种方法// mutable variablelet mut s: String = String::from(&quot;hello&quot;);// modify string ss.push(&#x27;!&#x27;);// replace first character of string ss.replace_range(0..1, &quot;H&quot;);// check the resultprintln!(&quot;s = &#123;&#125;&quot;, s);  // ✅ 输出：s = Hello!\n\nString Slice 文本字符串切片类型我们把某个字符串的某段字符串称为 slice（字符串切片&#x2F;字符串片段）。上面提到的，文本字符串本身是动态长度的 UTF-8 编码序列，且拥有数据的所有权。当我们只需要借用字符串文本数据本身时，我们需要使用 &amp;str 类型，它包含指针（ptr &#x3D; 该 slice 第一个字符在内存中对应的地址）、长度（len &#x3D; 从第一个字符开始，一共多少个字符），slice 因为是借用关系，本身是不可变的。字符串本身是动态大小的类型，有了 slice 的借用类型之后，编译时就可以计算出对应字符串所占字节大小，这对 Rust 这种强静态编译语言是必需的。它有两种具体使用场景：\n\n普通文本字符串（string literal）：不可修改\n作为某个 String 类型的切片字符串：不可修改\n\n可以看到，都是不可修改，所以当我们有要修改字符串的计划，我们就应该使用上面 String 类型，而不修改的话就选择 &amp;str 类型。\n12345678910111213141516171819202122232425262728fn str_and_string() &#123;    // 普通文本字符串 string literals    let normal_str = &quot;hello, &quot;;    // 可操作的、拥有所有权的 String 类型字符串    let mut mutable_string = String::from(normal_str);    // a string slice of String, 没有修改字符串的计划    let hello = &amp;mutable_string[0..5];    println!(&quot;hello = &#123;&#125;&quot;, hello);    // 修改字符串 &amp;mut 才能修改    do_some_mutation(&amp;mut mutable_string);    // 只需要借用字符串的值    only_use_text(&amp;mutable_string);    println!(&quot;mutable_string = &#123;&#125;&quot;, mutable_string);&#125;fn do_some_mutation(input: &amp;mut String) &#123;    input.replace_range(0..1, &quot;H&quot;);    input.push_str(&quot;add this to the end&quot;);&#125;fn only_use_text(input: &amp;String) &#123;    let hello = &amp;input[..=6];    let world = &quot;world&quot;;    println!(&quot;greet = &#123;&#125;&quot;, [hello, world].concat());&#125;\n\n隐式类型转换 String -&gt; &amp;str\n当函数参数定义为 &amp;str 切片类型时，我们在传入的是完整切片时是可以直接传入 String 类型字符串的，相当于 &amp;s[..]，Rust 实现了自动解引用，在必要时会将 &amp;String 自动转换成 &amp;str 。这样使得，如果接受参数是字符串的引用，我们采用 &amp;str 作为入参，但能获得两种类型数据的兼容。\n123let s :String = String::from(&quot;hello, world&quot;);// String 转换成 slicelet slice = s.as_str();\n\n注意：反过来是不行的，因为 String 类型 转 切片类型，没有转换成本，而从 切片类型 转 String 类型还需要为其重新申请内存，对性能是有损耗的，Rust 不会自动做这个行为。\n与其他类型的转换\n元组 The Tuple Type混合类型 —— 多种类型的数值的集合，一旦定义了不能改变长度\n12345678// 声明let tup: (i32, f64, u8) = (500, 6.4, 1);// 取值(1)let (x, y, z) = tup;println!(&quot;The value of y is: &#123;y&#125;&quot;); // ✅ The value of y is: 6.4// 取值(2)println!(&quot;Values in tup: &#123;&#125; &#123;&#125; &#123;&#125;&quot;, tup.0, tup.1, tup.2); // ✅ Values in tup: 500 6.4 1\n\n数组 The Array Type数组的定义其实就是为分配一段连续的相同数据类型的内存块。\n[T; N] 表示 N 个值的数组，每个值的类型为 T。数组长度一经定义不可修改，所以编译时数组占用的内存大小就已是确定的了，不能追加或删除元素，但可以修改元素的值。\n12345678910111213// 先声明类型和长度，后赋值let a: [i32; 5] = [1, 2, 3, 4, 5]; // 定义后无法再修改大小// 同样的值，可以简化创建let a = [3; 5]; // 5 个 3// 取值let first = a[0];let second = a[1];// 转迭代器，得到 (index, value) 枚举对 lista.iter().enumerate()\n\n遍历方式\n1234567891011// 已知长度let arr = [10; 4];for i in 0..4 &#123;  println!(&quot;&#123;&#125;&quot;, arr[i]);&#125;// 未知长度：迭代器for i in arr.iter() &#123; println!(&quot;&#123;&#125;&quot;, i);&#125;\n\n数组的引用都是值的传递，即和原数组没有联系，原数组不受任何影响\n12345678910111213141516171819202122fn test_arr() &#123;    let mut a = [10, 20];    let mut b = a;    a[0] = 0;    println!(&quot;a &#123;:?&#125;&quot;, a); // [0, 20]    println!(&quot;b &#123;:?&#125;&quot;, b); // [10, 20]    let arr = [10, 20, 30];    println!(&quot;1111 &#123;:?&#125;&quot;, arr); // [10, 20, 30]   // 参数传递，是直接复制 arr 的值传入，和 arr 无关    update(arr);    println!(&quot;2222 &#123;:?&#125;&quot;, arr); // [10, 20, 30]    fn update(mut arr: [i32; 3]) &#123;        for i in 0..3 &#123;            arr[i] = 0;        &#125;        println!(&quot;update &#123;:?&#125;&quot;, arr); // [0, 0, 0]    &#125;&#125;\n\n向量 The Vec TypeAn array-like data structure，一种类数组数据结构，和数组的区别是它支持动态大小，即可以增加或删除元素。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465fn main() &#123;    /*      使用Vec和HashMap实现书籍库管理系统      添加书籍，查询库存，更新库存，删除书籍    */      let books = vec![        &quot;The Rust Programming Language&quot;,        &quot;Welcome to Rust&quot;,        &quot;Rust by Example&quot;,    ];    struct BookSystem &#123;        map: HashMap&lt;String, i32&gt;,    &#125;    impl BookSystem &#123;        // 创建        fn new(books: Vec&lt;&amp;str&gt;) -&gt; BookSystem &#123;            let mut map = HashMap::new();            for book in books &#123;                map.insert(book.to_string(), 1);            &#125;            BookSystem &#123; map &#125;        &#125;        // 添加书籍        fn add(&amp;mut self, name: &amp;str) &#123;            self.map.insert(name.to_string(), 1);        &#125;        // 查询库存        fn find(&amp;self, name: &amp;str) -&gt; i32 &#123;            match self.map.get(&amp;name.to_string()) &#123;                Some(num) =&gt; *num,                None =&gt; 0,            &#125;        &#125;        // 更新库存        fn update(&amp;mut self, name: &amp;str, num: i32) &#123;            self.map.insert(name.to_string(), num);        &#125;        // 删除书籍        fn delete(&amp;mut self, name: &amp;str) &#123;            self.map.remove_entry(name);        &#125;        fn log(&amp;self) &#123;            println!(&quot;&gt;&gt;&gt;&gt;&gt;&gt; Current stock &lt;&lt;&lt;&lt;&lt;&lt;&quot;);            for (k, v) in &amp;self.map &#123;                println!(&quot;[&#123;&#125;]: &#123;&#125;&quot;, k, v);            &#125;        &#125;    &#125;    let mut sys = BookSystem::new(books);    sys.log();    let book_name = &quot;Easy Rust&quot;;    sys.add(book_name);    sys.log();    sys.update(book_name, 3);    sys.log();    println!(&quot;The stock of [&#123;&#125;] is &#123;&#125;&quot;, book_name, sys.find(book_name));    sys.delete(book_name);    sys.log();&#125;\n\n切片 The Slice Type表示 String 类型、Array 类型、Vec 类型 的局部数据，&amp;T 只引用值，&amp;mut T 可以修改原数据\n12345678910切片常用函数- len(): 取 slice 元素个数- is_empty(): 判断 slice 是否为空- contains(): 判断是否包含某个元素- repeat(): 重复 slice 指定次数- reverse(): 反转 slice- join(): 将各元素压平（flatten）并通过指定的分隔符连接起来- swap(): 交换两个索引处的元素，如 s.swap(1, 3)- windows(): 以指定大小的窗口进行滚动迭代- start_with(): 判断 slice 是否以某个 slice 开头\n\n自定义类型 Custom TypesRust 自定义数据类型主要通过 struct 和 enum 关键字形成\n\nstruct: 定义一个结构体型数据\nenum: 定义一个枚举型数据\n\n结构体 Structures基础用法，结构体可以定义 n 多个字段\n\n结构体变量和一般变量一样，默认也是不可变的（immutable），let mut T = struct XXX 定义可变的（mutable）结构体变量\n可以没有任何字段名，但不能没有字段类型，这种结构体长的像元组，所以被被称为元祖结构体（tuple struct），例如：struct Point(i32, i32, i32) 表示一个点的坐标 x,y,z\n可以不包含任何字段，即没有类型也没有名称，被称为单元结构体\n\n12345678910111213141516171819202122232425262728293031struct Person &#123;    name: String,    age: u8,&#125;let me = Person &#123; name: &quot;Marnie&quot;.to_string(), age: 10 &#125;;// A unit structstruct Unit;// A tuple structstruct Pair(i32, f32);let a = Pair(8, 0.2);println(&quot;&#123;&#125;&quot;, a.0);// A struct with two fieldsstruct Point &#123;    x: f32,    y: f32,&#125;let p = Point &#123; x: 0.5, y: 1.2 &#125;;// Structs can be reused as fields of another structstruct Rectangle &#123;    // A rectangle can be specified by where the top left and bottom right    // corners are in space.    top_left: Point,    bottom_right: Point,&#125;let point_top_left = Point &#123; x: 0.5, y: 1.2 &#125;;let point_bottom_right = Point &#123; x: 1.8, y: 0.2 &#125;;let rect = Rectangle &#123; top_left: point_top_left, bottom_right: point_bottom_right &#125;;\n\n结构体更新语法：我们可以用 ..structA 给 structB 进行更新，在 structB 中没有显示声明的字段，都会从 structA 中取 。\n但是注意了📢，在 Rust 中严格管控着数据所有权（ownership），所以当针对没有 copy 特性的字段被用来赋值之后，该字段的数据所有权即会发生转移。只要有一个字段发生了所有权变化，那么整个结构体就已经是不完整的了，该结构体本身就不能再被转移，即无法整个结构体直接使用。\n没有 copy 特性（trait）指的就是那些存在 heap 上的数据，在 stack-side 存储的是其内存块的 pointer，赋值操作即原指针失效，内存地址转移到新指针上。\n12345678910let user1 = User &#123;     active: true,     username: String::from(&quot;example1&quot;),     email: String::from(&quot;example1@examples.com&quot;),     sign_in_count: 1, &#125;; let user2 = User &#123;     email: String::from(&quot;example2@examples.com&quot;),     ..user1 &#125;;\n\n结构体可以包含行为，即带有方法（方法和函数是有区别的）的结构体\n枚举型 Enum结构体通常是描述带有不同字段的某个类型，而枚举型指的是某个更上层的类型下会包含多个不同类型，比如动物类型包含猫猫、狗狗、兔子、猪等等\n123456enum Animal &#123;  Dog,  Cat,  Rabbit,  Pig,&#125;\n\n函数 Functions语句 Statements表示一个要执行的操作，没有返回值\n1234567fn foo() &#123;  // ❌ 首先 let y = 1; 是个语句，没有返回值，且（）中加表达式只能在 if、while 条件判断下使用  let x = (let y = 1);    // 等同于 let x = 1; let y = 1;  let x = y = 1;&#125;\n\n流程控制 Control Flow条件控制 ifif 表达式的条件（condition）必须是 bool 类型\n123456let number = 3;// ❌ error[E0308]: mismatched types, expected `bool`, found integer&quot;if number &#123;  println!(&quot;Never print: expected `bool`, found integer&quot;);&#125;\n\nif or else 表达式后紧跟的代码块被称为 arms，和 match 表达式的 arms 一致\nif 表达式的代码块最后一行若是表达式，即为当前块的返回值\n若是多个 if...else if 每个代码块的返回值类型需要一致\n123456789101112131415161718fn if_else_expressions() -&gt; () &#123;    let number = 55;    const NOT_MATCHED_MESSAGE: &amp;str = &quot;Not Matched&quot;;    let message = if number % 4 == 0 &#123;        &quot;Divide by 4&quot;    &#125; else if number % 3 == 0 &#123;        &quot;Divide by 3&quot;    &#125; else if number % 2 == 0 &#123;        &quot;Divide by 2&quot;    &#125; else &#123;        NOT_MATCHED_MESSAGE    &#125;;    if message != NOT_MATCHED_MESSAGE &#123;        println!(&quot;&#123;&#125;&quot;, message);    &#125;&#125;\n\n todo()! 表示延迟实现当前代码块，和占位符概念类似，即可以跳过类型检查\n123fn foo() &#123;  todo()!;&#125;\n\n循环 Looplooploop 加大括号声明循环（代码块可以有返回值），continue 跳出本次循环，break 跳出并终止整个循环，\n12345678910111213fn loop_expressions() -&gt; () &#123;    let mut counter = 0;    let result = loop &#123;        counter += 1;        if counter == 10 &#123;            break counter * 10; // 终止循环，并有返回值        &#125;    &#125;;    println!(&quot;&#123;&#125;&quot;, result);&#125;\n\n嵌套循环，用 单引号 + label 的格式命名，break LOOP_NAME 跳出对应循环\n123456789101112131415161718192021222324fn nested_loops() -&gt; () &#123;    let mut count = 0;    &#x27;counting_up: loop &#123;        println!(&quot;count = &#123;&#125;&quot;, count);        let mut remaining = 10;        loop &#123;            println!(&quot;remaining = &#123;&#125;&quot;, remaining);            if remaining == 9 &#123;                break; // 结束并跳出当前循环            &#125;            if count == 2 &#123;                break &#x27;counting_up; // 结束并跳出 &#x27;counting_up 循环            &#125;            remaining -= 1;        &#125;        count += 1;    &#125;&#125;\n\nwhile如果需要判断某些条件的循环，可以使用 while 更方便\n123456789fn while_case() -&gt; () &#123;    let mut count = 1;    while count &lt; 12 &#123;        count += 1;    &#125;    println!(&quot;count = &#123;&#125;&quot;, count);&#125;\n\nforfor loop 遍历数组\n123456789101112131415161718192021222324252627282930313233343536// loop in arrayfn for_loop() -&gt; () &#123;    let a = [10, 20, 30, 40, 50];    for e in a &#123;        println!(&quot;i=&#123;&#125;&quot;, e);    &#125;   // 1..=5 快速创建一个1-5的    for n in 1..=5 &#123;        println!(&quot;n=&#123;&#125;&quot;, n);    &#125;     // (1..=5).rev() 快速创建一个5-1倒序的数组    for n in (1..=5).rev() &#123;        println!(&quot;n=&#123;&#125;&quot;, n);    &#125;&#125;// loop in vectorfn vector_case() -&gt; () &#123;    let mut v = vec![1, 2, 3];    // 表示并非所有权转移，&amp; 表示借用，借用是只读    for vv in &amp;mut v &#123;        // vv 是对 v 中的某个 vector 的引用，        // 引用的本质是一个指针，指针不能直接和值进行比较，        // 需要加 *号 解引用，解引用就表示该引用变量的值        if *vv == 1 &#123;            *vv = 5;        &#125;        println!(&quot;v=&#123;&#125;&quot;, vv);    &#125;    println!(&quot;&#123;&#125;&quot;, v[0]);&#125;\n\n所有权 Ownership所有权是控制一个 Rust 程序如何管理内存的一套规则。所有程序都要有管理它们在运行时使用计算机内存的方式。\n内存管理方式 Memory Management常见的内存管理方式：\n\n垃圾回收（Garbage Collection）：如 JavaScript、Java 这种动态语言，语言层面设计了一套内存回收机制，垃圾回收器会持续追踪内存的分配并定期找到不再被使用的内存进行释放回收，让开发者无需去关心内存的分配和回收\n手动管理（Manual Management）：如 C、C++ 这种静态语言，需要手动调用分配和释放内存的方法进行操作，这让开发者需要对内存的分配及释放负责，忘记释放会导致内存浪费，太早释放又会导致获得无效的变量\n\n第三种 —— Rust 使用的内存管理方式：所有权系统（Ownership System）\n\n所有者（ower）指的是这块内存（memory）是属于谁的，包括访问和修改的能力\n每个值都有一个所有者，任何时候都只能有一个有效所有者\n当所有者离开作用域（scope），值会被丢弃（drop）\n遵循所有权系统规则，编译器在编译时通过静态分析管理内存安全，违背规则的程序不会通过编译\n通过借用（borrowing，即引用）机制来共享数据\n\n🎯 TODO：内存分配方式 Memory Allocation\n栈（Stack）：连续的内存空间，从低地址到高地址逐步分配，简单数据类型会被直接存储在栈上，便于操作\n堆（Heap）：非连续内存空间，申请多少大小空间就一次性分配多少，会通过一个指针指向这一块内存空间，复杂数据类型的值会在堆上开辟对应的空间存放，而栈上对应的这个变量存的是与这块内存相关的指针信息，即内存地址（adress）、大小（Capacity）、长度（Length）\nStatic：blahblahblah…\n\n转移 或 复制 Move or Copy基于不同的内存分配方式，针对数据和变量之间的赋值操作，在 Rust 中也会有两种表现情况：\n\n简单数据类型：一般是固定大小的数据，值存放在栈上，赋值是对值的拷贝（copy）\n复杂数据类型：一般为非固定大小数据，值被存放在堆上，该内存一旦分配，赋值的操作默认被看做为转移（move），即将该内存的所有权转移给某个变量\n\n12345678// copylet a: i32 = 1;let b = a; // directly copy 1// movelet a: String = String::from(&quot;Hello&quot;);let b = a; // move the ownership of &quot;Hello&quot; from a to b// current, a is considered as transferred, which means it&#x27;s no longer needed\n\n其实可以简单理解，转移（move）是所有权（ownership）系统实现 “内存所有者只能有一个” 的一种规则机制，这个机制防止出现数据竞争的可能 —— 多个线程对统一资源进行访问和修改，从而导致程序结果与期望不符。本身具有所有权的变量本质是存在栈上的某个指针类型变量，它的作用是为了指向堆中的某块内存，所以一经转移，相当于指针不再指向这块内存，这个变量就不再有效了，即不可以再被访问。\n所有权和生命周期（Lifetimes）所有权是指某块内存的所有者，所有者是某个变量，而变量的生命周期和所在作用域相关，在某个作用域下定义的变量只能在该作用域下使用。所有权也有着相应的限制，变量在某个作用域（scope）内被分配到对应数据的内存，在离开作用域后，变量会变得无效，它会交还对某个数据内存的所有权，则该“无主”的数据内存会被视为不再需要的，会触发自动释放内存的机制，也就是回收内存。\n12345fn foo() &#123;  let s = String::from(&quot;Hello&quot;); // s is valid from this point  // s is the owner of the string &quot;Hello&quot;&#125; // this scope is over now, s and string &quot;Hello&quot; are not valid// the data is not valid means it is no longer needed, which will trigger the step of freeing memory\n\n当变量被传入某个函数，也是发生了转移操作，意味着数据的所有权被传递给了函数，函数外已经没有权利访问和修改该变量所指的数据。如下例子：\n\n第一步，s 拥有了 string &quot;Hello&quot; 的所有权\n第二步，将 string &quot;Hello&quot; 的所有权转移给了 carry_params 函数\n而 carry_params 没有对参数 s 做任何处理，那么在函数执行完毕后，离开作用域，入参 s 对应也不再有效，对应占用的数据内存会被释放\n第三步，我们再打印 s 就会得到值已被转移了，即无权访问的编译错误提示\n拥有所有权的作用所有权是指对某块内存的所有，即拥有读写这块内存的权力，当我们需要修改某个数据时，我们就需要拥有其所有权，才能有修改的能力。而当我们只需要读，而不需要写，那就不必拥有或者转移其所有权。可以看到，有了所有权规则的加持，代码变得更加安全但也因此增加了书写代码的难度。\n上面提到如果我们不需要获得某个数据的所有权，只是想要访问值，可以用另一个概念 —— 借用（borrow）。\n借用 Borrow当我们不需要数据的所有权时，我们使用借用来访问数据的值，借用分为两种：\n\nborrow：不可变的借用，我只是把数据借给你用 &amp;T\nborrow mutably：可变的借用，我不仅把数据借给你用，且给你修改它的权限 &amp;mut T，这种借用也可以被叫做引用（reference）\n\n其实可以理解为，&amp; 给了读数据的权力，&amp;mut  在读的基础上给了写的权力，但数据（也就是这块内存）的拥有者并没有变。\n123456789101112131415161718192021222324252627282930313233fn str_and_string() &#123;    // 普通文本字符串 string literals    let normal_str = &quot;hello, &quot;;    // 可操作的、拥有所有权的 String 类型字符串    let mut mutable_string = String::from(normal_str);   // a string slice of String,    // 借用（引用） &quot;hello, &quot;，没有修改字符串的需求    let slice = &amp;mutable_string[..];    println!(&quot;slice = &#123;&#125;&quot;, slice);    // 借用对象 和 被借用对象 都是指向同一块内存，所以相等    assert_eq!(slice, mutable_string);    // 1️⃣ 默认借用，只需要借用字符串的值，不涉及所有权    only_use_text(&amp;mutable_string);   // 2️⃣ 可变的借用，不仅可以访问值，还给了修改值的权力   // 需要声明 &amp;mut 才能修改字符串    do_some_mutation(&amp;mut mutable_string);    println!(&quot;mutable_string = &#123;&#125;&quot;, mutable_string);&#125;fn do_some_mutation(input: &amp;mut String) &#123;    input.replace_range(0..1, &quot;H&quot;);    input.push_str(&quot;add this to the end&quot;);&#125;fn only_use_text(input: &amp;String) &#123;    let hello = &amp;input[..=6];    let world = &quot;world&quot;;    println!(&quot;greet = &#123;&#125;&quot;, [hello, world].concat());&#125;\n\n🎯 TODO：生命周期 LifetimesNLL —— Non-Lexical LifetimesDangling Referencing 悬垂引用指的是一个变量是有效状态的时间，即可以被使用的时长，通常也被叫做存活（live）时间。\n生命周期是 Rust 用来保证引用有效性的机制。生命周期注解允许编译器推断引用的有效范围，确保在引用仍然有效的时候使用它们。\n在 Rust 中，一个变量的存活时间与其作用域（scope）和是否还存在被使用（引用 references）有关。\n\n作用域规则决定了一个变量能否被访问，在某个作用域下定义的变量也只在这个作用域内有效，即离开作用域后无法被访问，会自动被销毁。\n\n当编译器检查到一个变量不再存在任何被引用被借用关系后，该变量也会被自动销毁。\n\n\n12345let x :i32 = 5;// 存在被使用println!(&quot;x = &#123;&#125;&quot;, x); // after this line, x has no more references, will be automatically destroyedlet y :i32 = 6;\n\n借用规则 Borrow Rules\n一个变量只能存在一个可变引用或者多个不可变引用，不能同时存在可变和不可变引用\n\n借用检查器 Borrow Checker前面说了，借用是用于不关心所有权的场景下的，那没有所有权就意味着我需要依赖被我借用的那个变量，当它不合法时、无效时，那我的借用行为也是不可能通过的。Borrow Checker 便是在编译时，检查借用是否合法，即被借用的变量是否还在有效的生命周期内。结合前面提到的所有权的生命周期，来看下截图上的例子：\n\n可以看到报错部分说的是被借用值 x 存活的不够长，重点看下黄色框内，模拟画的作用域结构图。\n\nr 在 a 作用域中创建，即它存活在作用域 a 存活的期间，即 foo 函数执行期间\nx 在 b 作用域中创建，即它存活在作用域 b 存活的期间，作用域 b 是个 block 作用域，在它执行完成后内部变量都会自动释放，即 x 在作用域 b 外无效\n\n因为 r 是个借用类型，Borrow Checker 会检查被借用变量是否是有效的，当发现被借用变量的生命周期小于借用变量的生命周期，即 x 的生命周期小于 r 的生命周期，这是不合法的 —— 报错。所以如果是存在借用关系的两个变量，那么被借用变量的存活时间一定要比借用变量存活的时间更长，存活时间更长可以归纳为两种情况：\n\n相同作用域范围下，被借用变量定义早于借用变量\n借用变量的作用域层级深于被借用变量（越深销毁越早）\n\n📸 TODO 手动管理可能会遇到的问题内存泄露\n悬空指针\n缓冲区溢出\n泛型（Generics）和特质（Traits）MatchOption1234// `unwrap()`: 有值的时候会取值，没值的时候会 `panic`let mut s = String::from(&quot;hello&quot;);let p1 = s.pop().unwrap();println!(&quot;&#123;&#125;&quot;, p1);\n\n返回值与错误处理可恢复的错误 Result&lt;T, E&gt;从系统全局角度来看是可以接受的错误，这些错误只会影响某个用户自身的操作进程，一般是逻辑层面上的错误（业务逻辑、操作逻辑），不会对系统的全局稳定性产生影响。\n使用 Result 返回值不可恢复的错误 panic!全局性或者系统性的错误，列入数组越界访问、影响启动流程的错误等等，这些错误是影响系统流程的。\n主动触发 panicRust 提供了 panic! 宏，当调用执行该宏时，程序会打印出一个错误信息，展开报错点前面的函数调用堆栈，最后退出程序。\n123fn main() &#123;  panic!(&quot;crash and burn&quot;);&#125;\n\nbacktrace 栈展开默认程序执行调用栈输出是开启 --debug 的时候才会展示，可以通过 RUST_BACKTRACE=1 cargo run 来手动开启调用栈回溯。\n栈展开也称栈回溯，包含了函数调用的顺序，按照逆序排列：最近调用的函数在列表最上方。\nunwrap 方法\nOption : 有值的时候会取值，没值的时候会调用 panic!\nResult : Ok 会返回 Ok 中的值，Err 会为我们调用 panic!\n\n123let arr = [1, 2, 3, 4];let a = first(&amp;arr).unwrap();println!(&quot;The first element is &#123;&#125;&quot;, a);\n\nexpect 方法用于设置预期的 panic 错误文案\n12let file = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);println!(&quot;&#123;:?&#125;&quot;, file);\n\n传播错误unwrap 方法在遇到错误情况下都会直接调用 panic! 从而会直接终止程序的进行，但很多情况下我们遇到的都是预期内的错误情况，并不需要终止，只需要将错误向上传播，这时我们就不用使用 unwrap 方法。取而代之，通常使用 ? 链式调用传播错误，它的功能是问号前的表达式执行结果成功则继续向后执行，若结果失败或者说错误，则截停执行逻辑到当前表达式为止并将错误返回，此时如果前一个表达式设置了错误 callback 等类似的处理，就能触发相应的逻辑。\nOption 和 Result 的互转Result 有两个结果 Ok 和 Err，Option 包含 Some 和 None\n\nResult 转 Option，转换即将 ok 和 err 都转为 Some\n\nerr(): Err -&gt; Some\n\nok(): Ok -&gt; Some\n\n\n\n\n123456789let f = File::open(&quot;hello.txt&quot;).err();if f.is_some() &#123;    println!(&quot;no file&quot;);&#125; let f = File::open(&quot;hello.txt&quot;).ok();if f.is_none() &#123;    println!(&quot;no file&quot;);&#125;\n\n\nOption 转 Result\n\nok_or()\n\n\n\n","slug":"rust-basic","date":"2024-10-22T16:00:00.000Z","categories_index":"","tags_index":"rust","author_index":"Marnie"}]