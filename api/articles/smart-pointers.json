{"title":"智能指针 Smart Pointers","uid":"2e2bd34ffcfc46d5575f7c18eed689f5","slug":"smart-pointers","date":"2024-10-24T07:41:13.000Z","updated":"2025-01-13T14:30:07.336Z","comments":true,"path":"api/articles/smart-pointers.json","keywords":"","cover":[],"content":"<p>首先理解，指针是什么？指针是一个存储了内存地址（memory address）的变量，该内存地址引用或者指向了内存中另外的数据。</p>\n<p>在 Rust 中最常见的指针就是引用（reference），引用变量向被它引用的变量借用（borrow）它指向的数据，这意味着它们自身是没有对该数据的所有权（ownership）的。</p>\n<p>引用只包含一个指向被引用变量的指针，除此之外，引用就再无其他功能了。而 Rust 是静态编译语言，在编译期间就需要确定变量数据的大小以及何时释放。所以设计了智能指针，在普通指针的基础上，还包含了当前长度（len）、最大长度（capacity）等字段，这些都是用来确定指针类型指向的那块数据所需的内存 size 的字段。像是我们之前用过的 <code>String</code> 、<code>Vec</code> 都是智能指针数据类型。</p>\n<p>不同于普通指针，智能指针是具有所有权的指针，且实现了 Deref（解引用）和 Drop（清理）两个 trait（特征），这使得他们可以像指针一样解引用并在离开作用域是自动清理资源。这是对智能指针是什么的一个大致概括，具体功能可以通过后面更多的实际例子去理解更为自然。</p>\n<h3 id=\"为什么存在智能指针？\"><a href=\"#为什么存在智能指针？\" class=\"headerlink\" title=\"为什么存在智能指针？\"></a>为什么存在智能指针？</h3><h4 id=\"性能管理-—-处理大体量的数据\"><a href=\"#性能管理-—-处理大体量的数据\" class=\"headerlink\" title=\"性能管理 — 处理大体量的数据\"></a>性能管理 — 处理大体量的数据</h4><p>栈是我们用于快速读写的内存空间，并不适合存储过大的数据。相对来说，简单的数据类型会被分配在栈上，但针对简单却大体量数据，我们就不应该再继续存储在栈上了，栈溢出会引起程序的崩溃。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">大体量数据，长度为 1_000_000 的数组，数组默认是分配的栈内存</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">arr_stack</span> = [<span class=\"number\">0</span>; <span class=\"number\">1000000</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> arr_stack &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行代码，我们会得到如下报错：</p>\n<p><img src=\"/images/image-20241031162223186.png\" alt=\"image-20241031162223186\"></p>\n<p>正如前面所说 —— 栈溢出，程序中止运行了。</p>\n<h4 id=\"处理更复杂的数据结构\"><a href=\"#处理更复杂的数据结构\" class=\"headerlink\" title=\"处理更复杂的数据结构\"></a>处理更复杂的数据结构</h4><p>Rust 是静态编译语言，这意味着它在编译时期就是需要知道每个数据所需内存大小，而针对一些复杂的数据结构，如递归结构、分享结构【❓TODO 这是啥】等，是没有固定大小的，而智能指针就是为了解决这一问题设计的。</p>\n<p>举个例子，常规 <code>enum</code> ，因为一次只会使用 <code>enum</code> 的某一个值，所以该 <code>enum</code> 的所需内存大小取决于其下面内存占用最大的一个枚举值。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Message</span> &#123;</span><br><span class=\"line\">  Quit,</span><br><span class=\"line\">  Move &#123; x: <span class=\"type\">i32</span>, y: <span class=\"type\">i32</span> &#125;,</span><br><span class=\"line\">  <span class=\"title function_ invoke__\">Write</span>(<span class=\"type\">String</span>),</span><br><span class=\"line\">  <span class=\"title function_ invoke__\">ChangeColor</span>(<span class=\"type\">i32</span>, <span class=\"type\">i32</span>, <span class=\"type\">i32</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// enum Message 中所需内存最大的是 ChangeColor，</span></span><br><span class=\"line\"><span class=\"comment\">// 则该 enum 所需内存为 ChangeColor 所需的内存大小</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Message::Quit;</span><br></pre></td></tr></table></figure>\n\n<p>更复杂的数据结构，递归 <code>enum</code> 类型</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, List), <span class=\"comment\">// 动态大小，无法确定 size</span></span><br><span class=\"line\">  Nil,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于递归 <code>enum</code> 来说，基于我们前面计算 <code>enum</code> 大小的方式，会发现我们并不能知道哪个是内存大小最大的枚举值，递归的枚举值是动态的，所以我们无法得出递归类型的数据大小。</p>\n<h4 id=\"【TODO】在普通指针基础上，完善更多的功能\"><a href=\"#【TODO】在普通指针基础上，完善更多的功能\" class=\"headerlink\" title=\"【TODO】在普通指针基础上，完善更多的功能\"></a>【TODO】在普通指针基础上，完善更多的功能</h4><p>❓TODO：所有权、悬垂指针、动态大小？</p>\n<h4 id=\"【TODO】RC-智能指针\"><a href=\"#【TODO】RC-智能指针\" class=\"headerlink\" title=\"【TODO】RC 智能指针\"></a>【TODO】RC 智能指针</h4><p>智能指针是 Rust 确保其安全性的一种方式。智能指针是一种包裹了数据和提供了一些额外功能的数据结构，例如所有权（ownership）和引用计数（reference counting）。Rust 设计了多种智能指针的数据类型，适用于多种不同的场景。</p>\n<h3 id=\"Box-Smart-Pointer\"><a href=\"#Box-Smart-Pointer\" class=\"headerlink\" title=\"Box Smart Pointer\"></a>Box Smart Pointer</h3><p>Box 智能指针是 Rust 中智能指针的一种，它是在栈上拥有固定大小的指针，但其指向的数据，在堆上可以是任意大小的数据。所以当我们使用了 Box 智能指针，我们是可以在编译时就知道所需内存大小的。因此上面说到的编译时无法计算内存大小的问题，便就迎刃而解了。</p>\n<p>我们将改写上面递归 <code>enum</code> 的例子，用 Box 智能指针来解决问题：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将递归嵌套的 List 类型改写成 Box&lt;List&gt; 智能指针类型</span></span><br><span class=\"line\"><span class=\"comment\">// 智能指针在栈侧是拥有固定大小的指针，可以顺利通过编译</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, <span class=\"type\">Box</span>&lt;List&gt;),</span><br><span class=\"line\">  Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> List::&#123; Cons, Nil &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Box::new() 创建 Box 智能指针类型变量</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"variable\">list</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">1</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">2</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">3</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(Nil)))));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>智能指针之所以功能强大，还因为 Rust 为其实现了两种特征（trait），Deref Trait 和 Drop Trait，让我们一起了解下。</p>\n<h3 id=\"The-Deref-Trait\"><a href=\"#The-Deref-Trait\" class=\"headerlink\" title=\"The Deref Trait\"></a>The Deref Trait</h3><p>Deref Trait 解引用是为了让智能指针能像普通指针一样使用而实现的特征（trait）。这句话有两个关键点：</p>\n<ol>\n<li><p>什么是 trait（特征）？</p>\n</li>\n<li><p>什么叫像普通指针一样使用？</p>\n</li>\n</ol>\n<p>我们逐一了解一下：）</p>\n<h4 id=\"Traits-特征\"><a href=\"#Traits-特征\" class=\"headerlink\" title=\"Traits 特征\"></a>Traits 特征</h4><p> 特征（traits）是 Rust 设计出可以让不同类型拥有相同行为（behavior）的一种实现，在描述某种或者说某类行为时可以包含1个或者多个方法（methods），即特征就是我们用来使得不同类型能够共享（sharing）同一批方法的手段。</p>\n<p>我们看一下 trait 的例子：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"title class_\">TraitA</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">fn</span> <span class=\"title function_\">method_A</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span>;</span><br><span class=\"line\">  <span class=\"keyword\">fn</span> <span class=\"title function_\">method_B</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般我们描述 trait 时，会包含一个或多个方法的签名，如果对方法写了具体实现，则作为该方法的默认行为。我们也可以在具体类型上重写（overwrite）特征下的方法，来自定义不同类型上的实现。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">StructA</span> &#123;</span><br><span class=\"line\">    name: <span class=\"type\">String</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// once impl A for B means B is shared with all methods in A</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">TraitA</span> <span class=\"keyword\">for</span> <span class=\"title class_\">StructA</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// overwrite method_A of trait TraitA</span></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">method_a</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>([<span class=\"string\">&quot;I&#x27;m&quot;</span>, &amp;<span class=\"keyword\">self</span>.name].<span class=\"title function_ invoke__\">join</span>(<span class=\"string\">&quot; &quot;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = StructA &#123;</span><br><span class=\"line\">    name: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;aaa&quot;</span>),</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// call the methods of trait</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"variable\">name</span> = a.<span class=\"title function_ invoke__\">method_a</span>();</span><br><span class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, name);</span><br><span class=\"line\">  </span><br><span class=\"line\">  a.<span class=\"title function_ invoke__\">method_b</span>(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Rust 定义很多内置的特征，并为我们提供了 <code>derive</code> 属性，用于在一个 struct 或 enum 上生成对某个 trait 的实现的相关代码，这里的代码就是将该 trait 所拥有的默认实现复制过来。这样我们就能快速的拥有一个 trait 的所有默认行为，内置的特征需要通过 <code>use xxx</code> 导入之后使用。</p>\n<h4 id=\"像普通指针一样使用\"><a href=\"#像普通指针一样使用\" class=\"headerlink\" title=\"像普通指针一样使用\"></a>像普通指针一样使用</h4><p>其实指的就是，可以对于指针变量使用 <code>*</code> 操作符，我们知道因为所有权的关系，我们只能对指针类型的变量进行借用：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// String</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">y</span> = &amp;x; <span class=\"comment\">// &amp;String</span></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;</span>, x, y, x == y); <span class=\"comment\">// ❌ [ERROR] can&#x27;t compare `String` with `&amp;String`.</span></span><br></pre></td></tr></table></figure>\n\n<p>这里编译会报错，因为第 3 行无法将不同类型的两个值进行比较，x 是 String 类型，而 y 是 a reference to String。</p>\n<p>y 就是借用了 x，借用就意味着其实就只是拿到了一个内存地址，那么当我们需要直接使用数据时（如：上面做比较的场景 x &#x3D;&#x3D; y）就需要用 <code>*</code> 操作符做解引用，拿到内存地址对应的数据：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// String</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">y</span> = &amp;x; <span class=\"comment\">// &amp;String</span></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;</span>, x, y, x == *y); <span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p>除了 <code>*</code> 操作符实现了 deref，还有包括我们经常使用的 <code>.</code> 操作符，是默认带有解引用功能的，通过例子看一下：</p>\n<p><img src=\"/images/image-20241107133927309.png\" alt=\"image-20241107133927309\"></p>\n<p>可以看到，当我们在使用 <code>.</code> 操作符时，会得到自动解引用之后的结果（倒数第 2 行），并且最后一行我们看到，无论是多加了多少层的引用，都能得到最终指向的那块数据。这就是 <code>.</code> 操作符上带有的魔法之一 —— 自动解引用。</p>\n<p>为了更好的理解解引用特征，我们手动还原一个自己的 <code>MyBox</code> 智能指针类型。</p>\n<h4 id=\"手动还原-Box-智能指针\"><a href=\"#手动还原-Box-智能指针\" class=\"headerlink\" title=\"手动还原 Box 智能指针\"></a>手动还原 Box 智能指针</h4><p>首先，<code>MyBox</code> 是一个结构体，它只有一个字段 —— 被他包裹的类型，且不需要字段名，即我们采用<strong>元组结构体</strong>（tuple struct）构造 <code>MyBox</code>。这里还需要使用泛型 <code>T</code>，被包裹的类型是由调用的时候传入的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这一部分需要补充泛型（generics）的内容，可以参考 <a href=\"https://course.rs/basic/trait/generic.html\">https://course.rs/basic/trait/generic.html</a></p></blockquote>\n<p>使用泛型的规范是，先声明 <code>xxx&lt;T&gt;</code> 后使用 <code>structNameXXX(T)、functionNameXXX(x: T)</code> 等。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyBox</span>&lt;T&gt;(T);</span><br></pre></td></tr></table></figure>\n\n<p>接着实现 <code>new</code> 方法，在 Rust 中使用 <code>impl</code> 来定义方法，如 <code>impl Circle</code> ，泛型用 <code>impl&lt;T&gt; Circle&lt;T&gt;</code> 。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(x: T) <span class=\"punctuation\">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">MyBox</span>(x)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下一步，在 <code>MyBox</code> 上实现 <code>deref trait</code> ，可以参考官网 <code>Deref Trait</code> 给出的示例实现：</p>\n<p><img src=\"/images/image-20241108213447782.png\" alt=\"image-20241108213447782\"></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; Deref <span class=\"keyword\">for</span> <span class=\"title class_\">MyBox</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> <span class=\"title class_\">Target</span> = T;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">deref</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"keyword\">Self</span>::Target &#123; <span class=\"comment\">// Target 就是目标类型 T</span></span><br><span class=\"line\">        &amp;<span class=\"keyword\">self</span>.<span class=\"number\">0</span> <span class=\"comment\">// 因为 MyBox 是元组结构体，对应的值 self.0</span></span><br><span class=\"line\">    &#125;  <span class=\"comment\">// 注意：解引用并不会涉及所有权转移，返回的值还是一个引用值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在我们就可以在 MyBox 类型变量上使用解引用功能了，让我们试下:</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">n</span> = MyBox::<span class=\"title function_ invoke__\">new</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Marnie&quot;</span>));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Marnie&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;</span>, a, *n, a == *n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/image-20241108224953665.png\" alt=\"image-20241108224953665\"></p>\n<p>以上就是模拟 MyBox 并实现 Deref Trait 的大致过程，当我们使用 <code>*v</code> 时，就会去 <code>v</code> 对应的类型 <code>T</code> 上找 <code>deref</code> 方法，即 <code>*(v.deref())</code>，所以但凡是实现了 <code>Deref Trait</code> 的类型变量都可以使用 <code>*</code> 操作符来解引用。</p>\n<p>在官网关于”使用 Deref Trait 将智能指针像常规引用一样对待”有很详细的介绍，细节可以更多的参考 <a href=\"https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait\">https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait</a>，这里再提一点比较重要的内容：</p>\n<h4 id=\"Implicit-Deref-Coerions-隐式的强制解引用\"><a href=\"#Implicit-Deref-Coerions-隐式的强制解引用\" class=\"headerlink\" title=\"Implicit Deref Coerions 隐式的强制解引用\"></a>Implicit Deref Coerions 隐式的强制解引用</h4><p>在 Deref Trait 相关内容下，有一个知识点叫 Deref coerion 强制解引用，意思是在某些场景下，Rust 会自动发生解引用。</p>\n<p>这里会发生自动解引用的场景是在变量作为参数传入方法 methods 或者函数 functions 时，若传入变量类型实现了 Deref Trait，变会发生自动解引用的行为。我们分析看下官方的例子：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">hello</span>(name: &amp;<span class=\"type\">str</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里写了一个 <code>hello</code> 函数，接收 string slice 类型的参数，如果我们继续用前面 <code>MyBox</code> 的实例 <code>n</code> 传入 <code>hello</code> 函数 <code>hello(&amp;n)</code>，如：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">n</span> = MyBox::<span class=\"title function_ invoke__\">new</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Marnie&quot;</span>)); <span class=\"comment\">// MyBox&lt;String&gt;</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">hello</span>(&amp;n); <span class=\"comment\">// 🤔...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们会发现，编辑器并没有提示任何编译错误，这里就是强制解引用的作用。</p>\n<p>首先，我们传入的 <code>n</code> 本身是个 <code>MyBox&lt;String&gt;</code> 类型，按照强制解引用的发生规则 —— 当我们将某个类型作为参数传入函数或者方法时，会自动发生解引用。<code>MyBox</code>类型的解引用实现我们前面已经还原了，那么这一步强制解引用就相当于调用 <code>n.deref()</code>，则 <code>&amp;n</code> 从 <code>&amp;MyBox&lt;String&gt;</code> -&gt; <code>&amp;String</code>，这么看起来还是不对呀，目标参数接收的是 <code>String Slice</code>，现在还只是 <code>String</code>。好，这里注意 📢，当类型上实现了 Deref Trait 的话强制解引用会一直继续自动发生，即可能发生连续的解引用。</p>\n<p>我们上一步强制解引用得到的是类型 <code>String</code>，在标准库里 <code>String</code> 也对应实现了 <code>Deref Trait</code> ，所以会再次做强制解引用，我们可以查看官网看到标准库中对于 <code>String</code> 上 <code>Deref Trait</code> 实现的签名描述：</p>\n<p><img src=\"/images/image-20241108233250046.png\" alt=\"image-20241108233250046\"></p>\n<p>可以看到 <code>String</code> 的 <code>deref</code> 方法返回 <code>string slice</code> 类型，所以才满足了 <code>hello</code> 函数，并不会有编译问题。</p>\n<p>关于这个连续强制解引用，我尝试再用一些自定义的类型例子来验证一下是否如此：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::ops::Deref;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TypeA</span>(<span class=\"type\">i32</span>); <span class=\"comment\">// i32</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TypeB</span>(TypeA); <span class=\"comment\">// TypeA</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TypeC</span>(TypeB); <span class=\"comment\">// TypeB</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Deref</span> <span class=\"keyword\">for</span> <span class=\"title class_\">TypeA</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> <span class=\"title class_\">Target</span> = <span class=\"type\">i32</span>;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">deref</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"keyword\">Self</span>::Target &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;calling TypeA&#x27;s deref&quot;</span>);</span><br><span class=\"line\">        &amp;<span class=\"keyword\">self</span>.<span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Deref</span> <span class=\"keyword\">for</span> <span class=\"title class_\">TypeB</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> <span class=\"title class_\">Target</span> = TypeA;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">deref</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"keyword\">Self</span>::Target &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;calling TypeB&#x27;s deref&quot;</span>);</span><br><span class=\"line\">        &amp;<span class=\"keyword\">self</span>.<span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Deref</span> <span class=\"keyword\">for</span> <span class=\"title class_\">TypeC</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> <span class=\"title class_\">Target</span> = TypeB;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">deref</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"keyword\">Self</span>::Target &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;calling TypeC&#x27;s deref&quot;</span>);</span><br><span class=\"line\">        &amp;<span class=\"keyword\">self</span>.<span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">test</span>(x: &amp;<span class=\"type\">i32</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;I get &#123;&#125;&quot;</span>, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = <span class=\"title function_ invoke__\">TypeA</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = <span class=\"title function_ invoke__\">TypeB</span>(a);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = <span class=\"title function_ invoke__\">TypeC</span>(b);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"title function_ invoke__\">test</span>(&amp;c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我写了上述的这些代码，企图验证是否会有连续的强制解引用发生。按照我上个段落的结论，我预想的 将 <code>c</code> 作为参数传入 <code>test</code> 函数，<code>c</code> 的类型 <code>TypeC</code> 上又有 <code>deref trait</code> 的实现，那么连续的强制解引用将会是 <code>TypeC -&gt; TypeB, TypeC -&gt; TypeA, TypeA -&gt; i32</code>，我们可以看到编译器首先并没有提示类型错误，我们再运行看看：</p>\n<p><img src=\"/images/image-20241109000000451.png\" alt=\"image-20241109000000451\"></p>\n<p>如结果所示，印证了预想，那么这就是一个连续的强制解引用的过程。Rust 之所依提供这个隐含的功能就是为了让我们省去手动做”连续的类型转换”的过程。我们再强调一下，这个强制类型转换发生需要符合的条件：</p>\n<ol>\n<li><code>&amp;T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt;</code>  T 上有返回类型为 U 的解引用实现</li>\n<li><code>&amp;mut T -&gt; &amp;mut U ===&gt; T: DerefMut&lt;Target=U&gt;</code>  T 上有返回类型为 U 的可变解引用实现</li>\n<li><code>&amp;mut T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt;</code> T 上有返回类型为 U 的解引用实现（可变的类型可以转换为不可变类型，但不可变不能转换成可变）</li>\n</ol>\n<h3 id=\"The-Drop-Trait\"><a href=\"#The-Drop-Trait\" class=\"headerlink\" title=\"The Drop Trait\"></a>The Drop Trait</h3><p>除了 Deref Trait 外，智能指针还拥有 Drop Trait。Drop Trait 是 Rust 设计用于内存管理的特征，当一个变量超出 scope 之后，自动释放其占用的内存。Drop Trait 的实现和 Deref Trait 异曲同工，本质也是执行该 Trait 下对应的 <code>drop method</code> , 当我们需要自定义释放内存的场景就可以手动实现 <code>drop method</code> ，让我们一样用例子看一下：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::ops::<span class=\"built_in\">Drop</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CustomSmartPointer</span> &#123;</span><br><span class=\"line\">    data: <span class=\"type\">String</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Drop</span> <span class=\"keyword\">for</span> <span class=\"title class_\">CustomSmartPointer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">drop</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;CustomSmartPointer of data &#123;&#125; is dropping...&quot;</span>, <span class=\"keyword\">self</span>.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c1</span> = CustomSmartPointer &#123;</span><br><span class=\"line\">        data: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;c1&quot;</span>),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125; is created.&quot;</span>, c1);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c2</span> = CustomSmartPointer &#123;</span><br><span class=\"line\">        data: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;c2&quot;</span>),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125; is created.&quot;</span>, c2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<p><img src=\"/images/image-20241109131227963.png\" alt=\"image-20241109131227963\"></p>\n<p>结合所有权系统，当一个变量离开作用域以及不存在对其的任何引用，Rust 会自动释放变量占用的内存，这样就无需开发者手动管理内存。我们上面的代码就可以看到这个效果，内存释放是按照变量出栈顺序，即先进后出，创建顺序是 <code>c1 -&gt; c2</code>，销毁顺序则是 <code>c2 -&gt; c1</code>，如打印结果所示。</p>\n<p>这里有一点需要注意，因为 Rust 已经有一套合理管理内存的机制 —— 离开作用域内存会自动被释放，所以是不支持我们直接手动调用 <code>xxx.drop()</code> 来释放内存的，这样会导致双重释放内存的错误（a double free error）。</p>\n<h3 id=\"Trait-Objects\"><a href=\"#Trait-Objects\" class=\"headerlink\" title=\"Trait Objects\"></a>Trait Objects</h3><p>虽然 Rust 强调静态类型编译，需要有明确的数据类型，但为了实现代码的多态性，Rust 也提供了一种方案可以动态调度（dynamic dispatch）类型，它就是 <code>Trait Objects</code>。首先我们理解一下什么是动态调度：</p>\n<h4 id=\"Dynamic-dispatch-动态调度\"><a href=\"#Dynamic-dispatch-动态调度\" class=\"headerlink\" title=\"Dynamic dispatch 动态调度\"></a>Dynamic dispatch 动态调度</h4><p>动态调度表示在编译时并不知道具体类型，而是在运行时才能确定类型。它与 static dispatch 相对，static dispatch 静态调度是指在编译时就已经确定了类型，一般我们没有特别处理的都属于静态调度，变量的类型是明确的，函数的入参类型也是确定的，所有的类型都是编译时就已经固定了的。而动态调度需要使用关键字 <code>dyn</code> ，来表示这是一个动态调度类型，我们需要结合 <code>Trait Objects</code> 这个概念一起使用。</p>\n<p><code>Trait Objects</code> 是 Rust 提供应对有着同样行为的但所属不同类型的变量的事务，用官方的例子，比如我们现在要实现一个前端框架库，我们会拥有很多 <code>components</code> 组件，每个组件都是一个类型。</p>\n<p>因为组件会有很多种，比如 Button、Select、Input，我们在声明 components 类型的时候，首先它是个可以更改长度的 list，所以 <code>components: vec![???]</code>，好了，这里就有一个问题出现了！<code>vec!</code> 里面的类型并不是我们以往固定的某一种类型，它可能是 <code>Button/Input/Select</code> 等等，这种情况我们就需要使用动态调度，表示这里的类型不是某一个固定类型，是多种类型。</p>\n<p>具体使用方式，用 <code>dyn</code> 关键字表示这里是动态调度，<code>dyn</code> 后面跟的类型是一个 <code>trait</code>，<code>dyn xxxTrait</code> 则表示当前是一个 <code>trait objects</code> 类型。trait（特征）我们在上面有单独介绍，它用来描述某种行为，那么 <code>trait objects</code> 其实就是拥有同种行为的不同类型的对象，本质就是不同类型都对同一个 trait 进行了实现。我们上面这个组件的例子，就是 <code>Trait Objects</code> 的一个标准案例，组件本身都是不同的类型，但是它们都至少有某个或某些相同的行为，比如绘制功能，那么实现时就可以把绘制作为一个 trait，这些组件都有对于 绘制trait 的实现，这些组件便可以通过 <code>dyn Draw</code> 视为同一个 <code>trait object</code> 类型。但因为 <code>trait</code> 本身没有固定大小，所以它必须结合指针类型使用（指针类型拥有固定大小），如 <code>Box&lt;dyn Draw&gt;</code> 表示 <code>Draw trait objects</code> 类型。</p>\n<p>用这个场景，我们具体实现下代码来理解：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 绘制trait</span></span><br><span class=\"line\"><span class=\"keyword\">trait</span> <span class=\"title class_\">Draw</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">fn</span> <span class=\"title function_\">draw</span>(&amp;<span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Button类型</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Button</span> &#123;</span><br><span class=\"line\">  width: <span class=\"type\">u32</span>,</span><br><span class=\"line\">  height: <span class=\"type\">u32</span>,</span><br><span class=\"line\">  label: <span class=\"type\">String</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Select类型</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Select</span> &#123;</span><br><span class=\"line\">  width: <span class=\"type\">u32</span>,</span><br><span class=\"line\">  height: <span class=\"type\">u32</span>,</span><br><span class=\"line\">  options: <span class=\"type\">Vec</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 都会继承绘制trait</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Draw</span> <span class=\"keyword\">for</span> <span class=\"title class_\">Button</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">fn</span> <span class=\"title function_\">draw</span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do Button&#x27;s drawing stuff </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 都会继承绘制trait</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Draw</span> <span class=\"keyword\">for</span> <span class=\"title class_\">Select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">fn</span> <span class=\"title function_\">draw</span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do Select&#x27;s drawing stuff </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 框架库类</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Library</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// components list</span></span><br><span class=\"line\">  components: <span class=\"type\">Vec</span>&lt;<span class=\"type\">Box</span>&lt;<span class=\"keyword\">dyn</span> Draw&gt;&gt;, <span class=\"comment\">// a list of &quot;Draw trait objects&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是【动态调度 + trait objects】的使用方法，这种方式本质上其实是让我们有了可以同时使用不同的类型的能力，这就是动态调度的魔法。和泛型（generics）的不同之处就是这里，泛型只是声明时的多态，在调用时一次传入的还只是同一个类型，而动态调度是一次调用能传入多种类型，实现了真正的运行时多态。</p>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><h3 id=\"作业2\"><a href=\"#作业2\" class=\"headerlink\" title=\"作业2\"></a>作业2</h3><p><img src=\"/../images/smart-pointers/home_work_2.png\" alt=\"home_work_2\"></p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::ops::DerefMut;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> colored::Colorize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">trait</span> <span class=\"title class_\">FileSystem</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// type Output;</span></span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">create_file</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, name: &amp;<span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> &amp;Node;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">create_folder</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, name: &amp;<span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> &amp;Node;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">list_contents</span>(&amp;<span class=\"keyword\">self</span>);</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">find_folder</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, name: &amp;<span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">Option</span>&lt;&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">Self</span>&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 文件</span></span><br><span class=\"line\">        <span class=\"title function_ invoke__\">File</span>(<span class=\"type\">String</span>),</span><br><span class=\"line\">        <span class=\"comment\">// 文件夹</span></span><br><span class=\"line\">        <span class=\"title function_ invoke__\">Folder</span>(FolderNode),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">FolderNode</span> &#123;</span><br><span class=\"line\">        name: <span class=\"type\">String</span>,</span><br><span class=\"line\">        contents: <span class=\"type\">Vec</span>&lt;<span class=\"type\">Box</span>&lt;Node&gt;&gt;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">impl</span> <span class=\"title class_\">FileSystem</span> <span class=\"keyword\">for</span> <span class=\"title class_\">FolderNode</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在当前文件夹下创建单个文件</span></span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">create_file</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, name: &amp;<span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> &amp;Node &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.contents.<span class=\"title function_ invoke__\">push</span>(<span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(Node::<span class=\"title function_ invoke__\">File</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(name))));</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;/&#123;&#125; 添加文件 &#123;&#125;&quot;</span>, <span class=\"keyword\">self</span>.name, name);</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.contents.<span class=\"title function_ invoke__\">last</span>().<span class=\"title function_ invoke__\">unwrap</span>()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 在当前文件夹下创建文件夹</span></span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">create_folder</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, name: &amp;<span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> &amp;Node &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.contents.<span class=\"title function_ invoke__\">push</span>(<span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(Node::<span class=\"title function_ invoke__\">Folder</span>(FolderNode &#123;</span><br><span class=\"line\">                name: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(name),</span><br><span class=\"line\">                contents: <span class=\"built_in\">vec!</span>[],</span><br><span class=\"line\">            &#125;)));</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;/&#123;&#125; 添加文件夹 &#123;&#125;&quot;</span>, <span class=\"keyword\">self</span>.name, name);</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.contents.<span class=\"title function_ invoke__\">last</span>().<span class=\"title function_ invoke__\">unwrap</span>()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回值是一个可变的 FolderNode，因为可能需要继续修改 folder 内容</span></span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">find_folder</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, target_name: &amp;<span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">Option</span>&lt;&amp;<span class=\"keyword\">mut</span> FolderNode&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 声明返回值为可变的，初始为 None</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">target</span>: <span class=\"type\">Option</span>&lt;&amp;<span class=\"keyword\">mut</span> FolderNode&gt; = <span class=\"literal\">None</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 遍历子目录，iter_mut() 允许返回可变的遍历对象</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> <span class=\"variable\">node</span> <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.contents.<span class=\"title function_ invoke__\">iter_mut</span>() &#123;</span><br><span class=\"line\">                <span class=\"comment\">// deref_mut() 允许返回解引用后并可变的值</span></span><br><span class=\"line\">                <span class=\"keyword\">match</span> node.<span class=\"title function_ invoke__\">deref_mut</span>() &#123;</span><br><span class=\"line\">                    Node::<span class=\"title function_ invoke__\">Folder</span>(folder) =&gt; &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> folder.name == target_name &#123;</span><br><span class=\"line\">                            target = <span class=\"title function_ invoke__\">Some</span>(folder);</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    _ =&gt; &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// log error</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> target.<span class=\"title function_ invoke__\">is_none</span>() &#123;</span><br><span class=\"line\">                <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"string\">&quot;[ERR] Cannot find this folder!&quot;</span>.<span class=\"title function_ invoke__\">red</span>());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            target</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 列出文件夹下所有文件和文件夹（递归 recursion）</span></span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">list_contents</span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;======== /&#123;&#125; 当前目录结构 ========&quot;</span>, <span class=\"keyword\">self</span>.name);</span><br><span class=\"line\">            <span class=\"comment\">// print current folder name</span></span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;/&#123;&#125;&quot;</span>, <span class=\"keyword\">self</span>.name);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 打印单个 node 下的内容，因为需要打印目录结构，子目录需要使用递归</span></span><br><span class=\"line\">            <span class=\"keyword\">fn</span> <span class=\"title function_\">print_node</span>(level: <span class=\"type\">usize</span>, node: &amp;Node) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 除 root 外（非根目录），目录结构前缀逐级添加 &#x27;|[][][][]&#x27;</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">level_prefix</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">with_capacity</span>(<span class=\"number\">5</span> * level);</span><br><span class=\"line\">                <span class=\"comment\">// level &gt; 1 need append space prefix</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> <span class=\"variable\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>..(level) &#123;</span><br><span class=\"line\">                    level_prefix.<span class=\"title function_ invoke__\">push_str</span>(<span class=\"string\">&quot;|    &quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">match</span> node &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 当前 node 是文件，没有子目录</span></span><br><span class=\"line\">                    Node::<span class=\"title function_ invoke__\">File</span>(file_name) =&gt; &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// print current file name</span></span><br><span class=\"line\">                        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&#123;&#125;&quot;</span>, level_prefix, file_name);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 当前 node 是文件夹，子目录需要继续调用 print_node</span></span><br><span class=\"line\">                    Node::<span class=\"title function_ invoke__\">Folder</span>(folder) =&gt; &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// print current folder name</span></span><br><span class=\"line\">                        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;/&#123;&#125;&quot;</span>, level_prefix, folder.name);</span><br><span class=\"line\">                        folder</span><br><span class=\"line\">                            .contents</span><br><span class=\"line\">                            .<span class=\"title function_ invoke__\">iter</span>()</span><br><span class=\"line\">                            .for_each(|n| <span class=\"title function_ invoke__\">print_node</span>(level + <span class=\"number\">1</span>, n));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">match</span> <span class=\"keyword\">self</span>.contents.<span class=\"title function_ invoke__\">len</span>() &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 空文件夹</span></span><br><span class=\"line\">                <span class=\"number\">0</span> =&gt; &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 当前为有内容的文件夹</span></span><br><span class=\"line\">                _ =&gt; &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (_, content) <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.contents.<span class=\"title function_ invoke__\">iter</span>().<span class=\"title function_ invoke__\">enumerate</span>() &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 当前文件夹 level 1，子文件夹 initial level = 2</span></span><br><span class=\"line\">                        <span class=\"title function_ invoke__\">print_node</span>(<span class=\"number\">2</span>, &amp;content);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;================ END =================&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">root</span> = FolderNode &#123;</span><br><span class=\"line\">        name: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;root&quot;</span>),</span><br><span class=\"line\">        contents: <span class=\"type\">Vec</span>::<span class=\"title function_ invoke__\">new</span>(),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// base on root</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root.<span class=\"title function_ invoke__\">create_file</span>(<span class=\"string\">&quot;file_1.txt&quot;</span>);</span><br><span class=\"line\">        root.<span class=\"title function_ invoke__\">create_file</span>(<span class=\"string\">&quot;file_2.txt&quot;</span>);</span><br><span class=\"line\">        root.<span class=\"title function_ invoke__\">create_folder</span>(<span class=\"string\">&quot;folder_1&quot;</span>);</span><br><span class=\"line\">        root.<span class=\"title function_ invoke__\">create_folder</span>(<span class=\"string\">&quot;folder_2&quot;</span>);</span><br><span class=\"line\">        root.<span class=\"title function_ invoke__\">list_contents</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// base on root/folder_1</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">folder_1</span> = root.<span class=\"title function_ invoke__\">find_folder</span>(<span class=\"string\">&quot;folder_1&quot;</span>).<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">        folder_1.<span class=\"title function_ invoke__\">create_file</span>(<span class=\"string\">&quot;file_11.txt&quot;</span>);</span><br><span class=\"line\">        folder_1.<span class=\"title function_ invoke__\">create_file</span>(<span class=\"string\">&quot;file_12.txt&quot;</span>);</span><br><span class=\"line\">        folder_1.<span class=\"title function_ invoke__\">create_folder</span>(<span class=\"string\">&quot;folder_11&quot;</span>);</span><br><span class=\"line\">        folder_1.<span class=\"title function_ invoke__\">list_contents</span>();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">folder_11</span> = folder_1.<span class=\"title function_ invoke__\">find_folder</span>(<span class=\"string\">&quot;folder_11&quot;</span>).<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">        folder_11.<span class=\"title function_ invoke__\">create_folder</span>(<span class=\"string\">&quot;folder_111&quot;</span>);</span><br><span class=\"line\">        folder_11.<span class=\"title function_ invoke__\">list_contents</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// base on root/folder_2</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">folder_2</span> = root.<span class=\"title function_ invoke__\">find_folder</span>(<span class=\"string\">&quot;folder_2&quot;</span>).<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">        folder_2.<span class=\"title function_ invoke__\">create_file</span>(<span class=\"string\">&quot;file_21.txt&quot;</span>);</span><br><span class=\"line\">        folder_2.<span class=\"title function_ invoke__\">create_file</span>(<span class=\"string\">&quot;file_22.txt&quot;</span>);</span><br><span class=\"line\">        folder_2.<span class=\"title function_ invoke__\">create_folder</span>(<span class=\"string\">&quot;folder_21&quot;</span>);</span><br><span class=\"line\">        folder_2.<span class=\"title function_ invoke__\">list_contents</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    root.<span class=\"title function_ invoke__\">list_contents</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Test finder_folder error case&quot;</span>);</span><br><span class=\"line\">        root.<span class=\"title function_ invoke__\">find_folder</span>(<span class=\"string\">&quot;not_exist&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h3><p><img src=\"/../images/smart-pointers/home_work_2_result.png\" alt=\"home_work_2_result\"></p>\n","text":"首先理解，指针是什么？指针是一个存储了内存地址（memory address）的变量，该内存地址引用或者指向了内存中另外的数据。 在 Rust 中最常见的指针就...","permalink":"/post/smart-pointers","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[],"tags":[{"name":"rust","slug":"rust","count":10,"path":"api/tags/rust.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F\"><span class=\"toc-text\">为什么存在智能指针？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86-%E2%80%94-%E5%A4%84%E7%90%86%E5%A4%A7%E4%BD%93%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">性能管理 — 处理大体量的数据</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%84%E7%90%86%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">处理更复杂的数据结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%90TODO%E3%80%91%E5%9C%A8%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80%E4%B8%8A%EF%BC%8C%E5%AE%8C%E5%96%84%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">【TODO】在普通指针基础上，完善更多的功能</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E3%80%90TODO%E3%80%91RC-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88\"><span class=\"toc-text\">【TODO】RC 智能指针</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Box-Smart-Pointer\"><span class=\"toc-text\">Box Smart Pointer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#The-Deref-Trait\"><span class=\"toc-text\">The Deref Trait</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Traits-%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">Traits 特征</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%83%8F%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E4%B8%80%E6%A0%B7%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">像普通指针一样使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%8A%A8%E8%BF%98%E5%8E%9F-Box-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88\"><span class=\"toc-text\">手动还原 Box 智能指针</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Implicit-Deref-Coerions-%E9%9A%90%E5%BC%8F%E7%9A%84%E5%BC%BA%E5%88%B6%E8%A7%A3%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">Implicit Deref Coerions 隐式的强制解引用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#The-Drop-Trait\"><span class=\"toc-text\">The Drop Trait</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Trait-Objects\"><span class=\"toc-text\">Trait Objects</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Dynamic-dispatch-%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">Dynamic dispatch 动态调度</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E4%B8%9A2\"><span class=\"toc-text\">作业2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">运行结果</span></a></li></ol>","author":{"name":"Marnie","slug":"blog-author","avatar":"/images/favicon.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"First Project","uid":"3b2621a700dd1210cc1c1a2ba961dd42","slug":"first-project","date":"2024-11-01T08:06:44.000Z","updated":"2025-01-13T14:29:45.597Z","comments":true,"path":"api/articles/first-project.json","keywords":"","cover":null,"text":"Getting Started安装 anchor —— Solana 智能合约框架 1.用 cargo 安装 avm ，Anchor 版本管理器 1cargo ...","permalink":"/post/first-project","photos":[],"count_time":{"symbolsCount":335,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"rust","slug":"rust","count":10,"path":"api/tags/rust.json"}],"author":{"name":"Marnie","slug":"blog-author","avatar":"/images/favicon.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Rust 基础 Rust Basic","uid":"1f5f42bbe18d84ce044c457f49d8e22c","slug":"rust-basic","date":"2024-10-22T16:00:00.000Z","updated":"2025-01-13T14:30:01.520Z","comments":true,"path":"api/articles/rust-basic.json","keywords":"","cover":[],"text":"入门 Getting StartedRust静态类型语言（statically typed）：在编译时就确定了所有表达式的类型 强类型语言（strongly t...","permalink":"/post/rust-basic","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[],"tags":[{"name":"rust","slug":"rust","count":10,"path":"api/tags/rust.json"}],"author":{"name":"Marnie","slug":"blog-author","avatar":"/images/favicon.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}