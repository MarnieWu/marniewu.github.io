{"title":"闭包 Closures","uid":"0e16d47ce0f8c7e02c11662ec70d0b06","slug":"closures","date":"2025-01-16T12:15:31.000Z","updated":"2025-01-21T04:31:42.302Z","comments":true,"path":"api/articles/closures.json","keywords":"","cover":[],"content":"<h2 id=\"What-are-Closures\"><a href=\"#What-are-Closures\" class=\"headerlink\" title=\"What are Closures?\"></a>What are Closures?</h2><p>Rust 中的闭包本质是一个匿名函数，它有三个特点：</p>\n<ul>\n<li>可以被存储在变量中</li>\n<li>可以当做参数传给某个函数</li>\n<li>可以当做某个函数的返回值</li>\n</ul>\n<p>这都是普通函数不能做到的，一会儿我们可以写一个对比的例子，先来看下闭包的语法和使用。</p>\n<h2 id=\"Closure-Syntax\"><a href=\"#Closure-Syntax\" class=\"headerlink\" title=\"Closure Syntax\"></a>Closure Syntax</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|parameters| body</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Parameters：参数需要用竖线包裹，可以为空 <code>||</code></li>\n<li>Body：闭包主体，默认需要用 <code>&#123;&#125;</code> 包裹 <code>|...| &#123; ... &#125;</code>，如果只有一句表达式（expression），可以省略括号 <code>|...| println!(&quot;test&quot;)</code></li>\n</ul>\n<h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><h3 id=\"Simple-Closure\"><a href=\"#Simple-Closure\" class=\"headerlink\" title=\"Simple Closure\"></a><strong>Simple Closure</strong></h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">add</span> = |a: <span class=\"type\">i32</span>, b: <span class=\"type\">i32</span>| <span class=\"punctuation\">-&gt;</span> <span class=\"type\">i32</span> &#123; a + b &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">result</span> = <span class=\"title function_ invoke__\">add</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The sum is &#123;&#125;.&quot;</span>, result); <span class=\"comment\">// Output: The sum is 5.</span></span><br></pre></td></tr></table></figure>\n\n<p>简单的闭包就和普通函数表现一致，我们定义时也可以不声明类型，按照第一个调用的闭包会产生自动的类型推断。</p>\n<h3 id=\"No-Parameters-one-line-body\"><a href=\"#No-Parameters-one-line-body\" class=\"headerlink\" title=\"No Parameters, one line body\"></a>No Parameters, one line body</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">greet</span> = || <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_ invoke__\">greet</span>(); <span class=\"comment\">// Outputs: Hello, world!</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Capturing-Variables\"><a href=\"#Capturing-Variables\" class=\"headerlink\" title=\"Capturing Variables\"></a>Capturing Variables</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">add_to_x</span> = |y: <span class=\"type\">i32</span>| <span class=\"punctuation\">-&gt;</span> <span class=\"type\">i32</span> &#123; y + x &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">result</span> = <span class=\"title function_ invoke__\">add_to_x</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The result of adding 5 to &#123;&#125; is: &#123;&#125;&quot;</span>, x, result); <span class=\"comment\">// Outputs: The result of adding 5 to 10 is: 15</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Multi-Lines\"><a href=\"#Multi-Lines\" class=\"headerlink\" title=\"Multi Lines\"></a>Multi Lines</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">squared_sum</span> = |x: <span class=\"type\">i32</span>, y: <span class=\"type\">i32</span>| <span class=\"punctuation\">-&gt;</span> <span class=\"type\">i32</span> &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">let</span> <span class=\"variable\">sum</span> = x * y;</span><br><span class=\"line\">  \tsum * sum</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">result</span> = <span class=\"title function_ invoke__\">squared_sum</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Result = &#123;&#125;&quot;</span>, result); <span class=\"comment\">// Outputs: Result = 64</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Compared-to-standard-functions\"><a href=\"#Compared-to-standard-functions\" class=\"headerlink\" title=\"Compared to standard functions\"></a>Compared to standard functions</h2><h3 id=\"Don’t-have-to-sepcify-data-types-of-the-closure’s-arguments\"><a href=\"#Don’t-have-to-sepcify-data-types-of-the-closure’s-arguments\" class=\"headerlink\" title=\"Don’t have to sepcify data types of the closure’s arguments\"></a>Don’t have to sepcify data types of the closure’s arguments</h3><p>可以不定义闭包的参数类型，它会根据实际调用（invoke）传入的参数类型进行类型推断（data type infering）。</p>\n<h4 id=\"As-same-as-the-returning-type-also-can-be-empty-complier-will-infer-the-data-type-through-its-invoking\"><a href=\"#As-same-as-the-returning-type-also-can-be-empty-complier-will-infer-the-data-type-through-its-invoking\" class=\"headerlink\" title=\"As same as, the returning type also can be empty, complier will infer the data type through its invoking.\"></a>As same as, the returning type also can be empty, complier will infer the data type through its invoking.</h4><p>同样的，返回类型也可以不定义，编译器会通过其调用推断数据类型。</p>\n<h3 id=\"Capturing-Variables-1\"><a href=\"#Capturing-Variables-1\" class=\"headerlink\" title=\"Capturing Variables\"></a>Capturing Variables</h3><p>闭包和函数还有一个大差异 —— 闭包可以访问其所在作用域内的变量。Standard functions can not access the varibales which are defined out of this function.</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">test_closures</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">add</span> = |x: <span class=\"type\">i32</span>, y: <span class=\"type\">i32</span>| x + y;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">number</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">test_standard_function</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, number); <span class=\"comment\">// ❌ get error</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">add</span>(number, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/closure/image-20250120161822179.png\" alt=\"image-20250120161822179\"></p>\n<p>而闭包不同于标准函数，它提供了 inherit（继承）的能力，在闭包内可以访问父级作用域（parent scope）用内定义的变量，这也被称为变量捕获（capturing variables），捕获有三种形式：</p>\n<ul>\n<li>引用捕获（默认）：闭包对变量进行借用</li>\n<li>可变引用捕获：闭包对变量进行可变的借用</li>\n<li>按值：上两种都是对变量的借用，如果想直接拥有数据的所有权，需要使用 <code>move</code> 关键字转移所有权，所有权转移后的变量不能再后续被使用</li>\n</ul>\n<h4 id=\"Examples-1\"><a href=\"#Examples-1\" class=\"headerlink\" title=\"Examples\"></a>Examples</h4><h5 id=\"Capturing-By-Reference（Default\"><a href=\"#Capturing-By-Reference（Default\" class=\"headerlink\" title=\"Capturing By Reference（Default)\"></a>Capturing By Reference（Default)</h5><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">add_to_x</span> = |y: <span class=\"type\">i32</span>| <span class=\"punctuation\">-&gt;</span> <span class=\"type\">i32</span> &#123; y + x &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">result</span> = <span class=\"title function_ invoke__\">add_to_x</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The result of adding 5 to &#123;&#125; is: &#123;&#125;&quot;</span>, x, result); <span class=\"comment\">// Outputs: The result of adding 5 to 10 is: 15</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"Capturing-By-Mutable-Reference\"><a href=\"#Capturing-By-Mutable-Reference\" class=\"headerlink\" title=\"Capturing By Mutable Reference\"></a>Capturing By Mutable Reference</h5><p>可变借用的前提是被借用的变量也得是 mutable 的，闭包也定义成 mutable</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">x</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">add_to_x</span> = |y: <span class=\"type\">i32</span>| <span class=\"punctuation\">-&gt;</span> <span class=\"type\">i32</span> &#123;</span><br><span class=\"line\">  \tx += <span class=\"number\">5</span>; <span class=\"comment\">// mutation</span></span><br><span class=\"line\">  \tx + y</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">result</span> = <span class=\"title function_ invoke__\">add_to_x</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;x = &#123;&#125;&quot;</span>, x); <span class=\"comment\">// Outputs: x = 15</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"Capturing-By-Value（move）\"><a href=\"#Capturing-By-Value（move）\" class=\"headerlink\" title=\"Capturing By Value（move）\"></a>Capturing By Value（<code>move</code>）</h5><p>对于实现了 <code>Copy</code> trait 的数据类型变量的移动和赋值都不会发生所有权转移，是值的复制。所以测试 move 需要使用没有实现 <code>Copy</code> trait 的数据类型</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Test&quot;</span>); <span class=\"comment\">// no implements Copy trait</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">foo</span> = <span class=\"keyword\">move</span> || <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; is moved&quot;</span>, x);</span><br><span class=\"line\"><span class=\"title function_ invoke__\">foo</span>();</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/closure/image-20250117023543133.png\" alt=\"image-20250117023543133\"></p>\n<h3 id=\"Types-of-the-closures\"><a href=\"#Types-of-the-closures\" class=\"headerlink\" title=\"Types of the closures\"></a>Types of the closures</h3><p>闭包适用的场景一般是当做 callback functions 或者用于 iterators 中，在将闭包作为参数时我们需要定义闭包的类型。按照“你使用闭包需要干什么”可以将闭包的类型分为三种，it’s matched the three ways of 👆🏻Capturing Varibales.</p>\n<h4 id=\"Fn（Reference-capturing）\"><a href=\"#Fn（Reference-capturing）\" class=\"headerlink\" title=\"Fn（Reference capturing）\"></a>Fn（Reference capturing）</h4><p>普通闭包，可以调用一次或多次，但不修改变量</p>\n<p><img src=\"/../images/closure/image-20250120162314741.png\" alt=\"image-20250120162314741\"></p>\n<h4 id=\"FnMut（Mutable-reference-capturing）\"><a href=\"#FnMut（Mutable-reference-capturing）\" class=\"headerlink\" title=\"FnMut（Mutable reference capturing）\"></a>FnMut（Mutable reference capturing）</h4><p>你会在闭包内修改一个定义在闭包外部的变量，可以调用一次或多次，就用 <code>FnMut</code></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  first_name: <span class=\"type\">String</span>,</span><br><span class=\"line\">  last_name: <span class=\"type\">String</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">p1</span> = Person &#123;</span><br><span class=\"line\">    first_name: <span class=\"string\">&quot;Wu&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>(),</span><br><span class=\"line\">    last_name: <span class=\"string\">&quot;Marnie&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>(),</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// ✨ 如果你需要在闭包中修改某个外部变量，那么这个闭包也需要定义成 mutable</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">change_name</span> = |new_last_name: &amp;<span class=\"type\">str</span>| p1.last_name = new_last_name.<span class=\"title function_ invoke__\">to_string</span>();</span><br><span class=\"line\">  <span class=\"title function_ invoke__\">change_name</span>(<span class=\"string\">&quot;Marnieeee&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;After changed: &#123;&#125;&quot;</span>, p1.last_name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/closure/image-20250120171226001.png\" alt=\"image-20250120171226001\"></p>\n<p><img src=\"/../images/closure/image-20250120171600569.png\" alt=\"image-20250120171600569\"></p>\n<p>如上是正确输出，我们现在修改下例子，我们再调用一次 <code>change_name</code> 会发现有如下报错：</p>\n<p><img src=\"/../images/closure/image-20250120171843694.png\" alt=\"image-20250120171843694\"></p>\n<p><strong>cannot borrow <code>p1.last_name</code> as immutable because it is also borrowed</strong></p>\n<p>这是使用闭包时需要遵守的一个规则，因为我们上文说过，闭包有权捕获其环境内的变量，所以编译器如果发现还存在闭包调用，相当于闭包还存在对某个变量的借用，那在最后一个闭包调用结束前，这个被借用的变量都不能被其他地方借用。</p>\n<p>我们可以将闭包的操作放一起，最后进行输出就遵循了规则：</p>\n<p><img src=\"/../images/closure/image-20250120172511827.png\" alt=\"image-20250120172511827\"></p>\n<p><img src=\"/../images/closure/image-20250120172524107.png\" alt=\"image-20250120172524107\"></p>\n<h4 id=\"FnOnce\"><a href=\"#FnOnce\" class=\"headerlink\" title=\"FnOnce\"></a>FnOnce</h4><p>只能调用一次的闭包，这个类型和 <code>FnMut</code> 的区别在于调用次数，它们都可以在内部修改变量，但 <code>FnOnce</code> 只允许调用一次，这个类型一般是结合我们上面提到的 <code>move</code> 转移所有权的场景，因为被闭包捕获的变量的所有权，随着闭包的执行被转移了，在闭包调用后不可被访问，而所有权也就只能被转移一次，所以需要转移所有权的闭包需要定义为 <code>FnOnce</code>。</p>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><img src=\"../images/closure/image-20250116222435474.png\" alt=\"image-20250116222435474\"  />\n\n\n\n<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><p>初始化方法，将传入的回调函数（即闭包）存入结构体以后调用，并初始化各字段</p>\n<h3 id=\"get-page\"><a href=\"#get-page\" class=\"headerlink\" title=\"get_page\"></a>get_page</h3><p>接收 user_id 和 article_id，调用 is_rendered_page 判断是否存在过</p>\n<ul>\n<li>若存在：返回存下来的 page_content</li>\n<li>若不存在：调用 fetch_query 渲染，并更新 page_content</li>\n</ul>\n<h3 id=\"is-rendered-page\"><a href=\"#is-rendered-page\" class=\"headerlink\" title=\"is_rendered_page\"></a>is_rendered_page</h3><p>比较存下来的 user_id + article_id 和 当前请求的是否一致</p>\n<h3 id=\"render-page\"><a href=\"#render-page\" class=\"headerlink\" title=\"render_page\"></a>render_page</h3><p>调用初始化的闭包，传入 user_id 和 article_id，得到 page_content，并更新所有字段</p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">home_work</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">page_cache</span> = PageCache::<span class=\"title function_ invoke__\">new</span>(|user_id: &amp;<span class=\"type\">str</span>, article_id: <span class=\"type\">u32</span>| <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;Rendering page for user &#123;&#125; and article &#123;&#125;&quot;</span>,</span><br><span class=\"line\">            user_id, article_id</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"built_in\">format!</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;Rendered HTML for user &#123;&#125; and article &#123;&#125;&quot;</span>,</span><br><span class=\"line\">            user_id, article_id</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, page_cache.<span class=\"title function_ invoke__\">get_page</span>(<span class=\"string\">&quot;user1&quot;</span>, <span class=\"number\">42</span>));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, page_cache.<span class=\"title function_ invoke__\">get_page</span>(<span class=\"string\">&quot;user1&quot;</span>, <span class=\"number\">42</span>));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, page_cache.<span class=\"title function_ invoke__\">get_page</span>(<span class=\"string\">&quot;user2&quot;</span>, <span class=\"number\">42</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要使用“比较”功能，派生“比较”特征</span></span><br><span class=\"line\"><span class=\"meta\">#[derive(PartialEq)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">PageCache</span>&lt;T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: <span class=\"title function_ invoke__\">Fn</span>(&amp;<span class=\"type\">str</span>, <span class=\"type\">u32</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    fetch_page: T,</span><br><span class=\"line\">    value: <span class=\"type\">Option</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    user_id: <span class=\"type\">Option</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    article_id: <span class=\"type\">Option</span>&lt;<span class=\"type\">u32</span>&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 闭包能干什么？</span></span><br><span class=\"line\"><span class=\"comment\"> * 1. as callback function</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. capturing surrounding variables (important!!)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; PageCache&lt;T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: <span class=\"title function_ invoke__\">Fn</span>(&amp;<span class=\"type\">str</span>, <span class=\"type\">u32</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(fetch_page: T) <span class=\"punctuation\">-&gt;</span> PageCache&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化时，先将传入的闭包存下来当做 fetch_page 方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 闭包接收 user_id and article_id, 返回 page_content</span></span><br><span class=\"line\">        PageCache &#123;</span><br><span class=\"line\">            fetch_page,</span><br><span class=\"line\">            value: <span class=\"literal\">None</span>,</span><br><span class=\"line\">            article_id: <span class=\"literal\">None</span>,</span><br><span class=\"line\">            user_id: <span class=\"literal\">None</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">is_rendered_page</span>(&amp;<span class=\"keyword\">self</span>, user_id: &amp;<span class=\"type\">str</span>, article_id: <span class=\"type\">u32</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.article_id.<span class=\"title function_ invoke__\">is_some_and</span>(|id| id == article_id)</span><br><span class=\"line\">            &amp;&amp; <span class=\"keyword\">self</span>.user_id.<span class=\"title function_ invoke__\">as_deref</span>().<span class=\"title function_ invoke__\">is_some_and</span>(|id| id == user_id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">render_page</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, user_id: &amp;<span class=\"type\">str</span>, article_id: <span class=\"type\">u32</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.user_id = <span class=\"title function_ invoke__\">Some</span>(user_id.<span class=\"title function_ invoke__\">to_string</span>());</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.article_id = <span class=\"title function_ invoke__\">Some</span>(article_id);</span><br><span class=\"line\">        <span class=\"comment\">// self.fetch_page 是一个闭包 即一个 function</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">page_content</span> = (<span class=\"keyword\">self</span>.fetch_page)(user_id, article_id);</span><br><span class=\"line\">        <span class=\"comment\">// println!(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, user_id, article_id, page_content);</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value = <span class=\"title function_ invoke__\">Some</span>(page_content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">get_page</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, user_id: &amp;<span class=\"type\">str</span>, article_id: <span class=\"type\">u32</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> !<span class=\"keyword\">self</span>.<span class=\"title function_ invoke__\">is_rendered_page</span>(user_id, article_id) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.<span class=\"title function_ invoke__\">render_page</span>(user_id, article_id);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// unwrap 获取 Option 的 inner value，但是会转移所有权</span></span><br><span class=\"line\">        <span class=\"comment\">// self 是 mutable 的，mutable 结构体内部的 fields 不允许转移所有权</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以先 as_ref() 变成普通借用后调用 unwrap，此时 借用的变量调用 unwrap 返回的还是个借用的值</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此再用 clone() 将值复制返回</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value.<span class=\"title function_ invoke__\">as_ref</span>().<span class=\"title function_ invoke__\">unwrap</span>().<span class=\"title function_ invoke__\">clone</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/../images/closure/image-20250121122727975.png\" alt=\"image-20250121122727975\"></p>\n","text":"What are Closures?Rust 中的闭包本质是一个匿名函数，它有三个特点： 可以被存储在变量中 可以当做参数传给某个函数 可以当做某个函数的返回值...","permalink":"/post/closures","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"rust","slug":"rust","count":12,"path":"api/tags/rust.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#What-are-Closures\"><span class=\"toc-text\">What are Closures?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Closure-Syntax\"><span class=\"toc-text\">Closure Syntax</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Examples\"><span class=\"toc-text\">Examples</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Simple-Closure\"><span class=\"toc-text\">Simple Closure</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#No-Parameters-one-line-body\"><span class=\"toc-text\">No Parameters, one line body</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Capturing-Variables\"><span class=\"toc-text\">Capturing Variables</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Multi-Lines\"><span class=\"toc-text\">Multi Lines</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Compared-to-standard-functions\"><span class=\"toc-text\">Compared to standard functions</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Don%E2%80%99t-have-to-sepcify-data-types-of-the-closure%E2%80%99s-arguments\"><span class=\"toc-text\">Don’t have to sepcify data types of the closure’s arguments</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#As-same-as-the-returning-type-also-can-be-empty-complier-will-infer-the-data-type-through-its-invoking\"><span class=\"toc-text\">As same as, the returning type also can be empty, complier will infer the data type through its invoking.</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Capturing-Variables-1\"><span class=\"toc-text\">Capturing Variables</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Examples-1\"><span class=\"toc-text\">Examples</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Capturing-By-Reference%EF%BC%88Default\"><span class=\"toc-text\">Capturing By Reference（Default)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Capturing-By-Mutable-Reference\"><span class=\"toc-text\">Capturing By Mutable Reference</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Capturing-By-Value%EF%BC%88move%EF%BC%89\"><span class=\"toc-text\">Capturing By Value（move）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Types-of-the-closures\"><span class=\"toc-text\">Types of the closures</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Fn%EF%BC%88Reference-capturing%EF%BC%89\"><span class=\"toc-text\">Fn（Reference capturing）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#FnMut%EF%BC%88Mutable-reference-capturing%EF%BC%89\"><span class=\"toc-text\">FnMut（Mutable reference capturing）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#FnOnce\"><span class=\"toc-text\">FnOnce</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#new\"><span class=\"toc-text\">new</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#get-page\"><span class=\"toc-text\">get_page</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#is-rendered-page\"><span class=\"toc-text\">is_rendered_page</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#render-page\"><span class=\"toc-text\">render_page</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">完整代码</span></a></li></ol></li></ol>","author":{"name":"Marnie","slug":"blog-author","avatar":"/images/favicon.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"npm_and_pnpm","uid":"b174df949a1c3f84910009414c4b737f","slug":"npm-and-pnpm","date":"2025-01-17T16:47:09.000Z","updated":"2025-01-21T04:29:51.378Z","comments":true,"path":"api/articles/npm-and-pnpm.json","keywords":"","cover":null,"text":"TODO …","permalink":"/post/npm-and-pnpm","photos":[],"count_time":{"symbolsCount":6,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Marnie","slug":"blog-author","avatar":"/images/favicon.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"宏 Marcos","uid":"764bca6314ff5edd2be26b3adc313bc1","slug":"marcos","date":"2025-01-13T14:29:24.000Z","updated":"2025-01-15T18:49:58.785Z","comments":true,"path":"api/articles/marcos.json","keywords":"","cover":[],"text":"Declarative macrosWhat is macro_rules!?macro_rules! 用于定义声明式宏（declarative macros）...","permalink":"/post/marcos","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"rust","slug":"rust","count":12,"path":"api/tags/rust.json"}],"author":{"name":"Marnie","slug":"blog-author","avatar":"/images/favicon.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}