{"title":"宏 Marcos","uid":"764bca6314ff5edd2be26b3adc313bc1","slug":"marcos","date":"2025-01-13T14:29:24.000Z","updated":"2025-01-15T18:49:58.785Z","comments":true,"path":"api/articles/marcos.json","keywords":"","cover":[],"content":"<h3 id=\"Declarative-macros\"><a href=\"#Declarative-macros\" class=\"headerlink\" title=\"Declarative macros\"></a>Declarative macros</h3><h4 id=\"What-is-macro-rules\"><a href=\"#What-is-macro-rules\" class=\"headerlink\" title=\"What is macro_rules!?\"></a>What is <code>macro_rules!</code>?</h4><p><code>macro_rules!</code> 用于定义声明式宏（declarative macros），它主要包含两个部分 —— 模式 + 拓展的代码</p>\n<p>模式指的是，它允许定义指定的标识（token），当调用者输入了与指定标识相匹配的内容，则命中该模式。</p>\n<p>每个模式允许定义与之匹配的可执行代码，这被称为拓展的代码，当模式被命中之后则会执行其拓展的代码。</p>\n<p>这是 <code>macro_rules!</code> 的工作模式，使用上类似于 <code>match</code> 匹配的多分支。</p>\n<h4 id=\"macro-rules-‘s-Syntax\"><a href=\"#macro-rules-‘s-Syntax\" class=\"headerlink\" title=\"macro_rules!‘s Syntax\"></a><code>macro_rules!</code>‘s Syntax</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注释负责导出</span></span><br><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> macro_name &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// pattern 模式 expansion 拓展的代码</span></span><br><span class=\"line\">  \t(pattern) =&gt; &#123; expansion; &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用的三种方式</span></span><br><span class=\"line\">macro_name!();</span><br><span class=\"line\">macro_name![];</span><br><span class=\"line\">macro_name!&#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>marco_export</strong>: 使用该注释将宏导出，只有被导出的宏才能被当前作用域使用或是引入其他作用域使用；</li>\n<li><strong>macro_name</strong>：宏的名字，调用时加感叹号调用 <code>macro_name!</code> ;</li>\n<li><strong>pattern</strong>: 定义需要匹配的输入的结构；</li>\n<li><strong>expansion</strong>：定义匹配后需要的代码；</li>\n</ul>\n<h4 id=\"Pattern-matching\"><a href=\"#Pattern-matching\" class=\"headerlink\" title=\"Pattern matching\"></a>Pattern matching</h4><p>上面说了 pattern 指的是定义指定的 token（标识）让输入（input）去匹配：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> greet &#123;</span><br><span class=\"line\">    ($name:expr) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello, &#123;&#125;!&quot;</span>, $name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    greet!(<span class=\"string\">&quot;Mark&quot;</span>);</span><br><span class=\"line\">    greet!(<span class=\"string\">&quot;Film&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>模式中使用 <code>$xxx:expr</code> 这样的语法来定义，<code>expr</code> 可以匹配任何 Rust 表达式，除了这个 macro 中还提供了多个可以使用的 token 我们可以了解下，具体需要用到的时候再查就是了。</p>\n<h4 id=\"Token-types\"><a href=\"#Token-types\" class=\"headerlink\" title=\"Token types\"></a>Token types</h4><ol>\n<li><strong><code>expr</code></strong>: Matches any valid Rust expression. This includes literals, variables, function calls, and more.</li>\n<li><strong><code>stmt</code></strong>: Matches a statement, which can be a full statement like an assignment or a control flow statement (e.g., <code>if</code>, <code>for</code>, etc.).</li>\n<li><strong><code>pat</code></strong>: Matches a pattern, which is used in pattern matching (e.g., in <code>match</code> statements).</li>\n<li><strong><code>ty</code></strong>: Matches a type, such as <code>i32</code>, <code>String</code>, or any user-defined type.</li>\n<li><strong><code>ident</code></strong>: Matches an identifier, which is typically a variable name or function name.</li>\n<li><strong><code>path</code></strong>: Matches a path, which can be a simple identifier like <code>foo</code>, or fully qualified paths like <code>std::mem::replace</code>.</li>\n<li><strong><code>meta</code></strong>: Matches meta items, which are used in attributes (e.g., <code>#[derive(Debug)]</code>).</li>\n<li><strong><code>tt</code></strong>: Stands for “token tree” and matches any sequence of tokens. This is the most flexible option and can match anything from expressions to types to identifiers.</li>\n<li><strong><code>vis</code></strong>: Matches visibility qualifiers (e.g., <code>pub</code>, <code>private</code>, etc.), which control the visibility of items.</li>\n</ol>\n<p>除了指定 token 之外，宏的参数还是可变参数（与函数不一样），我们可以写对应的或者是多个匹配来实现参数的可变。</p>\n<h4 id=\"多个匹配：\"><a href=\"#多个匹配：\" class=\"headerlink\" title=\"多个匹配：\"></a>多个匹配：</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    greet!();</span><br><span class=\"line\">    greet!(<span class=\"string\">&quot;Mark&quot;</span>);</span><br><span class=\"line\">    greet!(<span class=\"string\">&quot;Film&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> greet &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 入参空</span></span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 入参非空</span></span><br><span class=\"line\">    ($name:expr) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello, &#123;&#125;!&quot;</span>, $name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../images/marcos/image-20250114165000073.png\" alt=\"image-20250114165000073\"></p>\n<h4 id=\"可重复（repetition）参数模式：\"><a href=\"#可重复（repetition）参数模式：\" class=\"headerlink\" title=\"可重复（repetition）参数模式：\"></a>可重复（repetition）参数模式：</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> create_vec &#123;</span><br><span class=\"line\">    ($($value:expr),*) =&gt; &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;外层 --- start&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">vec</span> = <span class=\"type\">Vec</span>::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">            $(&#123;</span><br><span class=\"line\">                <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,$value);</span><br><span class=\"line\">                vec.<span class=\"title function_ invoke__\">push</span>($value);</span><br><span class=\"line\">                <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;每次匹配到的输入都会执行&quot;</span>);</span><br><span class=\"line\">            &#125;)*</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;外层 --- end&quot;</span>);</span><br><span class=\"line\">            vec</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">my_vec</span> = create_vec![<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>$($value:expr), *</code> 中  <code>*</code> 表示 zero or more 可以匹配0或多次，还可以是 <code>+</code> at least one 至少匹配一次，<code>?</code> zero or one 零次或1次。</p>\n<p>注意上面的代码，可以看到 <code>expansion</code>  的部分我们有两个大括号，那是因为宏的概念本身是为了让我们定义对指定输入的固定行为，也就是 <code>expansion</code>，因为输入和输出都是固定的，所以在编译期间就会将宏调用替换成匹配到的 <code>expansion</code>。</p>\n<p>对于 <code>expansion</code> ，由于不同的宏调用上下文，比如它在一个赋值语句中被调用 <code>let a = macro_name!();</code> ，那 <code>expansion</code> 的执行结果它一定是一个值，一个值意味着它可能是一个表达式（expression）或一段包含多个语句（statement）且有返回值的代码块（code block）。如果是一个独立的宏调用 <code>macro_name!();</code>，那么 <code>expansion</code> 就可以是一个单独的语句，这就是不同上下文对 <code>expansion</code> 的限制。</p>\n<p>语句（statements）指的是一切代表某个操作行为的代码句子，可能是赋值、执行等等，其中有返回值的语句被称为表达式（expression），比如 <code>a + b / add(1, 2)</code> ，而用大括号包裹的1至多组语句被称为代码块（code block）。</p>\n<p>再说回上面代码示例，如果  <code>expansion</code> 是代码块就需要再套上一层大括号，其中可以用 <code>$(...)*</code> 语法糖包裹每次匹配到符合指定条件的输入 （<code>$value</code>） 时需要执行的语句，它会被替换成等价的配有不同输入的多个语句：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比如： create_vec![1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 替换前：</span></span><br><span class=\"line\">$(<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, $value))*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 替换后：</span></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"编译期间替换代码\"><a href=\"#编译期间替换代码\" class=\"headerlink\" title=\"编译期间替换代码\"></a>编译期间替换代码</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>再提一下</p></blockquote>\n<p>宏之所以好用是因为它在运行时不会产生损耗，因为声明宏使用的匹配模式是定义后就固定了的，编译期间就能将每个宏调用等价替换成命中匹配后的拓展代码。这里说的不会产生运行时的损耗，说白了就是代码在执行期间并不会因为逻辑而发生变化，没有会变的逻辑。</p>\n<h3 id=\"Procedural-macros\"><a href=\"#Procedural-macros\" class=\"headerlink\" title=\"Procedural macros\"></a>Procedural macros</h3><p>派生宏、属性宏、函数宏</p>\n<h4 id=\"派生宏\"><a href=\"#派生宏\" class=\"headerlink\" title=\"派生宏\"></a>派生宏</h4><p>我们常用的 derive 后使用的 crate 就是派生宏。</p>\n<p>注释：<code>#[proc_macro_derive]</code></p>\n<h4 id=\"函数宏\"><a href=\"#函数宏\" class=\"headerlink\" title=\"函数宏\"></a>函数宏</h4><p>注释：<code>#[proc_macro]</code></p>\n<p>常用函数宏：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[test]</span></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">macro_fn</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 读取文件内容</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">file_content</span> = <span class=\"built_in\">include_str!</span>(<span class=\"string\">&quot;../Cargo.toml&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 获取环境路径</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">env_path</span> = <span class=\"built_in\">env!</span>(<span class=\"string\">&quot;PATH&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 拼接字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">str</span> = <span class=\"built_in\">concat!</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 条件编译</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">cfg!</span>(target_os = <span class=\"string\">&quot;mac&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;manually panic!&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;111&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[test]</span></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">echo</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 以后实现的代码</span></span><br><span class=\"line\">    todo!();</span><br><span class=\"line\">    <span class=\"built_in\">unimplemented!</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"属性宏\"><a href=\"#属性宏\" class=\"headerlink\" title=\"属性宏\"></a>属性宏</h4><p>注释：<code>#[proc_macro_attribute]</code></p>\n<h4 id=\"编译期间计算和生成代码\"><a href=\"#编译期间计算和生成代码\" class=\"headerlink\" title=\"编译期间计算和生成代码\"></a>编译期间计算和生成代码</h4><p>派生宏用于处理比声明宏给为复杂的业务，每个过程宏都必须有一个单独的 crate，被当做插件一样在别的 crate 中使用。所以过程宏和声明宏一样，都是编译期间计算和生成对应的代码并将调用的地方替换，并无运行时损耗。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p><img src=\"/../images/marcos/image-20250115032438908.png\" alt=\"image-20250115032438908\"></p>\n<h4 id=\"先定义三个声明宏的壳子：\"><a href=\"#先定义三个声明宏的壳子：\" class=\"headerlink\" title=\"先定义三个声明宏的壳子：\"></a>先定义三个声明宏的壳子：</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(repeat!(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">3</span>), <span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(sum!(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>), <span class=\"number\">15</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(max_value!(<span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>), <span class=\"number\">9</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> repeat &#123;</span><br><span class=\"line\">    ($value:expr) =&gt; &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($value:expr) =&gt; &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> max_value &#123;</span><br><span class=\"line\">    ($value:expr) =&gt; &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>分析并实现宏：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * repeat!(&quot;x&quot;, 3)</span></span><br><span class=\"line\"><span class=\"comment\"> * 第一个入参：字符或字符串 C</span></span><br><span class=\"line\"><span class=\"comment\"> * 第二个入参：数字 N</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回：将 C 重复 N 次拼接</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> repeat &#123;</span><br><span class=\"line\">    ($<span class=\"type\">str</span>:expr,$num:expr) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"variable\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..$num &#123;</span><br><span class=\"line\">            s.<span class=\"title function_ invoke__\">push_str</span>($<span class=\"type\">str</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * sum!(1, 2, 3, 4, 5)</span></span><br><span class=\"line\"><span class=\"comment\"> * 入参：不固定数量的数字</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回：这些数字的和</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> sum &#123;</span><br><span class=\"line\">    ($($value:expr),*) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">v</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        $(v=v+$value;)*</span><br><span class=\"line\">        v</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * max_value!(1, 8, 9)</span></span><br><span class=\"line\"><span class=\"comment\"> * 入参：不固定数量的数字</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回：入参中最大的数字</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> max_value &#123;</span><br><span class=\"line\">    ($($value:expr),*) =&gt; &#123;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">max</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        $(max=<span class=\"keyword\">if</span> $value&gt;max &#123;$value&#125; <span class=\"keyword\">else</span> &#123;max&#125;;)*</span><br><span class=\"line\">        max</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","text":"Declarative macrosWhat is macro_rules!?macro_rules! 用于定义声明式宏（declarative macros）...","permalink":"/post/marcos","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"rust","slug":"rust","count":9,"path":"api/tags/rust.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Declarative-macros\"><span class=\"toc-text\">Declarative macros</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#What-is-macro-rules\"><span class=\"toc-text\">What is macro_rules!?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#macro-rules-%E2%80%98s-Syntax\"><span class=\"toc-text\">macro_rules!‘s Syntax</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Pattern-matching\"><span class=\"toc-text\">Pattern matching</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Token-types\"><span class=\"toc-text\">Token types</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA%E5%8C%B9%E9%85%8D%EF%BC%9A\"><span class=\"toc-text\">多个匹配：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E9%87%8D%E5%A4%8D%EF%BC%88repetition%EF%BC%89%E5%8F%82%E6%95%B0%E6%A8%A1%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">可重复（repetition）参数模式：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E6%9B%BF%E6%8D%A2%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">编译期间替换代码</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Procedural-macros\"><span class=\"toc-text\">Procedural macros</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B4%BE%E7%94%9F%E5%AE%8F\"><span class=\"toc-text\">派生宏</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%AE%8F\"><span class=\"toc-text\">函数宏</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E5%AE%8F\"><span class=\"toc-text\">属性宏</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E8%AE%A1%E7%AE%97%E5%92%8C%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">编译期间计算和生成代码</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A0\"><span class=\"toc-text\">练习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%88%E5%AE%9A%E4%B9%89%E4%B8%89%E4%B8%AA%E5%A3%B0%E6%98%8E%E5%AE%8F%E7%9A%84%E5%A3%B3%E5%AD%90%EF%BC%9A\"><span class=\"toc-text\">先定义三个声明宏的壳子：</span></a></li></ol></li></ol>","author":{"name":"Marnie","slug":"blog-author","avatar":"/images/favicon.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"closure","uid":"80f0573b97af3c314928fabd7a5845aa","slug":"closure","date":"2025-01-16T12:15:31.000Z","updated":"2025-01-16T18:36:20.960Z","comments":true,"path":"api/articles/closure.json","keywords":"","cover":[],"text":"What are Closures?Rust 中的闭包本质是一个匿名函数，它有三个特点： 可以被存储在变量中 可以当做参数传给某个函数 可以当做某个函数的返回值...","permalink":"/post/closure","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"rust","slug":"rust","count":9,"path":"api/tags/rust.json"}],"author":{"name":"Marnie","slug":"blog-author","avatar":"/images/favicon.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"特征 Trait","uid":"bf66738dcbdc4a39018dfff1579fc70a","slug":"trait","date":"2025-01-05T14:56:40.000Z","updated":"2025-01-13T14:30:10.302Z","comments":true,"path":"api/articles/trait.json","keywords":"","cover":[],"text":"孤儿规则impl T for A : 为 A 实现特征 T , 那么 A 或者 T 至少有一个是在当前作用域中定义的。 1234fn main { // ❌ C...","permalink":"/post/trait","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"rust","slug":"rust","count":9,"path":"api/tags/rust.json"}],"author":{"name":"Marnie","slug":"blog-author","avatar":"/images/favicon.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}