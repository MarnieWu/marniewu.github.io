[{"id":"bf66738dcbdc4a39018dfff1579fc70a","title":"特征 Trait","content":"孤儿规则impl T for A : 为 A 实现特征 T , 那么 A 或者 T 至少有一个是在当前作用域中定义的。\n1234fn main &#123;  // ❌ Clone 和 String 都是标准库中定义的，而不是当前 crate 中定义的，无法使用 impl 关键字  impl Clone for String &#123;&#125;&#125;\n\n\n签名 signature 和重载 overridetrait 中，可以只定义签名，也可以定义方法的默认行为。在具体实现中定义的方法会重载特征中默认的方法。\n当我们在调用某个方法时，会先找自身结构体中是否有对应实现，若没有则向上🔼找特征中的该方法。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Post 结构体struct Post &#123;    name: String,    author: String,&#125;// Weibo 结构体struct Weibo &#123;    username: String,    content: String,&#125;// Summary 特征trait Summary &#123;    fn summarize_author(&amp;self) -&gt; String;    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;Read more from &#123;&#125;...&quot;, self.summarize_author())    &#125;&#125;// 为 Post 实现 Summary 特征impl Summary for Post &#123;    fn summarize_author(&amp;self) -&gt; String &#123;        self.author.clone()    &#125;    // fn summarize(&amp;self) -&gt; String &#123;    //     format!(&quot;文章&#123;&#125;，作者是&#123;&#125;&quot;, self.name, self.author)    // &#125;&#125;// 为 Weibo 实现 Summary 特征impl Summary for Weibo &#123;    fn summarize_author(&amp;self) -&gt; String &#123;        format!(&quot;@&#123;&#125;&quot;, self.username)    &#125;    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;&#123;&#125;发表了微博&#123;&#125;&quot;, self.username, self.content)    &#125;&#125;fn main() &#123;    let post = Post &#123;        name: &quot;trait_study&quot;.to_string(),        author: &quot;marnie&quot;.to_string(),    &#125;;   // Post 中只有 summarize_author 这一个方法的实现   // 所以当调用 summarize 方法时会找到其原特征中的对应方法    println!(&quot;&#123;&#125;&quot;, post.summarize_author());    println!(&quot;&#123;&#125;&quot;, post.summarize());    let weibo = Weibo &#123;        username: String::from(&quot;marnie&quot;),        content: String::from(&quot;正在学习 Trait 特征&quot;),    &#125;;   // 因为 Weibo 中分别对以下两个方法进行了重写，会覆盖特征中的默认方法    println!(&quot;&#123;&#125;&quot;, weibo.summarize_author());    println!(&quot;&#123;&#125;&quot;, weibo.summarize());&#125;\n\n\n泛型的使用在特征中使用泛型：trait AAA&lt;T&gt; 使用到传入的泛型的地方，必须手动标注类型特征接收的泛型是给特征方法所使用的，在具体实现了特征的结构体调用方法时，需要手动的标注泛型的实际类型，让编译器知道调用哪个类型实现的方法\n123456789101112131415161718192021222324252627282930313233// 特征 Convert 用于转换类型trait Convert&lt;T&gt; &#123;    fn convert(&amp;self) -&gt; T;&#125;// 我们定义一个结构体来实现 Convert 特征// 元组结构体（tuple）struct MyInt(i32);// 对 MyInt 实现了两种类型的特征impl Convert&lt;i32&gt; for MyInt &#123;    fn convert(&amp;self) -&gt; i32 &#123;        self.0 as i32    &#125;&#125;impl Convert&lt;String&gt; for MyInt &#123;    fn convert(&amp;self) -&gt; String &#123;        self.0.to_string()    &#125;&#125;fn main() &#123;    let my_int = MyInt(5);    // 必须手动加上类型标注    let output: i32 = my_int.convert();    println!(&quot;&#123;&#125;&quot;, output);    // 必须手动加上类型标注    let output: String = my_int.convert();    println!(&quot;&#123;&#125;&quot;, output);&#125;\n\n在方法中使用泛型：impl&lt;T&gt; AAA for BBB ==&gt; impl&lt;T&gt; for BBB在方法中使用泛型指的是 —— 当我们某个特征方法需要使用泛型，它本质上就是将指定类型传给方法，和特征、和结构体其实无关，使用上和在结构体中使用泛型是一个方式。\n一种更疯狂的用法，该泛型既是方法需要用的也是特征要用的，会是下面定义的样子：\n123impl&lt;T&gt; Convert&lt;T&gt; for MyInt &#123; // ...&#125;\n\n当 trait 中加入了泛型，让我们拥有了针对不同场景进行不同类型实现的能力。但如果我们想控制 —— 特征的实现是可以支持多种类型的，但只能有一种类型的具体实现，这个时候泛型就做不了这样的约束了，Rust 针对需要这种约束的场景提供了一个新的方式 —— 关联类型。\n关联类型关联类型是在签名时不固定类型，在实现中指定需关联的类型，且不能有多次指定（即多种实现），编译器会在第一次以后得实现上报错。\n123456789101112131415161718192021222324252627282930313233- trait Convert&lt;T&gt; &#123;-     fn convert(&amp;self) -&gt; T;- &#125;+ trait Convert &#123;+     // 这是关联类型 Output+     type Output;+     // Self::Output 使用关联类型+     fn convert(&amp;self) -&gt; Self::Output;+ &#125;struct MyInt(i32);- impl Convert&lt;i32&gt; for MyInt &#123;-     fn convert(&amp;self) -&gt; i32 &#123;-         self.0 as i32-     &#125;- &#125;- impl Convert&lt;String&gt; for MyInt &#123;-     fn convert(&amp;self) -&gt; String &#123;-         self.0.to_string()-     &#125;- &#125;+ impl Convert for MyInt &#123;+     type Output = i32;+     fn convert(&amp;self) -&gt; Self::Output &#123;+         self.0+     &#125;+ &#125;\n\n如果关联了不止一个类型，就会得到下面的报错：\n\nTrait 关联类型的默认类型：A&lt;B = T&gt; T 为 A 关联类型 B 的默认类型我们先实现一个简单的 add 函数，功能是将两个参数相加，并返回结果：\n1234567891011use std::ops::Add;// 作用：将两参数相加，并返回结果fn add&lt;T: Add&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T &#123;  a + b&#125;fn main() &#123;  let sum = add(10, 20);  println!(&quot;&#123;&#125;&quot;, sum);&#125;\n\n\n这里用了一个内部特征 Add，它支持泛型且默认值为 Self，Self 指的是当你没有指定传入类型时它就默认为你正在调用的实现了 Add 特征的当前类型。\n\n12345678910111213141516171819202122// 举个例子struct Point &#123;  x: i32,  y: i32,&#125;// ✨ 并没有指定 Add 的泛型，Self 则为当前类型 Pointimpl Add for Point &#123;  // ✨ 关联类型没有默认值，必须手动指定  type Output = Point;    fn add(self, rhs: Self) -&gt; Self::Output &#123;    Point &#123;      x: self.x + rhs.x,      y: self.y + rhs.y,    &#125;  &#125;&#125;let p1 = Point &#123; x: 10, y: 20 &#125;;let p2 = Point &#123; x: 20, y: 30 &#125;;let p3 = p1.add(p2);\n\n\n再回到前面我们手动实现的 add 函数，我们再用不同类型来试验一下泛型：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Add 特征在 Meters 上的多态实现impl Add&lt;Kilometers&gt; for Meters &#123;    type Output = Meters;    fn add(self, rhs: Kilometers) -&gt; Self::Output &#123;        println!(            &quot;&#123;&#125;km, &#123;&#125;m, &#123;&#125;m&quot;,            rhs.0,            rhs.0 * 1000 as f64,            self.0 + (rhs.0 * 1000 as f64)        );        Meters(self.0 + (rhs.0 * 1000 as f64))    &#125;&#125;// Add 特征在 Meters 上的多态实现impl Add for Meters &#123;    type Output = Meters;    fn add(self, rhs: Meters) -&gt; Self::Output &#123;        Meters(self.0 + rhs.0)    &#125;&#125;// Add 特征在 Kilometers 上的多态实现impl Add&lt;Meters&gt; for Kilometers &#123;    type Output = Kilometers;    fn add(self, rhs: Meters) -&gt; Self::Output &#123;        println!(            &quot;&#123;&#125;m, &#123;&#125;km, &#123;&#125;km&quot;,            rhs.0,            rhs.0 / 1000 as f64,            self.0 + (rhs.0 / 1000 as f64)        );        Kilometers(self.0 + rhs.0 / 1000 as f64)    &#125;&#125;// Add 特征在 Kilometers 上的多态实现impl Add for Kilometers &#123;    type Output = Kilometers;    fn add(self, rhs: Self) -&gt; Self::Output &#123;        Kilometers(self.0 + rhs.0)    &#125;&#125;let m = Meters(600 as f64);let km = Kilometers(10 as f64);let total_m = m.clone().add(km.clone());let total_km = km.add(m.clone());println!(&quot;total meters = &#123;:?&#125;m&quot;, total_m.0);println!(&quot;total kilometers = &#123;:?&#125;km&quot;, total_km.0);\n\n\n当 Trait 作为参数传递时，如何进行类型声明 —— Trait Bound 特征约束假设当前有一个特征 Summary\n12345trait Summary &#123;  fn summarize(&amp;self) -&gt; String;&#125;// TODO：实现 notify 函数，用于实现了 Summary 特征的类型进行通知（调用 .summarize 方法）\n\n&lt;T: U&gt; 用于约束泛型 T 必须是实现了 U 特性的类型，但该函数只能接受一种泛型的具体类型\n1234567891011121314// 单个参数fn notify&lt;T: Summary&gt;(item: &amp;T) &#123;  item.summarize();&#125;// 多参数fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;  item.summarize();&#125;// 省略 Weibo，Post 定义，它们均是实现了 Summary 特征的结构体// 只能传入一种类型notify(Weibo &#123;&#125;, Weibo &#123;&#125;); // ✅notify(Weibo &#123;&#125;, Post &#123;&#125;); // ❌\n\nimpl T 用于表示实现了 T 特性的类型，比起 &lt;T: U&gt; 更灵活，可以传入不同的实现了同一特征的类型\n1234567891011121314151617fn notify(item: &amp;impl Summary) &#123;  item.summarize();&#125;// 返回类型同样也能使用fn foo() -&gt; impl Summary &#123;  // ...&#125;// 多参数fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) &#123;  item.summarize();&#125;// 省略 Weibo，Post 定义，它们均是实现了 Summary 特征的结构体// 可以传入多个类型notify(Weibo &#123;&#125;, Post &#123;&#125;);\n\n多重约束 &lt;T: A + B&gt; &#x2F; impl A + B 表示同时实现了 特征A 和 特征B 的类型where 语法糖当约束复杂时，可以使用 where 语法糖在函数后面写类型约束\n1234567fn notify2&lt;T, U&gt;(item1: T, item2: U)where  T: Summary + Display,  U: Summary + Display + Debug,&#123;  // ...&#125;\n\nderive 派生特性当一个类型没有实现某个 trait 但又想使用该特性的方法，可以使用 #[derive(AAA)] 派生特性的语法，会自动实现该特征和继承其方法的默认行为。如果一个结构体派生了某个特征，那么该结构体的每个字段都需要实现了这个特征，不然无法对齐特征，使用其功能。\nCopy Trait 复制特征这里介绍一个常用特征 Copy ，通常我们使用 let b = a，因为所有权的控制，赋值会将 a 的值的所有权转移给目标变量 b，在赋值语句之后，a 将不能再被使用。\n但如果是实现了 Copy 特征的类型，在赋值操作时会调用 Copy 特征的功能，不会转移所有权，会将值复制一份赋值给目标变量，这样一来等号左边和右边的变量就是两个独立变量，不会互相影响。一般内置基本类型都已经实现了 Copy 特征。\n12345678struct Meters(i32);fn main() &#123;    let b = Meters(10);    let a = b;    println!(&quot;&#123;:?&#125;&quot;, b);&#125;\n\n\n我们使用派生特性加上 Copy 特征，报错就解决了：\n123456789#[derive(Debug, Copy)]struct Meters(i32);fn main() &#123;    let b = Meters(10);    let a = b;    println!(&quot;&#123;:?&#125;&quot;, b);&#125;\n\n\n练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960trait Item &#123;    type Output;    fn summarize(&amp;self) -&gt; Self::Output;&#125;struct Apple &#123;    name: String,&#125;struct Weibo &#123;    author: String,    content: String,&#125;impl Item for Apple &#123;    type Output = String;    fn summarize(&amp;self) -&gt; Self::Output &#123;        self.name.to_string()    &#125;&#125;impl Item for Weibo &#123;    type Output = String;    fn summarize(&amp;self) -&gt; Self::Output &#123;        format!(&quot;@&#123;&#125;:&#123;&#125;&quot;, self.author, self.content)    &#125;&#125;struct Container &#123;    // 💙 注意点    items: Vec&lt;Box&lt;dyn Item&lt;Output = String&gt;&gt;&gt;,&#125;impl Container &#123;    fn iterator(&amp;self) &#123;        // 💙 注意点        for item in self.items.iter() &#123;            println!(&quot;&#123;&#125;&quot;, item.summarize())        &#125;    &#125;&#125;fn main() &#123;    let apple = Apple &#123;        name: String::from(&quot;Marnie&quot;),    &#125;;    let weibo = Weibo &#123;        author: String::from(&quot;Marnie&quot;),        content: String::from(&quot;sky...&quot;),    &#125;;    let container = Container &#123;        // 💙 注意点        items: vec![Box::new(apple), Box::new(weibo)],    &#125;;    container.iterator();&#125;\n\n\nTrait Object 用 dyn 关键字\nTrait Object 是动态类型，编译时没有固定大小，需要用智能指针包裹（赋予其一个栈内的固定大小）使用\n遍历向量 Vec 使用 xxx.iter()\n含关联类型的声明方式 XXX&lt;Output = T&gt;\n\n","slug":"trait","date":"2025-01-05T14:56:40.000Z","categories_index":"","tags_index":"trait","author_index":"Marnie"},{"id":"9fb78f735ce3a3f25bf1795a347b0649","title":"智能指针2 Smart Pointers 2","content":"Rc 智能指针Rust 所有权机制要求一个值只能有一个所有者，如果出现需要共享数据的情况，也就是说一个数据资源拥有多个所有者，或者说一个资源需要被多个对象引用，Rust 设计了 Rc 智能指针来做相应实现。\nRc&lt;T&gt;Rc 是引用计数（Reference counting）的意思，顾名思义就是记录一个数据资源被引用的次数，以此来确定该数据是否正在被使用。当引用次数归零后，就代表该数据不再被任何使用，因此可以被清理释放。在离开某个作用域时，如引用对象被 drop 了那引用次数也会对应减去。\nRc::new我们使用 Rc::new(data) 创建一个新的 Rc&lt;T&gt; 智能指针，并赋值给某个变量。\nRc::clone我们使用 Rc::clone(Rc&lt;T&gt;) 创建出一个新的 Rc&lt;T&gt; 智能指针，指向堆内存上那个被共享的 Rc&lt;T&gt; 智能指针。使用 clone 可以在不转移所有权的条件下得到 owned value，而不是某个值的引用。\nOwned Valuelet x = 5 我们把 x 称为 variable 变量，5 称为 owned value 即 数据值，此时 变量 x 拥有 数据 5 的所有权。\nRc::strong_count新建的 Rc&lt;T&gt; 智能指针初始引用计数为1，每被 clone 一次就会相应 +1，调用 Rc::strong(Rc&lt;T&gt;) 会返回传入的 Rc&lt;T&gt; 智能指针当前被引用的次数。\nStrong Reference 强引用Rc 是 strong reference 强引用，强引用指的是会参与引用计数的引用，参与引用计数意味着每被引用一次，该数据的被引用次数就会加一，只要被引用次数不为0，那这块数据对应的资源就不会被释放。\n比如 c 是一个 Rc 变量，它被 a 和 b 引用着，那只有 a 和 b 的引用都被 drop 了之后，c 对应的内部数据资源才会被清理。这里就会出现一个问题，因为强引用会参与引用计数，它会直接影响到内存释放的逻辑，当产生循环引用时，比如 a 引用 b，c 引用 d，b 和 d 之间存在互相引用，本来 a 离开作用域后应该将 b 释放的，但是因为 d 还有对 b 的引用所以这块资源并不能释放，同样的 c 离开作用域后应该将 d 释放的，但 d 还存在被 b 引用着也无法被释放，这就会产生内存泄漏问题。为了避免内存泄漏，当我们遇到循环引用的场景时我们需要用 weak reference 弱引用来替代，下面说明一下相关用法。\nWeak Reference 弱引用Rc::downgrade使用 Rc::downgrade(&amp;Rc&lt;T&gt;) 得到一个 Rc 引用的弱引用，弱引用不参与引用计数，它只是 Rc 在处理循环引用上的一个解决方案。而也因为不参与引用计数，所以无法保证被引用的对象一定是存在的，当需要访问它对应的数据时，需要使用 xx.upgrade() 将其转换为强引用类型，且该强引用被引用的对象还存在时，才可以访问。\n12345678910111213let t = Rc::new(String::from(&quot;Hello&quot;));let weak_t = Rc::downgrade(&amp;t);// upgrade 得到强引用的对象match weak_t.upgrade() &#123;  // 若强引用对象还存在  Some(t) =&gt; &#123;    println!(&quot;&#123;&#125;&quot;, t);  &#125;  // 强引用对象不存在  _ =&gt; &#123;&#125;&#125;;\n\n共享资源之后还安全么？我们之前学习过，Rust 中设计所有权机制就是为了保证数据资源的使用安全，一个数据资源只有一个所有者，就能规避掉对一个数据同时进行读写的状况。\n而也是因为所有权的限制，在很多实际场景中，会让开发者因为所有权转移的规则而头疼，导致代码总是无法编译通过、报错。于是乎，Rc 智能指针的诞生让开发者可以更轻松的实现对一个数据资源的共享且不违背所有权规则的底层原因 —— 数据读写安全，它提供了“创建指向同一块资源的多个指针”的能力，以及一些相关的功能（如：引用计数）。查看 Rc 的内部实现就可以发现，它在创建时其实是把数据装在了一个 Box 智能指针中（让不确定大小的数据类型变成有大小的数据类型，有大小的数据类型指的是为其在栈上申请一块空间，并在栈上拥有一个固定大小的指针指向这块内存），然后又在外面套了一层自己的壳，而在 Rc 智能指针这一层并没有提供修改内部数据的方法，所以即使是共享资源，多个对象可以访问一块内存资源，内存中的数据也还是安全的，它只是一个不可变的引用。\n但是往往，需要 share data 的场景 和 修改的场景 都是伴随出现的，我们遇到 共享 + 修改 时需要配合 RefCell 使用。\nRefCell一般在共享数据的场景下，如果还需要支持对原数据进行修改，我们就可以使用 RefCell。RefCell 是让你拥有对数据修改能力的结构体，即便这个数据是 immutable 的。它和可变引用的区别是，可变引用依然遵守一个所有者的原则，一个数据的可变引用和不可变引用是不能同时存在的。我们可以看下例子：\n\n如报错所示，因为引用本身还是遵守 ownership 的原则，不可能同时存在两种类型的引用，这是违背数据安全的，在编译时就可以校验出来。说回 RefCell ，我们看到前面引用存在着严格的借用关系，当我们需要借用的地方变多时，就会很难在写代码时就整理出明确的借用关系。此时就可以用 RefCell，它没有编译时的借用关系校验，而是运行时校验，介绍下它的常用内容。\nRefCell::new创建一个新的内部可变的 RefCell 结构体\n123use std::cell::RefCell;let data = RefCell::new(5);\n\nborrow()得到某个 RefCell 的不可变借用\n1let r1 = data.borrow();  // Immutable borrow\n\nborrow_mut()得到某个 RefCell 的可变借用\n12let mut r2 = data.borrow_mut();  // Mutable borrow*r2 += 1; // Modify through mutable borrow\n\nRefCell 的限制RefCell 也有一个使用规则，在运行时不能同时存在着可变借用和不可变借用。\n如下图的示例，我们可以看到虽然我们创建了可变借用和不可变借用，并有同时存在的时刻，但这并没有触发编译报错：\n\n我们运行代码，可以看到报错信息 “already borrowed”：\n\nInterior Mutability 内部可变性内部可变性指的是即使变量本身定义的是非可变变量，使用 RefCell 也能改变其内部的数据。\n练习\n实现：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091use std::&#123;    cell::RefCell,    rc::&#123;Rc, Weak&#125;,&#125;;fn main() &#123;    home_work();&#125;#[derive(Debug)]struct User &#123;    name: String,    // friends 用户列表 Vec&lt;User&gt;    // a、b 存在互相引用 需要定义成 Weak 智能指针 Vec&lt;Weak&lt;User&gt;&gt;    // a、b 的 friends 需要有可变性 Vec&lt;Weak&lt;RefCell&lt;User&gt;&gt;&gt;    friends: RefCell&lt;Vec&lt;Weak&lt;User&gt;&gt;&gt;,&#125;impl User &#123;    fn new(name: &amp;str) -&gt; Rc&lt;User&gt; &#123;        Rc::new(User &#123;            name: String::from(name),            friends: RefCell::new(vec![]),        &#125;)    &#125;    // 因为我们需要拿到 user 内部的 friends 数据，所以此时需要用 Rc 而不是 Weak，Weak 无法得到内部数据    fn add_friend(self: &amp;Rc&lt;User&gt;, other: Rc&lt;User&gt;) &#123;        // 需要检查other和self是否已经是朋友，若不是则push进friends列表        // 如何检查 friends 列表，已知 friends 列表是一个 Weak&lt;User&gt; list        let weak_other = Rc::downgrade(&amp;other.clone());        let is_friend = self            .friends            .borrow()            .iter()            .any(|user| weak_other.ptr_eq(user));        if is_friend &#123;            println!(&quot;&#123;&#125; and &#123;&#125; are already friends.&quot;, self.name, other.name);            return;        &#125;        if !is_friend &#123;            println!(&quot;&#123;&#125; add friend &#123;&#125;&quot;, self.name, other.name);            // 若不是朋友，更新 friends 列表            self.friends.borrow_mut().push(weak_other);            other.friends.borrow_mut().push(Rc::downgrade(self));        &#125;    &#125;    fn list_friends(self: &amp;Rc&lt;User&gt;) &#123;        let mut output = String::from(format!(&quot;The friends of &#123;&#125; are &quot;, self.name).as_str());        for item in self.friends.borrow().iter() &#123;            match item.upgrade() &#123;                Some(friend) =&gt; output.push_str(format!(&quot;&#123;&#125;,&quot;, friend.name).as_str()),                None =&gt; &#123;&#125;            &#125;        &#125;        output.pop();        println!(&quot;&#123;&#125;&quot;, output);    &#125;&#125;/** * 实现一个简单的社交网络系统，包含用户和朋友的关系。 * 用户结构：每个用户拥有一个名字和一个朋友列表 * 添加朋友：支持在两个用户之间建立朋友关系 * 展示朋友关系：能够展示每个用户的朋友列表 * 循环引用：处理用户之间的双向引用，确保不产生循环引用 */fn home_work() &#123;    let a = User::new(&quot;Milk&quot;);    let b = User::new(&quot;Mark&quot;);    let c = User::new(&quot;Film&quot;);    a.add_friend(b.clone());    a.add_friend(c.clone());    b.add_friend(a.clone());    b.add_friend(c.clone());    c.add_friend(a.clone());    c.add_friend(b.clone());    a.list_friends();    b.list_friends();    c.list_friends();    // println!(&quot;a = &#123;:?&#125;&quot;, a);    // println!(&quot;b = &#123;:?&#125;&quot;, b);    // println!(&quot;c = &#123;:?&#125;&quot;, c);    // println!(&quot;a rc = &#123;:?&#125;&quot;, Rc::strong_count(&amp;a));    // println!(&quot;b rc = &#123;:?&#125;&quot;, Rc::strong_count(&amp;b));    // println!(&quot;c rc = &#123;:?&#125;&quot;, Rc::strong_count(&amp;c));&#125;\n\n运行结果：\n\n","slug":"smart-pointers-2","date":"2024-12-05T03:36:40.000Z","categories_index":"","tags_index":"smart-pointers","author_index":"Marnie"},{"id":"be46c1c387f4b8a2a5d0ca8494de6c20","title":"生命周期 Lifetime","content":"作用生命周期即指一个变量的有效作用范围，它和 Scope 的概念听起来会有点类似。Scope（作用域）规定了变量能被访问的范围，超出了定义作用域的地方是不能访问作用域内定义的变量的。而 Lifetime（生命周期）是针对引用变量的，它表示一个引用变量可存活的范围，简单说也就是，如果我压根不存在引用的变量，那我遵循作用域的限制就够用了。但是一旦出现了引用和被引用的关系，单纯作用域的概念不够使用，可能会产生悬垂引用之类的问题，于是 Rust 为了确保所有操作都是内存安全的，制定了生命周期的一套概念。\n悬垂指针 Dangling Pointer悬垂指针指的是引用了内存已被释放的变量，如下：\n12345678910111213fn main() &#123;    let r;    &#123;        let x = 5;        r = &amp;x;        // 🌟 drop(x) 这里在离开代码块前有一步隐藏的自动释放 x    &#125;    // r 指向的引用 x 在离开代码块后就会被释放    // 则以下代码访问 r 即产生了一个悬垂指针（dangling pointer）    // —— 访问了已被释放内存的变量    println!(&quot;This is a dangling pointer &amp;r &#123;&#125;&quot;, &amp;r);&#125;\n\n悬垂引用的本质是变量的存活时间，也可以说是作用域链长度，通常来说，存活时间更长的变量去引用比它存活时间短的变量就会容易发生这类问题，Rust 编译期间就会检查出每个变量的有效作用范围，来避免这类异常。\n函数中的生命周期我们来实现一个函数 longer，接收两个字符串切片，然后返回长度更大的字符串切片：\n1234567891011121314fn longer(a: &amp;str, b: &amp;str) -&gt; &amp;str &#123;    if a.len() &gt; b.len() &#123;        a    &#125; else &#123;        b    &#125;&#125;fn main() &#123;    let s1 = String::from(&quot;Hello&quot;);    let s2 = &quot;Rust&quot;;    let s3 = longer(s1.as_str(), s2);    println!(&quot;The longer string is &#123;&#125;&quot;, s3);&#125;\n\n我们得到如图的报错提示：\n\nMissing lifetime specifier 缺少生命周期标注，这是为什么？我们上段有讲过，Rust 需要确保所有操作都是内存安全。而如何确保？就会需要足够的信息来分析生命周期，确保只会有短生命周期引用长生命周期的情况。所以，在 Rust 中每个变量都会有它自己的生命周期，代表它能存活多久。\n那么讲回我们上面的 longer 函数，函数参数是两个变量 a 和 b，如果该函数没有返回值的情况下，那么这两个入参引用在函数执行完成后就无法被访问了，这是可以理解的。但我们现在给函数指定了返回一个字符串切片类型的变量，此时 Rust 编译器并不能分析出到底是返回入参 a 还是入参 b 还是别的什么情况，这些都是运行时才能确定的，这就导致了在静态编译期间 Rust 编译器判断不出返回值操作内存是否是安全的，这种状况对 Rust 来说是不允许的。\n于是就需要开发者手动的显式标注生命周期，让编译器在编译时至少了解返回的变量对应的是哪个生命周期，以此来通过编译期间的安全检查。\n📢 注意，生命周期标注并不会对变量的实际生命周期造成任何影响，仅是告知编译器及通过编译期间检查。\n生命周期标注 Lifetime Specifier写法：半个单引号 &#39;a\n123&amp;i32 // 一个引用&amp;&#x27;a i32 // 具有显式生命周期标注的引用&amp;&#x27;a mut i32 // 具有显式生命周期标注的可变引用\n\n我们来修改下 longer 函数，对它加上显式的生命周期标注：\n1234567891011121314151617// 显式的告诉编译器，a,b,返回值 都属于同一个生命周期// 因为返回值要么是 a 要么是 b// 生命周期标注和泛型一样，也需要前置声明 &lt;&#x27;a&gt; 后才能使用fn longer&lt;&#x27;a&gt;(a: &amp;&#x27;a str, b: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;    if a.len() &gt; b.len() &#123;        a    &#125; else &#123;        b    &#125;&#125;fn main() &#123;    let s1 = String::from(&quot;Hello&quot;);    let s2 = &quot;Rust&quot;;    let s3 = longer(s1.as_str(), s2);    println!(&quot;The longer string is &#123;&#125;&quot;, s3);&#125;\n\n运行结果，如下：\n\n那么可能会有疑惑，为什么我们之前的练习中，都没有需要显式生命周期标注的 case 呢？那是因为 Rust 编译器本身有自动推理生命周期的功能，并且如我们上面提到的“每个变量都有其对应的生命周期”，实际上我们定义的函数也会通过编译器被翻译，函数的每个入参都会被自动加上其对应的生命周期参数，而当我们并没有出现无法分析生命周期的情况时，在编译器自动推理能力范围内的 case 就不需要手动加上生命周期标注。\n这是因为，如果函数压根没有返回值，自然就不需要生命周期标注的加持了。如果有返回值，假设函数的返回值是引用类型，那么它也只可能有两种来源：\n\n函数某个入参的生命周期\n函数内某个新建变量的生命周期\n\n对于第一种情况，如果只有一个入参，那也就不需要生命周期标注（✨ 生命周期标注通常是出现在拥有多个生命周期的情况下的）。 而第二种情况，这是明显的悬垂指针，新建变量的生命周期仅在函数内部，函数外是无法对其进行引用的，直接会被编译器拒绝。\n这种无需手动进行生命周期标注的能力被称为 “生命周期消除（Lifetime Elision）”，是编译器为了简化开发者的使用而自动运用的。具体的，会自动使用生命消除能力需要符合三条具体规则，可以参考一下截图要求：\n（一般情况，只要编译器能通过编译，则证明无需手动进行生命周期标注）\n\n对 生命周期标注 的总结生命周期标注就是将函数的多个引用参数和返回值的作用域进行关联，一旦关联到一起后，Rust 便可以拥有充分的信息来分析和确保我们的操作是内存安全的。\n结构体中的生命周期当结构体中存在引用类型时，也会存在需要显式生命周期标注的 case：\n12345// 结构体加上生命周期标注struct Example&lt;&#x27;a, &#x27;b&gt; &#123;  x: &amp;&#x27;a str,  y: &amp;&#x27;b str,&#125;\n\n方法中的生命周期给 Example 结构体加上方法（methods）：\n1234567891011121314151617// 结构体加上生命周期标注struct Example&lt;&#x27;a, &#x27;b&gt; &#123;    x: &amp;&#x27;a str,    y: &amp;&#x27;b str,&#125;impl&lt;&#x27;a, &#x27;b&gt; Example&lt;&#x27;a, &#x27;b&gt; &#123;    // 这里我们并不需要标注因为我们的入参上含有 &amp;self 或者 &amp;mut self，    // 其实就是符合了我们上面指出过的第一种 case，该方法有引用类型的返回值，    // 无论是什么引用类型，只可能是来源于入参。    // 此时如果仅一个入参，那么它的返回值生命周期一定是 self 的生命周期，    // 且无论返回值有多少个，都一定只有一个生命周期。也就不需要手动添加生命周期标注了，    // self 的生命周期 —— 即当前 Example 结构体实例会被直接赋予给这个方法的返回值。    fn get_self(&amp;self) -&gt; &amp;Example &#123;        self    &#125;&#125;\n\n手动约束生命周期另外还有一种手动约束多个生命周期的语法 —— &#39;a: &#39;b 表示 &#39;a 活的比 &#39;b 时间长，用于当方法引用了多个生命周期的情况下，因为如果返回了一个较大的生命周期会产生悬垂引用，需要手动表明生命周期之间的关系：\n12345678910111213141516// beforeimpl&lt;&#x27;a&gt; MyStruct&lt;&#x27;a&gt; &#123;  // 方法返回值为&#x27;b, 且该方法引用了&#x27;a, 那么只有 &#x27;b 存活时间一定比 &#x27;a 短才不会引起悬垂引用。  // Rust 编译器并不能知道两者关系，需要手动加上生命周期约束。  fn foo&lt;&#x27;b&gt;(&amp;&#x27;a self, other: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123;   self.name &#125;&#125;// afterimpl&lt;&#x27;a: &#x27;b, &#x27;a&gt; MyStruct&lt;&#x27;a&gt; &#123;  fn foo&lt;&#x27;b&gt;(&amp;&#x27;a self, other: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123;   self.name &#125;&#125;\n\n特殊生命周期标注静态生命周期&#39;static 标注是指这是一个静态生命周期，拥有静态生命周期的引用就表示可以和整个程序存活的一样久。\n1let s: &amp;&#x27;static str = &quot;我没啥优点，就是活得久，嘿嘿&quot;;\n\n在 Rust 中，字符串字面量默认就是 静态生命周期，即不管字符串字面量定义在哪，它的生命周期默认都是整个程序存活期间。这里我们可以结合一个复杂点的例子来对比看下字符串字面量的生命周期和普通生命周期的差异。\n有如下两个函数，分别都返回第二个入参，对应也都加上了生命周期标注：\n1234567fn example&lt;&#x27;a&gt;(a: &amp;&#x27;a str, b: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;    b&#125;fn example2&lt;&#x27;a&gt;(a: &amp;&#x27;a i32, b: &amp;&#x27;a i32) -&gt; &amp;&#x27;a i32 &#123;    b&#125;\n\n我们写两个一样的 case，一个用字符串字面量测试 对应 example，一个用 i32 类型测试 对应 example2：\n123456789101112131415161718192021let s1 = &quot;Hello&quot;; // &#x27;staticlet result = &#123;  let s2 = &quot;Rust&quot;; // &#x27;static  let result = example(s1, s2);  result&#125;;// result 持有对 s2 的引用// 尝试能否访问println!(&quot;result is &#123;&#125;&quot;, result);let n1 = 3;  // i32let result = &#123;  let n2 = 9;  // i32  let result = example2(&amp;n1, &amp;n2);  result&#125;;// result 持有对 n2 的引用// 尝试能否访问println!(&quot;result is &#123;&#125;&quot;, result);\n\n编辑器有如下报错：\n\nn2 does not live long enough 可以看到 case2 外面的 result 持有了对 n2 的引用，那么就意味着 n2 的生命周期应该长于外部的 result，但 n2 是代码块内部定义的变量，它的存活范围仅在代码块内部，则无法通过编译检查。\n而同一个状况，因为 case1 中用到的是字符串字面量，字符串字面量本身的生命周期就是整个程序期间，这才通过了编译器的检查。\n占位符默认匹配生命周期当我们在实现方法时，如果并没有涉及多生命周期的情况，或者说都满足生命消除规则的条件下，其实就表示我们并不是很关心这个生命周期，这时候我们 impl  声明可以使用 _ 占位符来表示默认匹配的那个生命周期，不需要给定一个具体的生命周期标注名了，因为在内层方法的实现上我们也不需要用到手动标注。\n1234567891011struct Counter&lt;&#x27;a&gt; &#123;    count: &amp;&#x27;a mut i32,&#125;// 占位符匹配默认的生命周期// 该 Counter 结构体实例就一个生命周期impl Counter&lt;&#x27;_&gt; &#123;    fn add(&amp;mut self) &#123;        *self.count += 1;    &#125;&#125;\n\n练习巩固上面的理解，请修复下面的函数声明：\n\n改动代码如下：\n123456789101112131415fn test_lifetime_mut() &#123;  fn insert_value&lt;&#x27;a, &#x27;b: &#x27;a&gt;(my_vec: &amp;mut Vec&lt;&amp;&#x27;a i32&gt;, value: &amp;&#x27;b i32) &#123;    // ✅ 结论：my_vec 拥有对 value 的引用 =&gt; &#x27;b: &#x27;a 为函数添加生命周期约束通过编译器检查    my_vec.push(value);  &#125;    &#123;    // ✅ 根据上述结论，y 必须早于 x 定义    let y = 2;    let x = 1;    let mut my_vec = vec![&amp;x];    insert_value(&amp;mut my_vec, &amp;y);    println!(&quot;&#123;my_vec:?&#125;&quot;);  &#125;&#125;\n\n成功运行！\n\n","slug":"lifetime","date":"2024-12-04T10:16:46.000Z","categories_index":"","tags_index":"lifetime","author_index":"Marnie"},{"id":"ab26d33d9183b3dac0ad2f16b85bf6b4","title":"泛型 Generics","content":"函数中使用泛型泛型是实现让一个功能函数支持不同类型的手段，我们称之为多态。在不支持泛型时，我们可能会写出如下代码：\n1234567891011fn add_i32(a: i32, b: i32) -&gt; i32 &#123;    a + b&#125;fn add_f64(a: f64, b: f64) -&gt; f64 &#123;    a + b&#125;fn add_i8(a: i8, b: i8) -&gt; i8 &#123;    a + b&#125;\n\n上面是多个类型的 add 函数，因为类型的限制，我们需要为每种类型单独写一个函数。有了泛型之后，可以省去这样冗余的代码，泛型的声明格式：\n使用泛型参数，有一个先决条件，必需在使用前对其进行声明。\n使用前声明的意义是：表示我这个函数拥有多少泛型参数，如\n123fn add&lt;T&gt; // 表示当前 add 函数拥有一个泛型参数 Tfn foo&lt;T, R&gt; // 表示当前 foo 函数拥有两个泛型参数 T，R\n\n延用 add 函数，我们完善泛型声明后如下：\n\n我们得到了一个报错，cannot add T to T 因为泛型参数 T 可以是任何类型，但并不是所有类型都可以做加法这个行为，所以我们还需要对泛型参数 T 进行特征（Trait）限制，以表示这个类型是可以进行相加的。\n我们输入 add 可以看到相关的特征提示，add 特征也是支持泛型的，按照提示的示例，我们修改函数声明。\n\nAdd 是 use std::ops::Add 引入的，Add&lt;Output = T&gt; 我们把泛型参数 T 传入 Trait Add 的泛型声明中，整个泛型的声明就完成了。\n\n下面我们再尝试写一个复杂点的例子，实现一个输出数组中最大值的函数。\n123456789101112131415161718192021222324/** * 1. 声明泛型参数 T * 2. list 为类型为 T 的数组，用指针类型让数组参数在编译时期有一个确定的大小 * 3. 返回值为 T类型值 的引用 */fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T &#123;    // 默认最大值为数组第一个元素    let mut max = &amp;list[0];    // 遍历后续数组，逐个比较，出现更大的值则替换    for i in 1..list.len() &#123;        // 这里需要注意，需要限制泛型参数 T &lt;T: std::cmp::PartialOrd&gt;，要拥有比较大小的特征        if max &lt; &amp;list[i] &#123;            max = &amp;list[i];        &#125;    &#125;    max&#125;fn main() &#123;    let number_list = vec![1, 5, 9, 4, 7];    let max = largest(&amp;number_list);    println!(&quot;largest number is &#123;&#125;&quot;, max);&#125;\n\n运行后结果如下：\n\n结构体中使用泛型基于上面泛型的理解，我们直接看声明：\n1234567891011struct Point&lt;T&gt; &#123;  x: T,  y: T,&#125;// 上述类型声明表示，结构体 Point 的 fields 都是同一个类型的fn main() &#123;    let p1 = Point &#123; x: 1, y: 2 &#125;;  // Point&lt;i32&gt;    let p2 = Point &#123; x: 1.0, y: 2.0 &#125;;  // Point&lt;f64&gt;&#125;\n\n那么当我们需要 x, y 不同类型时，我们可以声明第 2 个泛型参数 U，如下：\n123456789101112struct Point&lt;T, U&gt; &#123;  x: T,  y: U,&#125;fn main() &#123;    let p1 = Point &#123; x: 1, y: 2 &#125;;  // Point&lt;i32&gt;    let p2 = Point &#123; x: 1.0, y: 2.0 &#125;;  // Point&lt;f64&gt;     // 这样既可以支持相同类型的情况，也可以支持不同类型的情况   let p3 = Point &#123; x: 1, y: 2.0 &#125;; // Point&lt;i32, f64&gt;&#125;\n\n枚举中使用泛型123456789enum Option&lt;T&gt; &#123;    Some(T),    None,&#125;enum Result&lt;T, E&gt; &#123;    Ok(T),    Err(E),&#125;\n\n方法中使用泛型123456789101112struct Point&lt;T, U&gt; &#123;    x: T,    y: U,&#125;// 这里 Point&lt;T, U&gt; 被视为一种结构体类型，所以在实现其方法时，// 也需要通过 impl&lt;T, U&gt; 提前声明泛型参数列表impl&lt;T, U&gt; Point&lt;T, U&gt; &#123;    fn x(&amp;self) -&gt; &amp;T &#123;        &amp;self.x    &#125;&#125;\n\n我们再加入一个复杂点的方法 mixup，功能是传入另一个 Point，然后输出它们交叉后的新 Point。交叉指的是，取原 Point 的 x 和传入 Point 的 y，组成一个新的 Point。\n123456789101112131415161718192021impl&lt;T, U&gt; Point&lt;T, U&gt; &#123;    fn x(&amp;self) -&gt; &amp;T &#123;        &amp;self.x    &#125;    // mixup 方法入参需要泛型参数 T2, U2   // 所以需要提前声明泛型参数列表 mixup&lt;T2, U2&gt;   // 返回值类型为交叉后的 Point&lt;T, U2&gt; 结构体类型    fn mixup&lt;T2, U2&gt;(self, other: Point&lt;T2, U2&gt;) -&gt; Point&lt;T, U2&gt; &#123;        Point &#123;            x: self.x,            y: other.y,        &#125;    &#125;&#125;fn main() &#123;    // 这里 mixup 并不需要手动传入类型，会根据入参 Point&lt;T2, U2&gt; 类型自动做类型推断    let p4 = p1.mixup(Point &#123; x: 9.0, y: &quot;Hello&quot; &#125;);    println!(&quot;p4.x = &#123;&#125;, p4.y = &#123;&#125;&quot;, p4.x, p4.y);&#125;\n\n运行结果，如下：\n\nconst 泛型意思是 常量的泛型，在诸如当我们只希望控制参数类型为一个整数 i32 数组，但数组长度不需要固定的情况可以使用，看具体例子：\n12345678910111213// usize 表示索引类型fn display_array&lt;const N: usize&gt;(list: &amp;[i32; N]) &#123;    println!(&quot;&#123;:?&#125;&quot;, list);&#125;fn main() &#123;    // 打印一个数组    let a1 = [1, 2, 3];    display_array(&amp;a1);    let a2 = [9, 8, 7, 6];    display_array(&amp;a2);&#125;\n\n运行结果，如下：\n\n泛型代码的性能使用泛型给开发者带来了很多便利，在开发效率上无疑是提效的。而泛型代码虽然输入是一种模式，但是经由 Rust 编译器，实际会被翻译成 n 种，所有可支持的情况都会有一份代码，这个翻译的过程被称为 单态化，即声明时是 多态的，编译后即变为 单态。同时也就意味着，在运行时其实是不会因为泛型带来任何增加的开销的，因为编译期间都生成好了，对应的调用代码调用的也就是那一份翻译后的代码。所有的开销都是在编译期间产生的（编译时间及编译后文件大小会有所增加），运行期间无损，仍然保持高效。\n","slug":"generics","date":"2024-12-02T13:12:41.000Z","categories_index":"","tags_index":"generics","author_index":"Marnie"},{"id":"3b2621a700dd1210cc1c1a2ba961dd42","title":"First Project","content":"Getting Started安装 anchor —— Solana 智能合约框架\n1.用 cargo 安装 avm ，Anchor 版本管理器\n1cargo install --git https://github.com/coral-xyz/anchor --tag v0.30.1 anchor-cli\n\n2.使用 avm 安装最新版本 anchor\n1avm install latest\n\n3.检查安装好的版本\n1anchor --version\n\nTrouble Shooting\nerror: no such command: build-sbf\n12cargo buildcargo build-sbf --force-tools-install\n\n\n\n","slug":"first-project","date":"2024-11-01T08:06:44.000Z","categories_index":"","tags_index":"setup","author_index":"Marnie"},{"id":"2e2bd34ffcfc46d5575f7c18eed689f5","title":"智能指针 Smart Pointers","content":"首先理解，指针是什么？指针是一个存储了内存地址（memory address）的变量，该内存地址引用或者指向了内存中另外的数据。\n在 Rust 中最常见的指针就是引用（reference），引用变量向被它引用的变量借用（borrow）它指向的数据，这意味着它们自身是没有对该数据的所有权（ownership）的。\n引用只包含一个指向被引用变量的指针，除此之外，引用就再无其他功能了。而 Rust 是静态编译语言，在编译期间就需要确定变量数据的大小以及何时释放。所以设计了智能指针，在普通指针的基础上，还包含了当前长度（len）、最大长度（capacity）等字段，这些都是用来确定指针类型指向的那块数据所需的内存 size 的字段。像是我们之前用过的 String 、Vec 都是智能指针数据类型。\n不同于普通指针，智能指针是具有所有权的指针，且实现了 Deref（解引用）和 Drop（清理）两个 trait（特征），这使得他们可以像指针一样解引用并在离开作用域是自动清理资源。这是对智能指针是什么的一个大致概括，具体功能可以通过后面更多的实际例子去理解更为自然。\n为什么存在智能指针？性能管理 — 处理大体量的数据栈是我们用于快速读写的内存空间，并不适合存储过大的数据。相对来说，简单的数据类型会被分配在栈上，但针对简单却大体量数据，我们就不应该再继续存储在栈上了，栈溢出会引起程序的崩溃。\n1234567/*大体量数据，长度为 1_000_000 的数组，数组默认是分配的栈内存*/let arr_stack = [0; 1000000];for i in arr_stack &#123;  println!(&quot;&#123;&#125;&quot;, i);&#125;\n\n运行代码，我们会得到如下报错：\n\n正如前面所说 —— 栈溢出，程序中止运行了。\n处理更复杂的数据结构Rust 是静态编译语言，这意味着它在编译时期就是需要知道每个数据所需内存大小，而针对一些复杂的数据结构，如递归结构、分享结构【❓TODO 这是啥】等，是没有固定大小的，而智能指针就是为了解决这一问题设计的。\n举个例子，常规 enum ，因为一次只会使用 enum 的某一个值，所以该 enum 的所需内存大小取决于其下面内存占用最大的一个枚举值。\n12345678910enum Message &#123;  Quit,  Move &#123; x: i32, y: i32 &#125;,  Write(String),  ChangeColor(i32, i32, i32),&#125;// enum Message 中所需内存最大的是 ChangeColor，// 则该 enum 所需内存为 ChangeColor 所需的内存大小let a = Message::Quit;\n\n更复杂的数据结构，递归 enum 类型\n1234enum List &#123;  Cons(i32, List), // 动态大小，无法确定 size  Nil,&#125;\n\n对于递归 enum 来说，基于我们前面计算 enum 大小的方式，会发现我们并不能知道哪个是内存大小最大的枚举值，递归的枚举值是动态的，所以我们无法得出递归类型的数据大小。\n【TODO】在普通指针基础上，完善更多的功能❓TODO：所有权、悬垂指针、动态大小？\n【TODO】RC 智能指针智能指针是 Rust 确保其安全性的一种方式。智能指针是一种包裹了数据和提供了一些额外功能的数据结构，例如所有权（ownership）和引用计数（reference counting）。Rust 设计了多种智能指针的数据类型，适用于多种不同的场景。\nBox Smart PointerBox 智能指针是 Rust 中智能指针的一种，它是在栈上拥有固定大小的指针，但其指向的数据，在堆上可以是任意大小的数据。所以当我们使用了 Box 智能指针，我们是可以在编译时就知道所需内存大小的。因此上面说到的编译时无法计算内存大小的问题，便就迎刃而解了。\n我们将改写上面递归 enum 的例子，用 Box 智能指针来解决问题：\n12345678910111213// 将递归嵌套的 List 类型改写成 Box&lt;List&gt; 智能指针类型// 智能指针在栈侧是拥有固定大小的指针，可以顺利通过编译enum List &#123;  Cons(i32, Box&lt;List&gt;),  Nil,&#125;use List::&#123; Cons, Nil &#125;;fn main() &#123;  // Box::new() 创建 Box 智能指针类型变量  let list = Cons(1, Box::new(Cons(2, Box::new(3, Box::new(Nil)))));&#125;\n\n智能指针之所以功能强大，还因为 Rust 为其实现了两种特征（trait），Deref Trait 和 Drop Trait，让我们一起了解下。\nThe Deref TraitDeref Trait 解引用是为了让智能指针能像普通指针一样使用而实现的特征（trait）。这句话有两个关键点：\n\n什么是 trait（特征）？\n\n什么叫像普通指针一样使用？\n\n\n我们逐一了解一下：）\nTraits 特征 特征（traits）是 Rust 设计出可以让不同类型拥有相同行为（behavior）的一种实现，在描述某种或者说某类行为时可以包含1个或者多个方法（methods），即特征就是我们用来使得不同类型能够共享（sharing）同一批方法的手段。\n我们看一下 trait 的例子：\n123456pub trait TraitA &#123;  fn method_A(&amp;self) -&gt; String;  fn method_B(&amp;self) -&gt; String &#123;    String::from(&quot;Hello&quot;)  &#125;;&#125;\n\n一般我们描述 trait 时，会包含一个或多个方法的签名，如果对方法写了具体实现，则作为该方法的默认行为。我们也可以在具体类型上重写（overwrite）特征下的方法，来自定义不同类型上的实现。\n1234567891011121314151617181920212223struct StructA &#123;    name: String,&#125;// once impl A for B means B is shared with all methods in Aimpl TraitA for StructA &#123;    // overwrite method_A of trait TraitA    fn method_a(&amp;self) -&gt; String &#123;        String::from([&quot;I&#x27;m&quot;, &amp;self.name].join(&quot; &quot;))    &#125;&#125;fn main() &#123;  let a = StructA &#123;    name: String::from(&quot;aaa&quot;),  &#125;;    // call the methods of trait  let name = a.method_a();  println!(&quot;&#123;&#125;&quot;, name);    a.method_b(); &#125;\n\nRust 定义很多内置的特征，并为我们提供了 derive 属性，用于在一个 struct 或 enum 上生成对某个 trait 的实现的相关代码，这里的代码就是将该 trait 所拥有的默认实现复制过来。这样我们就能快速的拥有一个 trait 的所有默认行为，内置的特征需要通过 use xxx 导入之后使用。\n像普通指针一样使用其实指的就是，可以对于指针变量使用 * 操作符，我们知道因为所有权的关系，我们只能对指针类型的变量进行借用：\n123let x = String::from(&quot;Hello&quot;); // Stringlet y = &amp;x; // &amp;Stringprintln!(&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;, x, y, x == y); // ❌ [ERROR] can&#x27;t compare `String` with `&amp;String`.\n\n这里编译会报错，因为第 3 行无法将不同类型的两个值进行比较，x 是 String 类型，而 y 是 a reference to String。\ny 就是借用了 x，借用就意味着其实就只是拿到了一个内存地址，那么当我们需要直接使用数据时（如：上面做比较的场景 x &#x3D;&#x3D; y）就需要用 * 操作符做解引用，拿到内存地址对应的数据：\n123let x = String::from(&quot;Hello&quot;); // Stringlet y = &amp;x; // &amp;Stringprintln!(&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;, x, y, x == *y); // ✅\n\n除了 * 操作符实现了 deref，还有包括我们经常使用的 . 操作符，是默认带有解引用功能的，通过例子看一下：\n\n可以看到，当我们在使用 . 操作符时，会得到自动解引用之后的结果（倒数第 2 行），并且最后一行我们看到，无论是多加了多少层的引用，都能得到最终指向的那块数据。这就是 . 操作符上带有的魔法之一 —— 自动解引用。\n为了更好的理解解引用特征，我们手动还原一个自己的 MyBox 智能指针类型。\n手动还原 Box 智能指针首先，MyBox 是一个结构体，它只有一个字段 —— 被他包裹的类型，且不需要字段名，即我们采用元组结构体（tuple struct）构造 MyBox。这里还需要使用泛型 T，被包裹的类型是由调用的时候传入的。\n\n\n\n\n\n\n\n\n\n这一部分需要补充泛型（generics）的内容，可以参考 https://course.rs/basic/trait/generic.html\n使用泛型的规范是，先声明 xxx&lt;T&gt; 后使用 structNameXXX(T)、functionNameXXX(x: T) 等。\n1struct MyBox&lt;T&gt;(T);\n\n接着实现 new 方法，在 Rust 中使用 impl 来定义方法，如 impl Circle ，泛型用 impl&lt;T&gt; Circle&lt;T&gt; 。\n12345impl&lt;T&gt; MyBox&lt;T&gt; &#123;    fn new(x: T) -&gt; MyBox&lt;T&gt; &#123;        MyBox(x)    &#125;&#125;\n\n下一步，在 MyBox 上实现 deref trait ，可以参考官网 Deref Trait 给出的示例实现：\n\n1234567impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123;    type Target = T;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123; // Target 就是目标类型 T        &amp;self.0 // 因为 MyBox 是元组结构体，对应的值 self.0    &#125;  // 注意：解引用并不会涉及所有权转移，返回的值还是一个引用值&#125;\n\n现在我们就可以在 MyBox 类型变量上使用解引用功能了，让我们试下:\n1234567fn main() &#123;    let n = MyBox::new(String::from(&quot;Marnie&quot;));    println!(&quot;&#123;:?&#125;&quot;, n);    let a = String::from(&quot;Marnie&quot;);    println!(&quot;Are &#123;&#125; and &#123;&#125; equals? &#123;&#125;&quot;, a, *n, a == *n);&#125;\n\n\n以上就是模拟 MyBox 并实现 Deref Trait 的大致过程，当我们使用 *v 时，就会去 v 对应的类型 T 上找 deref 方法，即 *(v.deref())，所以但凡是实现了 Deref Trait 的类型变量都可以使用 * 操作符来解引用。\n在官网关于”使用 Deref Trait 将智能指针像常规引用一样对待”有很详细的介绍，细节可以更多的参考 https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait，这里再提一点比较重要的内容：\nImplicit Deref Coerions 隐式的强制解引用在 Deref Trait 相关内容下，有一个知识点叫 Deref coerion 强制解引用，意思是在某些场景下，Rust 会自动发生解引用。\n这里会发生自动解引用的场景是在变量作为参数传入方法 methods 或者函数 functions 时，若传入变量类型实现了 Deref Trait，变会发生自动解引用的行为。我们分析看下官方的例子：\n123fn hello(name: &amp;str) &#123;    println!(&quot;Hello, &#123;&#125;!&quot;, name);&#125;\n\n这里写了一个 hello 函数，接收 string slice 类型的参数，如果我们继续用前面 MyBox 的实例 n 传入 hello 函数 hello(&amp;n)，如：\n123456fn main() &#123;    let n = MyBox::new(String::from(&quot;Marnie&quot;)); // MyBox&lt;String&gt;    println!(&quot;&#123;:?&#125;&quot;, n);    hello(&amp;n); // 🤔...&#125;\n\n我们会发现，编辑器并没有提示任何编译错误，这里就是强制解引用的作用。\n首先，我们传入的 n 本身是个 MyBox&lt;String&gt; 类型，按照强制解引用的发生规则 —— 当我们将某个类型作为参数传入函数或者方法时，会自动发生解引用。MyBox类型的解引用实现我们前面已经还原了，那么这一步强制解引用就相当于调用 n.deref()，则 &amp;n 从 &amp;MyBox&lt;String&gt; -&gt; &amp;String，这么看起来还是不对呀，目标参数接收的是 String Slice，现在还只是 String。好，这里注意 📢，当类型上实现了 Deref Trait 的话强制解引用会一直继续自动发生，即可能发生连续的解引用。\n我们上一步强制解引用得到的是类型 String，在标准库里 String 也对应实现了 Deref Trait ，所以会再次做强制解引用，我们可以查看官网看到标准库中对于 String 上 Deref Trait 实现的签名描述：\n\n可以看到 String 的 deref 方法返回 string slice 类型，所以才满足了 hello 函数，并不会有编译问题。\n关于这个连续强制解引用，我尝试再用一些自定义的类型例子来验证一下是否如此：\n1234567891011121314151617181920212223242526272829303132333435363738394041use std::ops::Deref;struct TypeA(i32); // i32struct TypeB(TypeA); // TypeAstruct TypeC(TypeB); // TypeBimpl Deref for TypeA &#123;    type Target = i32;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;        println!(&quot;calling TypeA&#x27;s deref&quot;);        &amp;self.0    &#125;&#125;impl Deref for TypeB &#123;    type Target = TypeA;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;        println!(&quot;calling TypeB&#x27;s deref&quot;);        &amp;self.0    &#125;&#125;impl Deref for TypeC &#123;    type Target = TypeB;    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;        println!(&quot;calling TypeC&#x27;s deref&quot;);        &amp;self.0    &#125;&#125;fn test(x: &amp;i32) &#123;    println!(&quot;I get &#123;&#125;&quot;, x);&#125;fn main() &#123;  let a = TypeA(0);  let b = TypeB(a);  let c = TypeC(b);    test(&amp;c);&#125;\n\n我写了上述的这些代码，企图验证是否会有连续的强制解引用发生。按照我上个段落的结论，我预想的 将 c 作为参数传入 test 函数，c 的类型 TypeC 上又有 deref trait 的实现，那么连续的强制解引用将会是 TypeC -&gt; TypeB, TypeC -&gt; TypeA, TypeA -&gt; i32，我们可以看到编译器首先并没有提示类型错误，我们再运行看看：\n\n如结果所示，印证了预想，那么这就是一个连续的强制解引用的过程。Rust 之所依提供这个隐含的功能就是为了让我们省去手动做”连续的类型转换”的过程。我们再强调一下，这个强制类型转换发生需要符合的条件：\n\n&amp;T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt;  T 上有返回类型为 U 的解引用实现\n&amp;mut T -&gt; &amp;mut U ===&gt; T: DerefMut&lt;Target=U&gt;  T 上有返回类型为 U 的可变解引用实现\n&amp;mut T -&gt; &amp;U ===&gt; T: Deref&lt;Target=U&gt; T 上有返回类型为 U 的解引用实现（可变的类型可以转换为不可变类型，但不可变不能转换成可变）\n\nThe Drop Trait除了 Deref Trait 外，智能指针还拥有 Drop Trait。Drop Trait 是 Rust 设计用于内存管理的特征，当一个变量超出 scope 之后，自动释放其占用的内存。Drop Trait 的实现和 Deref Trait 异曲同工，本质也是执行该 Trait 下对应的 drop method , 当我们需要自定义释放内存的场景就可以手动实现 drop method ，让我们一样用例子看一下：\n1234567891011121314151617181920212223use std::ops::Drop;#[derive(Debug)]struct CustomSmartPointer &#123;    data: String,&#125;impl Drop for CustomSmartPointer &#123;    fn drop(&amp;mut self) &#123;        println!(&quot;CustomSmartPointer of data &#123;&#125; is dropping...&quot;, self.data);    &#125;&#125;fn main() &#123;    let c1 = CustomSmartPointer &#123;        data: String::from(&quot;c1&quot;),    &#125;;    println!(&quot;&#123;:?&#125; is created.&quot;, c1);    let c2 = CustomSmartPointer &#123;        data: String::from(&quot;c2&quot;),    &#125;;    println!(&quot;&#123;:?&#125; is created.&quot;, c2);&#125;\n\n运行结果如下：\n\n结合所有权系统，当一个变量离开作用域以及不存在对其的任何引用，Rust 会自动释放变量占用的内存，这样就无需开发者手动管理内存。我们上面的代码就可以看到这个效果，内存释放是按照变量出栈顺序，即先进后出，创建顺序是 c1 -&gt; c2，销毁顺序则是 c2 -&gt; c1，如打印结果所示。\n这里有一点需要注意，因为 Rust 已经有一套合理管理内存的机制 —— 离开作用域内存会自动被释放，所以是不支持我们直接手动调用 xxx.drop() 来释放内存的，这样会导致双重释放内存的错误（a double free error）。\nTrait Objects虽然 Rust 强调静态类型编译，需要有明确的数据类型，但为了实现代码的多态性，Rust 也提供了一种方案可以动态调度（dynamic dispatch）类型，它就是 Trait Objects。首先我们理解一下什么是动态调度：\nDynamic dispatch 动态调度动态调度表示在编译时并不知道具体类型，而是在运行时才能确定类型。它与 static dispatch 相对，static dispatch 静态调度是指在编译时就已经确定了类型，一般我们没有特别处理的都属于静态调度，变量的类型是明确的，函数的入参类型也是确定的，所有的类型都是编译时就已经固定了的。而动态调度需要使用关键字 dyn ，来表示这是一个动态调度类型，我们需要结合 Trait Objects 这个概念一起使用。\nTrait Objects 是 Rust 提供应对有着同样行为的但所属不同类型的变量的事务，用官方的例子，比如我们现在要实现一个前端框架库，我们会拥有很多 components 组件，每个组件都是一个类型。\n因为组件会有很多种，比如 Button、Select、Input，我们在声明 components 类型的时候，首先它是个可以更改长度的 list，所以 components: vec![???]，好了，这里就有一个问题出现了！vec! 里面的类型并不是我们以往固定的某一种类型，它可能是 Button/Input/Select 等等，这种情况我们就需要使用动态调度，表示这里的类型不是某一个固定类型，是多种类型。\n具体使用方式，用 dyn 关键字表示这里是动态调度，dyn 后面跟的类型是一个 trait，dyn xxxTrait 则表示当前是一个 trait objects 类型。trait（特征）我们在上面有单独介绍，它用来描述某种行为，那么 trait objects 其实就是拥有同种行为的不同类型的对象，本质就是不同类型都对同一个 trait 进行了实现。我们上面这个组件的例子，就是 Trait Objects 的一个标准案例，组件本身都是不同的类型，但是它们都至少有某个或某些相同的行为，比如绘制功能，那么实现时就可以把绘制作为一个 trait，这些组件都有对于 绘制trait 的实现，这些组件便可以通过 dyn Draw 视为同一个 trait object 类型。但因为 trait 本身没有固定大小，所以它必须结合指针类型使用（指针类型拥有固定大小），如 Box&lt;dyn Draw&gt; 表示 Draw trait objects 类型。\n用这个场景，我们具体实现下代码来理解：\n1234567891011121314151617181920212223242526272829303132333435363738// 绘制traittrait Draw &#123;  fn draw(&amp;self);&#125;// Button类型struct Button &#123;  width: u32,  height: u32,  label: String,&#125;// Select类型struct Select &#123;  width: u32,  height: u32,  options: Vec&lt;String&gt;,&#125;// 都会继承绘制traitimpl Draw for Button &#123;  fn draw(&amp;self) &#123;    // do Button&#x27;s drawing stuff   &#125;&#125;// 都会继承绘制traitimpl Draw for Select &#123;  fn draw(&amp;self) &#123;    // do Select&#x27;s drawing stuff   &#125;&#125;// 框架库类struct Library &#123;  // components list  components: Vec&lt;Box&lt;dyn Draw&gt;&gt;, // a list of &quot;Draw trait objects&quot;&#125;\n\n这就是【动态调度 + trait objects】的使用方法，这种方式本质上其实是让我们有了可以同时使用不同的类型的能力，这就是动态调度的魔法。和泛型（generics）的不同之处就是这里，泛型只是声明时的多态，在调用时一次传入的还只是同一个类型，而动态调度是一次调用能传入多种类型，实现了真正的运行时多态。\n练习作业2\n实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163use std::ops::DerefMut;use colored::Colorize;fn main() &#123;    trait FileSystem &#123;        // type Output;        fn create_file(&amp;mut self, name: &amp;str) -&gt; &amp;Node;        fn create_folder(&amp;mut self, name: &amp;str) -&gt; &amp;Node;        fn list_contents(&amp;self);        fn find_folder(&amp;mut self, name: &amp;str) -&gt; Option&lt;&amp;mut Self&gt;;    &#125;    #[derive(Debug)]    enum Node &#123;        // 文件        File(String),        // 文件夹        Folder(FolderNode),    &#125;    #[derive(Debug)]    struct FolderNode &#123;        name: String,        contents: Vec&lt;Box&lt;Node&gt;&gt;,    &#125;    impl FileSystem for FolderNode &#123;        // 在当前文件夹下创建单个文件        fn create_file(&amp;mut self, name: &amp;str) -&gt; &amp;Node &#123;            self.contents.push(Box::new(Node::File(String::from(name))));            println!(&quot;/&#123;&#125; 添加文件 &#123;&#125;&quot;, self.name, name);            self.contents.last().unwrap()        &#125;        // 在当前文件夹下创建文件夹        fn create_folder(&amp;mut self, name: &amp;str) -&gt; &amp;Node &#123;            self.contents.push(Box::new(Node::Folder(FolderNode &#123;                name: String::from(name),                contents: vec![],            &#125;)));            println!(&quot;/&#123;&#125; 添加文件夹 &#123;&#125;&quot;, self.name, name);            self.contents.last().unwrap()        &#125;        // 返回值是一个可变的 FolderNode，因为可能需要继续修改 folder 内容        fn find_folder(&amp;mut self, target_name: &amp;str) -&gt; Option&lt;&amp;mut FolderNode&gt; &#123;            // 声明返回值为可变的，初始为 None            let mut target: Option&lt;&amp;mut FolderNode&gt; = None;            // 遍历子目录，iter_mut() 允许返回可变的遍历对象            for node in self.contents.iter_mut() &#123;                // deref_mut() 允许返回解引用后并可变的值                match node.deref_mut() &#123;                    Node::Folder(folder) =&gt; &#123;                        if folder.name == target_name &#123;                            target = Some(folder);                            break;                        &#125;                    &#125;                    _ =&gt; &#123;                        continue;                    &#125;                &#125;            &#125;            // log error            if target.is_none() &#123;                println!(&quot;&#123;&#125;&quot;, &quot;[ERR] Cannot find this folder!&quot;.red());            &#125;            target        &#125;        // 列出文件夹下所有文件和文件夹（递归 recursion）        fn list_contents(&amp;self) &#123;            println!(&quot;======== /&#123;&#125; 当前目录结构 ========&quot;, self.name);            // print current folder name            println!(&quot;/&#123;&#125;&quot;, self.name);            // 打印单个 node 下的内容，因为需要打印目录结构，子目录需要使用递归            fn print_node(level: usize, node: &amp;Node) &#123;                // 除 root 外（非根目录），目录结构前缀逐级添加 &#x27;|[][][][]&#x27;                let mut level_prefix = String::with_capacity(5 * level);                // level &gt; 1 need append space prefix                for _ in 1..(level) &#123;                    level_prefix.push_str(&quot;|    &quot;);                &#125;                match node &#123;                    // 当前 node 是文件，没有子目录                    Node::File(file_name) =&gt; &#123;                        // print current file name                        println!(&quot;&#123;&#125;&#123;&#125;&quot;, level_prefix, file_name);                    &#125;                    // 当前 node 是文件夹，子目录需要继续调用 print_node                    Node::Folder(folder) =&gt; &#123;                        // print current folder name                        println!(&quot;&#123;&#125;/&#123;&#125;&quot;, level_prefix, folder.name);                        folder                            .contents                            .iter()                            .for_each(|n| print_node(level + 1, n));                    &#125;                &#125;;            &#125;            match self.contents.len() &#123;                // 空文件夹                0 =&gt; &#123;                    return;                &#125;                // 当前为有内容的文件夹                _ =&gt; &#123;                    for (_, content) in self.contents.iter().enumerate() &#123;                        // 当前文件夹 level 1，子文件夹 initial level = 2                        print_node(2, &amp;content);                    &#125;                &#125;            &#125;            println!(&quot;================ END =================&quot;);            println!();        &#125;    &#125;    let mut root = FolderNode &#123;        name: String::from(&quot;root&quot;),        contents: Vec::new(),    &#125;;    // base on root    &#123;        root.create_file(&quot;file_1.txt&quot;);        root.create_file(&quot;file_2.txt&quot;);        root.create_folder(&quot;folder_1&quot;);        root.create_folder(&quot;folder_2&quot;);        root.list_contents();    &#125;    // base on root/folder_1    &#123;        let folder_1 = root.find_folder(&quot;folder_1&quot;).unwrap();        folder_1.create_file(&quot;file_11.txt&quot;);        folder_1.create_file(&quot;file_12.txt&quot;);        folder_1.create_folder(&quot;folder_11&quot;);        folder_1.list_contents();        let folder_11 = folder_1.find_folder(&quot;folder_11&quot;).unwrap();        folder_11.create_folder(&quot;folder_111&quot;);        folder_11.list_contents();    &#125;    // base on root/folder_2    &#123;        let folder_2 = root.find_folder(&quot;folder_2&quot;).unwrap();        folder_2.create_file(&quot;file_21.txt&quot;);        folder_2.create_file(&quot;file_22.txt&quot;);        folder_2.create_folder(&quot;folder_21&quot;);        folder_2.list_contents();    &#125;    root.list_contents();    &#123;        println!(&quot;Test finder_folder error case&quot;);        root.find_folder(&quot;not_exist&quot;);    &#125;&#125;\n\n运行结果\n","slug":"smart-pointers","date":"2024-10-24T07:41:13.000Z","categories_index":"","tags_index":"smart-pointers","author_index":"Marnie"},{"id":"1f5f42bbe18d84ce044c457f49d8e22c","title":"Rust 基础 Rust Basic","content":"入门 Getting StartedRust静态类型语言（statically typed）：在编译时就确定了所有表达式的类型\n强类型语言（strongly typed）：一切皆需要明确的类型声明\n\nrustc：rust 编译器（compiler）\n\n检查 rust 是否安装成功：rustup --version\n将某个 rust 文件编译成二进制（binary）文件：rustc &lt;file_name&gt;.rs\n\n\nrustup：rust 安装器和版本管理工具\n\nrustup update 升级 rust\nrustup doc 打开本地 rust 文档\n\n\n命名规则（naming rule）：蛇形式（snake_case）\n\n语句（statement）：一定要加分号（semicolon），表示执行某个操作但没有返回值的某个指令\n\n表达式语句：以分号结尾的表达式\n声明语句\n\n\n表达式（expression）：主要用于计算求值（expression-base language）\n\n\nCrate用 rust 写的库或者可执行程序 a rust library or executable program\ncrate.io - rust 官方包注册表\nCargorust 包管理器 rust package manager\n\n支持管理项目依赖 cargo update\n支持编译、运行项目 cargo build, cargo run\n支持上传 crates.io cargo publish\nCargo.toml：dependencies declaration file\n\n1234567891011// setup a new project dircargo new &lt;project_name&gt;// compile project [debug or release version]cargo build [--release]// compile project and execute [debug or release version]cargo run [--release]// update all dependencies (keep semi-version 0.8.5 -&gt; 0.8.latest)cargo update\n\n通用概念 Common Concepts变量 Variables默认都是不可变变量（immutable variables），不用声明类型\n12let x = 5;println!(&quot;The value of x is: &#123;&#125;&quot;, x);\n\n声明可变变量（mutable variables），在运行时才会确定变量的值\n12345let mut x = 5;println!(&quot;The value of x is: &#123;&#125;&quot;, x);x = 6; // 若这句不运行，则 x 值还是 5println!(&quot;The value of x is: &#123;&#125;&quot;, x);\n\n作用域规则 Scoping Rules作用域是一个变量在程序中的有效范围，从变量声明的点开始知道当前作用域的结束就是一个有效范围。\n作用域范围一般分为 函数作用域、代码块作用域。\n不可变变量、可变变量、常量都是遵循这个作用域规则\n123456789101112fn foo() &#123;  let foo_global_variable :i32 = 1;    &#123;    // the start of the block    let foo_local_variable :i32 = 2; // defined in current block, only can access in current block    println!(&quot;The value of foo_global_variable is: &#123;&#125;&quot;, foo_global_variable); // ✅ access anywhere within foo_block    println!(&quot;The value of foo_local_variable is: &#123;&#125;&quot;, foo_local_variable);  &#125; // the end of the block    println!(&quot;The value of foo_local_variable is: &#123;&#125;&quot;, foo_local_variable); // ❌ outer of the block&#125;\n\n遮蔽 Shadowinglet 不可变变量支持重定义（遮蔽 shadowing）：虽然是不可变变量，但是可以用过去的值重新赋值，且可更改类型（与 mut 的不同之处）\n12let spaces = &quot;   &quot;;let spaces = spaces.len();\n\n块内遮蔽（shadowing）也遵循作用域规则，块内重定义变量的操作结果对外是屏蔽的，在块外访问到的还是原值\n123456789101112fn foo() &#123;    let x: i32 = 1;    &#123;        // the start of the block       // 遮蔽（shadowing）        let x = x + 1;        println!(&quot;The value of x is: &#123;&#125;&quot;, x); // ✅ The value of x is: 2    &#125; // the end of the block    println!(&quot;The value of x is: &#123;&#125;&quot;, x); // ✅ The value of x is: 1&#125;\n\n常量 Constants声明常量必须要带类型（data types）注释（annotation），在编译时期就确定了变量的值，命名规范大写蛇形式（UPPER_SNAKE_CASE）\n编译后是直接替换值\n1234// u32: unsigned 32-bit integer 无符号32位整数const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;println!(&quot;&#123;&#125;&quot;, THREE_HOURS_IN_SECONDS); // 🎯 编译后：println!(&quot;&#123;&#125;&quot;, 60 * 60 * 3)\n\n静态变量 Static特点如上同常量\n作用域（scope）：在整个程序中共享，可以再多个线程之间共享 —— 即 全局变量！！\n编译后是指向引用地址\n123static A : i32 = 1; // 假设这个 static 变量分配的内存地址为 0x123println!(&quot;&#123;&#125;&quot;, A); // 🎯 编译后：存在对 A 的引用，指向 A 的内存地址\n\n数据类型 Data Types原始类型 Primitive Types整数型 Integer Types默认 i32\n如果可能是负数则用 i[bit]，反之用 u[bit]，位数由运行代码的电脑决定\n1// TODO: 二进制位数和[整/负]数大小范围的关系\n\n浮点数型 Floating-Point Types默认 f64\n12let x = 2.0; // f64let y: f32 = 3.0; // f32\n\n布尔型 The Boolean Types123// both are 👌🏻let a = true;let b: bool = true;\n\n文本类型 Textual Typeschar 字符型\nunicode 编码，1 char &#x3D; 4 bytes，默认单引号包裹的文字（单个文字）表示字符型变量，也可以显式声明类型,\n123let c = &#x27;z&#x27;;let z: char = &#x27;ℤ&#x27;;let heart_eyed_cat = &#x27;😻&#x27;;\n\n复合类型 Compound Types🕵🏻‍♂️ ：下面字符串类型建议看完所有权部分知识，再去理解比较好！！\nCharacter encoding format\nASCII：1 character &#x3D; 7 bits binary，total 128 characters（max decimal number of 7-bit binary number）\nUTF-8：1 character &#x3D; 1～4 bytes &#x3D; (1～4) x 8 bits，total 1,112,064 character\n\n🎯 TODO：Memory management &amp; ownership in Rust\nhttps://www.linkedin.com/pulse/memory-management-rust-amit-nadiger#:~:text=The%20.,string%20literals%20and%20other%20constants.\n【TODO】compile binary –&gt; read-only memory 是什么？\n【TODO】Machine words 是什么？\n【TODO】Rc smart pointer  reference counted pointer\nVisualizing memory layout of Rust’s data types\nString 文本字符串型一串动态长度的 UTF-8 编码序列，用来表示文本字符串。UTF-8 编码规则用 1～4 个字节表示一个字符，是默认拥有所有权的类型。\n动态分配大小所以存储在 heap 上，对应栈上的变量存储指针（ptr &#x3D; 内存地址）、长度（len &#x3D; 实际长度）、容量（capacity &#x3D; 可用长度）。\n123456789// String 类型值内置了修改和其他的各种方法// mutable variablelet mut s: String = String::from(&quot;hello&quot;);// modify string ss.push(&#x27;!&#x27;);// replace first character of string ss.replace_range(0..1, &quot;H&quot;);// check the resultprintln!(&quot;s = &#123;&#125;&quot;, s);  // ✅ 输出：s = Hello!\n\nString Slice 文本字符串切片类型我们把某个字符串的某段字符串称为 slice（字符串切片&#x2F;字符串片段）。上面提到的，文本字符串本身是动态长度的 UTF-8 编码序列，且拥有数据的所有权。当我们只需要借用字符串文本数据本身时，我们需要使用 &amp;str 类型，它包含指针（ptr &#x3D; 该 slice 第一个字符在内存中对应的地址）、长度（len &#x3D; 从第一个字符开始，一共多少个字符），slice 因为是借用关系，本身是不可变的。字符串本身是动态大小的类型，有了 slice 的借用类型之后，编译时就可以计算出对应字符串所占字节大小，这对 Rust 这种强静态编译语言是必需的。它有两种具体使用场景：\n\n普通文本字符串（string literal）：不可修改\n作为某个 String 类型的切片字符串：不可修改\n\n可以看到，都是不可修改，所以当我们有要修改字符串的计划，我们就应该使用上面 String 类型，而不修改的话就选择 &amp;str 类型。\n12345678910111213141516171819202122232425262728fn str_and_string() &#123;    // 普通文本字符串 string literals    let normal_str = &quot;hello, &quot;;    // 可操作的、拥有所有权的 String 类型字符串    let mut mutable_string = String::from(normal_str);    // a string slice of String, 没有修改字符串的计划    let hello = &amp;mutable_string[0..5];    println!(&quot;hello = &#123;&#125;&quot;, hello);    // 修改字符串 &amp;mut 才能修改    do_some_mutation(&amp;mut mutable_string);    // 只需要借用字符串的值    only_use_text(&amp;mutable_string);    println!(&quot;mutable_string = &#123;&#125;&quot;, mutable_string);&#125;fn do_some_mutation(input: &amp;mut String) &#123;    input.replace_range(0..1, &quot;H&quot;);    input.push_str(&quot;add this to the end&quot;);&#125;fn only_use_text(input: &amp;String) &#123;    let hello = &amp;input[..=6];    let world = &quot;world&quot;;    println!(&quot;greet = &#123;&#125;&quot;, [hello, world].concat());&#125;\n\n隐式类型转换 String -&gt; &amp;str\n当函数参数定义为 &amp;str 切片类型时，我们在传入的是完整切片时是可以直接传入 String 类型字符串的，相当于 &amp;s[..]，Rust 实现了自动解引用，在必要时会将 &amp;String 自动转换成 &amp;str 。这样使得，如果接受参数是字符串的引用，我们采用 &amp;str 作为入参，但能获得两种类型数据的兼容。\n123let s :String = String::from(&quot;hello, world&quot;);// String 转换成 slicelet slice = s.as_str();\n\n注意：反过来是不行的，因为 String 类型 转 切片类型，没有转换成本，而从 切片类型 转 String 类型还需要为其重新申请内存，对性能是有损耗的，Rust 不会自动做这个行为。\n与其他类型的转换\n元组 The Tuple Type混合类型 —— 多种类型的数值的集合，一旦定义了不能改变长度\n12345678// 声明let tup: (i32, f64, u8) = (500, 6.4, 1);// 取值(1)let (x, y, z) = tup;println!(&quot;The value of y is: &#123;y&#125;&quot;); // ✅ The value of y is: 6.4// 取值(2)println!(&quot;Values in tup: &#123;&#125; &#123;&#125; &#123;&#125;&quot;, tup.0, tup.1, tup.2); // ✅ Values in tup: 500 6.4 1\n\n数组 The Array Type数组的定义其实就是为分配一段连续的相同数据类型的内存块。\n[T; N] 表示 N 个值的数组，每个值的类型为 T。数组长度一经定义不可修改，所以编译时数组占用的内存大小就已是确定的了，不能追加或删除元素，但可以修改元素的值。\n12345678910111213// 先声明类型和长度，后赋值let a: [i32; 5] = [1, 2, 3, 4, 5]; // 定义后无法再修改大小// 同样的值，可以简化创建let a = [3; 5]; // 5 个 3// 取值let first = a[0];let second = a[1];// 转迭代器，得到 (index, value) 枚举对 lista.iter().enumerate()\n\n遍历方式\n1234567891011// 已知长度let arr = [10; 4];for i in 0..4 &#123;  println!(&quot;&#123;&#125;&quot;, arr[i]);&#125;// 未知长度：迭代器for i in arr.iter() &#123; println!(&quot;&#123;&#125;&quot;, i);&#125;\n\n数组的引用都是值的传递，即和原数组没有联系，原数组不受任何影响\n12345678910111213141516171819202122fn test_arr() &#123;    let mut a = [10, 20];    let mut b = a;    a[0] = 0;    println!(&quot;a &#123;:?&#125;&quot;, a); // [0, 20]    println!(&quot;b &#123;:?&#125;&quot;, b); // [10, 20]    let arr = [10, 20, 30];    println!(&quot;1111 &#123;:?&#125;&quot;, arr); // [10, 20, 30]   // 参数传递，是直接复制 arr 的值传入，和 arr 无关    update(arr);    println!(&quot;2222 &#123;:?&#125;&quot;, arr); // [10, 20, 30]    fn update(mut arr: [i32; 3]) &#123;        for i in 0..3 &#123;            arr[i] = 0;        &#125;        println!(&quot;update &#123;:?&#125;&quot;, arr); // [0, 0, 0]    &#125;&#125;\n\n向量 The Vec TypeAn array-like data structure，一种类数组数据结构，和数组的区别是它支持动态大小，即可以增加或删除元素。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465fn main() &#123;    /*      使用Vec和HashMap实现书籍库管理系统      添加书籍，查询库存，更新库存，删除书籍    */      let books = vec![        &quot;The Rust Programming Language&quot;,        &quot;Welcome to Rust&quot;,        &quot;Rust by Example&quot;,    ];    struct BookSystem &#123;        map: HashMap&lt;String, i32&gt;,    &#125;    impl BookSystem &#123;        // 创建        fn new(books: Vec&lt;&amp;str&gt;) -&gt; BookSystem &#123;            let mut map = HashMap::new();            for book in books &#123;                map.insert(book.to_string(), 1);            &#125;            BookSystem &#123; map &#125;        &#125;        // 添加书籍        fn add(&amp;mut self, name: &amp;str) &#123;            self.map.insert(name.to_string(), 1);        &#125;        // 查询库存        fn find(&amp;self, name: &amp;str) -&gt; i32 &#123;            match self.map.get(&amp;name.to_string()) &#123;                Some(num) =&gt; *num,                None =&gt; 0,            &#125;        &#125;        // 更新库存        fn update(&amp;mut self, name: &amp;str, num: i32) &#123;            self.map.insert(name.to_string(), num);        &#125;        // 删除书籍        fn delete(&amp;mut self, name: &amp;str) &#123;            self.map.remove_entry(name);        &#125;        fn log(&amp;self) &#123;            println!(&quot;&gt;&gt;&gt;&gt;&gt;&gt; Current stock &lt;&lt;&lt;&lt;&lt;&lt;&quot;);            for (k, v) in &amp;self.map &#123;                println!(&quot;[&#123;&#125;]: &#123;&#125;&quot;, k, v);            &#125;        &#125;    &#125;    let mut sys = BookSystem::new(books);    sys.log();    let book_name = &quot;Easy Rust&quot;;    sys.add(book_name);    sys.log();    sys.update(book_name, 3);    sys.log();    println!(&quot;The stock of [&#123;&#125;] is &#123;&#125;&quot;, book_name, sys.find(book_name));    sys.delete(book_name);    sys.log();&#125;\n\n切片 The Slice Type表示 String 类型、Array 类型、Vec 类型 的局部数据，&amp;T 只引用值，&amp;mut T 可以修改原数据\n12345678910切片常用函数- len(): 取 slice 元素个数- is_empty(): 判断 slice 是否为空- contains(): 判断是否包含某个元素- repeat(): 重复 slice 指定次数- reverse(): 反转 slice- join(): 将各元素压平（flatten）并通过指定的分隔符连接起来- swap(): 交换两个索引处的元素，如 s.swap(1, 3)- windows(): 以指定大小的窗口进行滚动迭代- start_with(): 判断 slice 是否以某个 slice 开头\n\n自定义类型 Custom TypesRust 自定义数据类型主要通过 struct 和 enum 关键字形成\n\nstruct: 定义一个结构体型数据\nenum: 定义一个枚举型数据\n\n结构体 Structures基础用法，结构体可以定义 n 多个字段\n\n结构体变量和一般变量一样，默认也是不可变的（immutable），let mut T = struct XXX 定义可变的（mutable）结构体变量\n可以没有任何字段名，但不能没有字段类型，这种结构体长的像元组，所以被被称为元祖结构体（tuple struct），例如：struct Point(i32, i32, i32) 表示一个点的坐标 x,y,z\n可以不包含任何字段，即没有类型也没有名称，被称为单元结构体\n\n12345678910111213141516171819202122232425262728293031struct Person &#123;    name: String,    age: u8,&#125;let me = Person &#123; name: &quot;Marnie&quot;.to_string(), age: 10 &#125;;// A unit structstruct Unit;// A tuple structstruct Pair(i32, f32);let a = Pair(8, 0.2);println(&quot;&#123;&#125;&quot;, a.0);// A struct with two fieldsstruct Point &#123;    x: f32,    y: f32,&#125;let p = Point &#123; x: 0.5, y: 1.2 &#125;;// Structs can be reused as fields of another structstruct Rectangle &#123;    // A rectangle can be specified by where the top left and bottom right    // corners are in space.    top_left: Point,    bottom_right: Point,&#125;let point_top_left = Point &#123; x: 0.5, y: 1.2 &#125;;let point_bottom_right = Point &#123; x: 1.8, y: 0.2 &#125;;let rect = Rectangle &#123; top_left: point_top_left, bottom_right: point_bottom_right &#125;;\n\n结构体更新语法：我们可以用 ..structA 给 structB 进行更新，在 structB 中没有显示声明的字段，都会从 structA 中取 。\n但是注意了📢，在 Rust 中严格管控着数据所有权（ownership），所以当针对没有 copy 特性的字段被用来赋值之后，该字段的数据所有权即会发生转移。只要有一个字段发生了所有权变化，那么整个结构体就已经是不完整的了，该结构体本身就不能再被转移，即无法整个结构体直接使用。\n没有 copy 特性（trait）指的就是那些存在 heap 上的数据，在 stack-side 存储的是其内存块的 pointer，赋值操作即原指针失效，内存地址转移到新指针上。\n12345678910let user1 = User &#123;     active: true,     username: String::from(&quot;example1&quot;),     email: String::from(&quot;example1@examples.com&quot;),     sign_in_count: 1, &#125;; let user2 = User &#123;     email: String::from(&quot;example2@examples.com&quot;),     ..user1 &#125;;\n\n结构体可以包含行为，即带有方法（方法和函数是有区别的）的结构体\n枚举型 Enum结构体通常是描述带有不同字段的某个类型，而枚举型指的是某个更上层的类型下会包含多个不同类型，比如动物类型包含猫猫、狗狗、兔子、猪等等\n123456enum Animal &#123;  Dog,  Cat,  Rabbit,  Pig,&#125;\n\n函数 Functions语句 Statements表示一个要执行的操作，没有返回值\n1234567fn foo() &#123;  // ❌ 首先 let y = 1; 是个语句，没有返回值，且（）中加表达式只能在 if、while 条件判断下使用  let x = (let y = 1);    // 等同于 let x = 1; let y = 1;  let x = y = 1;&#125;\n\n流程控制 Control Flow条件控制 ifif 表达式的条件（condition）必须是 bool 类型\n123456let number = 3;// ❌ error[E0308]: mismatched types, expected `bool`, found integer&quot;if number &#123;  println!(&quot;Never print: expected `bool`, found integer&quot;);&#125;\n\nif or else 表达式后紧跟的代码块被称为 arms，和 match 表达式的 arms 一致\nif 表达式的代码块最后一行若是表达式，即为当前块的返回值\n若是多个 if...else if 每个代码块的返回值类型需要一致\n123456789101112131415161718fn if_else_expressions() -&gt; () &#123;    let number = 55;    const NOT_MATCHED_MESSAGE: &amp;str = &quot;Not Matched&quot;;    let message = if number % 4 == 0 &#123;        &quot;Divide by 4&quot;    &#125; else if number % 3 == 0 &#123;        &quot;Divide by 3&quot;    &#125; else if number % 2 == 0 &#123;        &quot;Divide by 2&quot;    &#125; else &#123;        NOT_MATCHED_MESSAGE    &#125;;    if message != NOT_MATCHED_MESSAGE &#123;        println!(&quot;&#123;&#125;&quot;, message);    &#125;&#125;\n\n todo()! 表示延迟实现当前代码块，和占位符概念类似，即可以跳过类型检查\n123fn foo() &#123;  todo()!;&#125;\n\n循环 Looplooploop 加大括号声明循环（代码块可以有返回值），continue 跳出本次循环，break 跳出并终止整个循环，\n12345678910111213fn loop_expressions() -&gt; () &#123;    let mut counter = 0;    let result = loop &#123;        counter += 1;        if counter == 10 &#123;            break counter * 10; // 终止循环，并有返回值        &#125;    &#125;;    println!(&quot;&#123;&#125;&quot;, result);&#125;\n\n嵌套循环，用 单引号 + label 的格式命名，break LOOP_NAME 跳出对应循环\n123456789101112131415161718192021222324fn nested_loops() -&gt; () &#123;    let mut count = 0;    &#x27;counting_up: loop &#123;        println!(&quot;count = &#123;&#125;&quot;, count);        let mut remaining = 10;        loop &#123;            println!(&quot;remaining = &#123;&#125;&quot;, remaining);            if remaining == 9 &#123;                break; // 结束并跳出当前循环            &#125;            if count == 2 &#123;                break &#x27;counting_up; // 结束并跳出 &#x27;counting_up 循环            &#125;            remaining -= 1;        &#125;        count += 1;    &#125;&#125;\n\nwhile如果需要判断某些条件的循环，可以使用 while 更方便\n123456789fn while_case() -&gt; () &#123;    let mut count = 1;    while count &lt; 12 &#123;        count += 1;    &#125;    println!(&quot;count = &#123;&#125;&quot;, count);&#125;\n\nforfor loop 遍历数组\n123456789101112131415161718192021222324252627282930313233343536// loop in arrayfn for_loop() -&gt; () &#123;    let a = [10, 20, 30, 40, 50];    for e in a &#123;        println!(&quot;i=&#123;&#125;&quot;, e);    &#125;   // 1..=5 快速创建一个1-5的    for n in 1..=5 &#123;        println!(&quot;n=&#123;&#125;&quot;, n);    &#125;     // (1..=5).rev() 快速创建一个5-1倒序的数组    for n in (1..=5).rev() &#123;        println!(&quot;n=&#123;&#125;&quot;, n);    &#125;&#125;// loop in vectorfn vector_case() -&gt; () &#123;    let mut v = vec![1, 2, 3];    // 表示并非所有权转移，&amp; 表示借用，借用是只读    for vv in &amp;mut v &#123;        // vv 是对 v 中的某个 vector 的引用，        // 引用的本质是一个指针，指针不能直接和值进行比较，        // 需要加 *号 解引用，解引用就表示该引用变量的值        if *vv == 1 &#123;            *vv = 5;        &#125;        println!(&quot;v=&#123;&#125;&quot;, vv);    &#125;    println!(&quot;&#123;&#125;&quot;, v[0]);&#125;\n\n所有权 Ownership所有权是控制一个 Rust 程序如何管理内存的一套规则。所有程序都要有管理它们在运行时使用计算机内存的方式。\n内存管理方式 Memory Management常见的内存管理方式：\n\n垃圾回收（Garbage Collection）：如 JavaScript、Java 这种动态语言，语言层面设计了一套内存回收机制，垃圾回收器会持续追踪内存的分配并定期找到不再被使用的内存进行释放回收，让开发者无需去关心内存的分配和回收\n手动管理（Manual Management）：如 C、C++ 这种静态语言，需要手动调用分配和释放内存的方法进行操作，这让开发者需要对内存的分配及释放负责，忘记释放会导致内存浪费，太早释放又会导致获得无效的变量\n\n第三种 —— Rust 使用的内存管理方式：所有权系统（Ownership System）\n\n所有者（ower）指的是这块内存（memory）是属于谁的，包括访问和修改的能力\n每个值都有一个所有者，任何时候都只能有一个有效所有者\n当所有者离开作用域（scope），值会被丢弃（drop）\n遵循所有权系统规则，编译器在编译时通过静态分析管理内存安全，违背规则的程序不会通过编译\n通过借用（borrowing，即引用）机制来共享数据\n\n🎯 TODO：内存分配方式 Memory Allocation\n栈（Stack）：连续的内存空间，从低地址到高地址逐步分配，简单数据类型会被直接存储在栈上，便于操作\n堆（Heap）：非连续内存空间，申请多少大小空间就一次性分配多少，会通过一个指针指向这一块内存空间，复杂数据类型的值会在堆上开辟对应的空间存放，而栈上对应的这个变量存的是与这块内存相关的指针信息，即内存地址（adress）、大小（Capacity）、长度（Length）\nStatic：blahblahblah…\n\n转移 或 复制 Move or Copy基于不同的内存分配方式，针对数据和变量之间的赋值操作，在 Rust 中也会有两种表现情况：\n\n简单数据类型：一般是固定大小的数据，值存放在栈上，赋值是对值的拷贝（copy）\n复杂数据类型：一般为非固定大小数据，值被存放在堆上，该内存一旦分配，赋值的操作默认被看做为转移（move），即将该内存的所有权转移给某个变量\n\n12345678// copylet a: i32 = 1;let b = a; // directly copy 1// movelet a: String = String::from(&quot;Hello&quot;);let b = a; // move the ownership of &quot;Hello&quot; from a to b// current, a is considered as transferred, which means it&#x27;s no longer needed\n\n其实可以简单理解，转移（move）是所有权（ownership）系统实现 “内存所有者只能有一个” 的一种规则机制，这个机制防止出现数据竞争的可能 —— 多个线程对统一资源进行访问和修改，从而导致程序结果与期望不符。本身具有所有权的变量本质是存在栈上的某个指针类型变量，它的作用是为了指向堆中的某块内存，所以一经转移，相当于指针不再指向这块内存，这个变量就不再有效了，即不可以再被访问。\n所有权和生命周期（Lifetimes）所有权是指某块内存的所有者，所有者是某个变量，而变量的生命周期和所在作用域相关，在某个作用域下定义的变量只能在该作用域下使用。所有权也有着相应的限制，变量在某个作用域（scope）内被分配到对应数据的内存，在离开作用域后，变量会变得无效，它会交还对某个数据内存的所有权，则该“无主”的数据内存会被视为不再需要的，会触发自动释放内存的机制，也就是回收内存。\n12345fn foo() &#123;  let s = String::from(&quot;Hello&quot;); // s is valid from this point  // s is the owner of the string &quot;Hello&quot;&#125; // this scope is over now, s and string &quot;Hello&quot; are not valid// the data is not valid means it is no longer needed, which will trigger the step of freeing memory\n\n当变量被传入某个函数，也是发生了转移操作，意味着数据的所有权被传递给了函数，函数外已经没有权利访问和修改该变量所指的数据。如下例子：\n\n第一步，s 拥有了 string &quot;Hello&quot; 的所有权\n第二步，将 string &quot;Hello&quot; 的所有权转移给了 carry_params 函数\n而 carry_params 没有对参数 s 做任何处理，那么在函数执行完毕后，离开作用域，入参 s 对应也不再有效，对应占用的数据内存会被释放\n第三步，我们再打印 s 就会得到值已被转移了，即无权访问的编译错误提示\n拥有所有权的作用所有权是指对某块内存的所有，即拥有读写这块内存的权力，当我们需要修改某个数据时，我们就需要拥有其所有权，才能有修改的能力。而当我们只需要读，而不需要写，那就不必拥有或者转移其所有权。可以看到，有了所有权规则的加持，代码变得更加安全但也因此增加了书写代码的难度。\n上面提到如果我们不需要获得某个数据的所有权，只是想要访问值，可以用另一个概念 —— 借用（borrow）。\n借用 Borrow当我们不需要数据的所有权时，我们使用借用来访问数据的值，借用分为两种：\n\nborrow：不可变的借用，我只是把数据借给你用 &amp;T\nborrow mutably：可变的借用，我不仅把数据借给你用，且给你修改它的权限 &amp;mut T，这种借用也可以被叫做引用（reference）\n\n其实可以理解为，&amp; 给了读数据的权力，&amp;mut  在读的基础上给了写的权力，但数据（也就是这块内存）的拥有者并没有变。\n123456789101112131415161718192021222324252627282930313233fn str_and_string() &#123;    // 普通文本字符串 string literals    let normal_str = &quot;hello, &quot;;    // 可操作的、拥有所有权的 String 类型字符串    let mut mutable_string = String::from(normal_str);   // a string slice of String,    // 借用（引用） &quot;hello, &quot;，没有修改字符串的需求    let slice = &amp;mutable_string[..];    println!(&quot;slice = &#123;&#125;&quot;, slice);    // 借用对象 和 被借用对象 都是指向同一块内存，所以相等    assert_eq!(slice, mutable_string);    // 1️⃣ 默认借用，只需要借用字符串的值，不涉及所有权    only_use_text(&amp;mutable_string);   // 2️⃣ 可变的借用，不仅可以访问值，还给了修改值的权力   // 需要声明 &amp;mut 才能修改字符串    do_some_mutation(&amp;mut mutable_string);    println!(&quot;mutable_string = &#123;&#125;&quot;, mutable_string);&#125;fn do_some_mutation(input: &amp;mut String) &#123;    input.replace_range(0..1, &quot;H&quot;);    input.push_str(&quot;add this to the end&quot;);&#125;fn only_use_text(input: &amp;String) &#123;    let hello = &amp;input[..=6];    let world = &quot;world&quot;;    println!(&quot;greet = &#123;&#125;&quot;, [hello, world].concat());&#125;\n\n🎯 TODO：生命周期 LifetimesNLL —— Non-Lexical LifetimesDangling Referencing 悬垂引用指的是一个变量是有效状态的时间，即可以被使用的时长，通常也被叫做存活（live）时间。\n生命周期是 Rust 用来保证引用有效性的机制。生命周期注解允许编译器推断引用的有效范围，确保在引用仍然有效的时候使用它们。\n在 Rust 中，一个变量的存活时间与其作用域（scope）和是否还存在被使用（引用 references）有关。\n\n作用域规则决定了一个变量能否被访问，在某个作用域下定义的变量也只在这个作用域内有效，即离开作用域后无法被访问，会自动被销毁。\n\n当编译器检查到一个变量不再存在任何被引用被借用关系后，该变量也会被自动销毁。\n\n\n12345let x :i32 = 5;// 存在被使用println!(&quot;x = &#123;&#125;&quot;, x); // after this line, x has no more references, will be automatically destroyedlet y :i32 = 6;\n\n借用规则 Borrow Rules\n一个变量只能存在一个可变引用或者多个不可变引用，不能同时存在可变和不可变引用\n\n借用检查器 Borrow Checker前面说了，借用是用于不关心所有权的场景下的，那没有所有权就意味着我需要依赖被我借用的那个变量，当它不合法时、无效时，那我的借用行为也是不可能通过的。Borrow Checker 便是在编译时，检查借用是否合法，即被借用的变量是否还在有效的生命周期内。结合前面提到的所有权的生命周期，来看下截图上的例子：\n\n可以看到报错部分说的是被借用值 x 存活的不够长，重点看下黄色框内，模拟画的作用域结构图。\n\nr 在 a 作用域中创建，即它存活在作用域 a 存活的期间，即 foo 函数执行期间\nx 在 b 作用域中创建，即它存活在作用域 b 存活的期间，作用域 b 是个 block 作用域，在它执行完成后内部变量都会自动释放，即 x 在作用域 b 外无效\n\n因为 r 是个借用类型，Borrow Checker 会检查被借用变量是否是有效的，当发现被借用变量的生命周期小于借用变量的生命周期，即 x 的生命周期小于 r 的生命周期，这是不合法的 —— 报错。所以如果是存在借用关系的两个变量，那么被借用变量的存活时间一定要比借用变量存活的时间更长，存活时间更长可以归纳为两种情况：\n\n相同作用域范围下，被借用变量定义早于借用变量\n借用变量的作用域层级深于被借用变量（越深销毁越早）\n\n📸 TODO 手动管理可能会遇到的问题内存泄露\n悬空指针\n缓冲区溢出\n泛型（Generics）和特质（Traits）MatchOption1234// `unwrap()`: 有值的时候会取值，没值的时候会 `panic`let mut s = String::from(&quot;hello&quot;);let p1 = s.pop().unwrap();println!(&quot;&#123;&#125;&quot;, p1);\n\n返回值与错误处理可恢复的错误 Result&lt;T, E&gt;从系统全局角度来看是可以接受的错误，这些错误只会影响某个用户自身的操作进程，一般是逻辑层面上的错误（业务逻辑、操作逻辑），不会对系统的全局稳定性产生影响。\n使用 Result 返回值不可恢复的错误 panic!全局性或者系统性的错误，列入数组越界访问、影响启动流程的错误等等，这些错误是影响系统流程的。\n主动触发 panicRust 提供了 panic! 宏，当调用执行该宏时，程序会打印出一个错误信息，展开报错点前面的函数调用堆栈，最后退出程序。\n123fn main() &#123;  panic!(&quot;crash and burn&quot;);&#125;\n\nbacktrace 栈展开默认程序执行调用栈输出是开启 --debug 的时候才会展示，可以通过 RUST_BACKTRACE=1 cargo run 来手动开启调用栈回溯。\n栈展开也称栈回溯，包含了函数调用的顺序，按照逆序排列：最近调用的函数在列表最上方。\nunwrap 方法\nOption : 有值的时候会取值，没值的时候会调用 panic!\nResult : Ok 会返回 Ok 中的值，Err 会为我们调用 panic!\n\n123let arr = [1, 2, 3, 4];let a = first(&amp;arr).unwrap();println!(&quot;The first element is &#123;&#125;&quot;, a);\n\nexpect 方法用于设置预期的 panic 错误文案\n12let file = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);println!(&quot;&#123;:?&#125;&quot;, file);\n\n传播错误unwrap 方法在遇到错误情况下都会直接调用 panic! 从而会直接终止程序的进行，但很多情况下我们遇到的都是预期内的错误情况，并不需要终止，只需要将错误向上传播，这时我们就不用使用 unwrap 方法。取而代之，通常使用 ? 链式调用传播错误，它的功能是问号前的表达式执行结果成功则继续向后执行，若结果失败或者说错误，则截停执行逻辑到当前表达式为止并将错误返回，此时如果前一个表达式设置了错误 callback 等类似的处理，就能触发相应的逻辑。\nOption 和 Result 的互转Result 有两个结果 Ok 和 Err，Option 包含 Some 和 None\n\nResult 转 Option，转换即将 ok 和 err 都转为 Some\n\nerr(): Err -&gt; Some\n\nok(): Ok -&gt; Some\n\n\n\n\n123456789let f = File::open(&quot;hello.txt&quot;).err();if f.is_some() &#123;    println!(&quot;no file&quot;);&#125; let f = File::open(&quot;hello.txt&quot;).ok();if f.is_none() &#123;    println!(&quot;no file&quot;);&#125;\n\n\nOption 转 Result\n\nok_or()\n\n\n\n","slug":"rust-basic","date":"2024-10-22T16:00:00.000Z","categories_index":"","tags_index":"basic","author_index":"Marnie"}]