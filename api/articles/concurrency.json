{"title":"并发 Concurrency","uid":"d644caf05d644047d4c92cde0f070d6e","slug":"concurrency","date":"2025-01-28T13:38:22.000Z","updated":"2025-02-13T09:35:58.057Z","comments":true,"path":"api/articles/concurrency.json","keywords":"","cover":[],"content":"<h2 id=\"Concurrency-in-Rust\"><a href=\"#Concurrency-in-Rust\" class=\"headerlink\" title=\"Concurrency in Rust\"></a>Concurrency in Rust</h2><p>在 Rust 中，并发（Concurrency）是一项核心功能，旨在安全高效的同时执行多个任务。</p>\n<h2 id=\"Spawning-Thread\"><a href=\"#Spawning-Thread\" class=\"headerlink\" title=\"Spawning Thread\"></a>Spawning Thread</h2><p>默认代码中的任务都是在主线程中执行的，Rust 在标准库中提供了 thread 模块，提供了操作线程的能力。</p>\n<h3 id=\"Creating-new-thread\"><a href=\"#Creating-new-thread\" class=\"headerlink\" title=\"Creating new thread\"></a>Creating new thread</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::thread::spawn;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">  <span class=\"title function_ invoke__\">spawn_thread</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">spawn_thread</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">thread_fn</span> = || &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">x</span> = <span class=\"number\">0u128</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">50_000_000</span> &#123;</span><br><span class=\"line\">            x += i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;worker get x = &#123;&#125;&quot;</span>, x);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Starting new worker thread...&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">handle</span> = <span class=\"title function_ invoke__\">spawn</span>(thread_fn);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">handle2</span> = <span class=\"title function_ invoke__\">spawn</span>(thread_fn);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">loop</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> handle.<span class=\"title function_ invoke__\">is_finished</span>() &amp;&amp; handle2.<span class=\"title function_ invoke__\">is_finished</span>() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Worker 1,2 are completed...&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Worker threads are all finished...&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Main thread has finished...&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"std-thread-spawn-closure\"><a href=\"#std-thread-spawn-closure\" class=\"headerlink\" title=\"std::thread::spawn(closure)\"></a><code>std::thread::spawn(closure)</code></h4><p><code>std::thread::spawn</code> 方法用于创建工作线程，接受一个闭包，闭包内写需要在该线程内执行的任务，该方法返回一个 <code>JoinHandle</code> 结构体。默认主线程上的任务和工作线程是随机执行的，无法固定执行顺序，工作线程依赖于主线程创建，主线程一旦退出后，即使有未执行完的工作线程上的任务，也会直接结束。</p>\n<p><code>JoinHandle</code> 结构体提供了一些方法，其中就有阻止主线程终结的 <code>join</code> 方法，调用该方法可以阻止主线程的结束，它会等到该工作线程所有任务完成后再退出。</p>\n<h4 id=\"join-方法\"><a href=\"#join-方法\" class=\"headerlink\" title=\"join 方法\"></a><code>join</code> 方法</h4><p>上面的例子我们在主线程写了一个 <code>loop</code> 函数来一直执行，直到 worker thread（handle+handle2） 执行完毕。<code>is_finished()</code> 方法是 <code>JoinHandle</code> 提供的用于查询工作线程是否结束的方法。除此之外用 <code>join</code> 能让主线程等待工作线程的执行。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">handle</span> = <span class=\"title function_ invoke__\">spawn</span>(thread_fn);</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">handle2</span> = <span class=\"title function_ invoke__\">spawn</span>(thread_fn);</span><br><span class=\"line\"></span><br><span class=\"line\">handle.<span class=\"title function_ invoke__\">join</span>();</span><br><span class=\"line\">handle2.<span class=\"title function_ invoke__\">join</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"Thread-variables-线程变量\"><a href=\"#Thread-variables-线程变量\" class=\"headerlink\" title=\"Thread variables 线程变量\"></a>Thread variables 线程变量</h4><p><code>spawn</code> 方法接收一个闭包，我们在学闭包部分的时候有提过，闭包的特性就是可以访问父级作用域内定义的变量，被称为 capturing variables，所以我们在新线程闭包函数内是可以访问父级作用域的变量的。比如下图例子：</p>\n<p><img src=\"/../images/concurrency/image-20250207203619887.png\" alt=\"image-20250207203619887\"></p>\n<p><code>print_age</code> 闭包内使用了父级作用域的 <code>user</code> 变量，这时 Rust 会尝试像父级作用域借用 <code>user</code>，然而就会出现报错上的这个问题：Rust 并不知道这个闭包会存活多久或者更进一步，因为这个闭包是传入 <code>spawn</code> 方法创建新线程时用的，Rust 并不知道这个新线程会存活多久，所以它无法确认被借用的 <code>user</code> 一定是存在的（比如子线程借用变量，主线程销毁了变量），便得到了上面的报错。</p>\n<p>所以关于线程中使用外部变量有两种解决方案：</p>\n<h5 id=\"move-closure-使用-move-关键字将变量的数据所有权转移到闭包内\"><a href=\"#move-closure-使用-move-关键字将变量的数据所有权转移到闭包内\" class=\"headerlink\" title=\"move closure 使用 move 关键字将变量的数据所有权转移到闭包内\"></a><code>move closure</code> 使用 move 关键字将变量的数据所有权转移到闭包内</h5><p>这相当于告诉编译器将变量转移到线程内作用域，线程结束后会自动 <code>drop</code> 变量。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::thread::spawn;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">m</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">thread_fn</span> = <span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">  m += <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;m = &#123;&#125;&quot;</span>, m);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_ invoke__\">spawn</span>(thread_fn);</span><br></pre></td></tr></table></figure>\n\n<p>上面的 <code>move closure</code> 只适用于只需要在子线程内使用的变量，若在子线程结束后还需要使用的变量我们就需要改用 <code>thread::scope</code> 方法。</p>\n<h5 id=\"std-thread-scope\"><a href=\"#std-thread-scope\" class=\"headerlink\" title=\"std::thread::scope\"></a><strong><code>std::thread::scope</code></strong></h5><p>普通的 threads 是 non-scoped threads，使用 <code>thread::scope</code> 提供一个 <code>Scope</code> 对象，用该对象提供的 <code>spawn</code> 方法支持创建带作用域的线程，它会确保等待这个 scope 内创建的所有线程的任务都执行完毕后才会离开当前作用域，这种自动等待的机制便让编译器可以<strong>推断</strong>变量借用的生命周期，不需要再手动转移变量所有权。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::thread::scope;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">user</span> = Person &#123;</span><br><span class=\"line\">  name: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Mark&quot;</span>),</span><br><span class=\"line\">  age: <span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">print_name</span> = || &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;My name is &#123;&#125;.&quot;</span>, user.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_ invoke__\">scope</span>(|s| &#123;</span><br><span class=\"line\">  s.<span class=\"title function_ invoke__\">spawn</span>(print_name);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"Message-Passing-with-MPSC-channels\"><a href=\"#Message-Passing-with-MPSC-channels\" class=\"headerlink\" title=\"Message Passing with MPSC channels\"></a>Message Passing with MPSC channels</h2><p>线程间的通信方式为：Message Passing 消息传递。消息传递的载体是 <code>channel</code> ，<code>channel</code> 分为一个发送方（transmitter）一个接收方（receiver）。</p>\n<p>使用 <code>mpsc::channel</code> 函数创建 <code>channel</code>，<strong>mpsc meanings multiple producer single consumer（多生产者单消费者）</strong>。</p>\n<h3 id=\"通信原则\"><a href=\"#通信原则\" class=\"headerlink\" title=\"通信原则\"></a>通信原则</h3><p>默认情况，<code>channel</code> 间消息通信都需要遵守多生产者单消费者的原则，这是为了防止数据竞争（data racing），可以有多个线程进行生产消息，但是消费或者说接收、处理消息的线程只能有一个。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::sync::mpsc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个 channel</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> (tx, rx) = mpsc::<span class=\"title function_ invoke__\">channel</span>();</span><br><span class=\"line\"><span class=\"comment\">// tx：发送方，rx：接收方</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"多个生产者-multiple-producers\"><a href=\"#多个生产者-multiple-producers\" class=\"headerlink\" title=\"多个生产者 multiple producers\"></a>多个生产者 multiple producers</h3><p>创建 <code>channel</code> 后，默认得到一个生产者一个消费者，如果需要使用多个线程进行消息生产的场景，我们可以使用 <code>clone()</code> 方法克隆原生产者，来创建该 <code>channel</code> 多个生产者。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::sync::mpsc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个 channel</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> (tx, rx) = mpsc::<span class=\"title function_ invoke__\">channel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 Sender::clone 方法，clone一个生产者（符合channel多个生产者的主旨）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">tx2</span> = mpsc::Sender::<span class=\"title function_ invoke__\">clone</span>(&amp;tx);</span><br><span class=\"line\"><span class=\"comment\">// 或者 clone trait 方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">tx3</span> = tx.<span class=\"title function_ invoke__\">clone</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Sharing-data-within-multiple-threads\"><a href=\"#Sharing-data-within-multiple-threads\" class=\"headerlink\" title=\"Sharing data within multiple threads\"></a>Sharing data within multiple threads</h3><p>上面说到，为了数据安全性的考虑，我们需要遵守只能存在一个线程消费（读取）消息的原则。但如果就是遇到了需要<strong>多个线程里都可能使用一个消息</strong>的场景，即<strong>多生产者多消费者</strong>，我们也是可以支持的，但<strong>始终遵守同一时间只能存在一个真实消费消息的线程</strong>。需要使用 <strong><code>Mutex</code> 互斥锁 + <code>Arc</code> 智能指针</strong>  ：</p>\n<p><code>Mutex</code> 用来防止多线程下的数据竞争，<code>Arc</code> 智能指针用来实现数据共享及多线程下需要共享的数据的安全性。</p>\n<h4 id=\"Mutex-互斥锁-是什么\"><a href=\"#Mutex-互斥锁-是什么\" class=\"headerlink\" title=\"Mutex 互斥锁 是什么\"></a>Mutex 互斥锁 是什么</h4><p><code>Mutex</code> 让多个线程并发的访问同一个值变成了排队访问：<strong>同一时间，只允许一个线程<code>A</code>访问该值，其它线程需要等待<code>A</code>访问完成后才能继续</strong>。</p>\n<p>这就很符合我们 <strong>mpsc</strong> 的原则，一般单线程中我们并不需要使用互斥锁，单线程中本来就需要遵守所有权的限制，很大程度的避免了同时读写的场景。所以互斥锁的场景一般都是用于多线程访问同一个值。</p>\n<h4 id=\"Mutex-怎么使用\"><a href=\"#Mutex-怎么使用\" class=\"headerlink\" title=\"Mutex 怎么使用\"></a>Mutex 怎么使用</h4><h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个 Mutex 结构体变量</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">m</span> = Mutex::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>Mutex</code> 是一个数据结构，它会类似 <code>Box</code> 智能指针一样持有数据。</p>\n<h5 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h5><p>访问内部的数据需要使用 <code>lock()</code> 方法向 <code>Mutex</code> 变量申请一个<strong>锁</strong>，该方法会挂起当前线程，直到获取到锁，一旦有某一条线程获取到了锁，其他线程获取锁便会被阻塞，直到已经获取锁的线程将锁释放，这样便可以保证，同时只会有一条线程在操作数据。</p>\n<p><code>lock()</code> 方法返回类型为 <code>LockResult&lt;MutexGuard&gt;</code>，一个用 <code>Result</code> 包裹的 <code>MutexGuard</code> 智能指针，所以要访问内部数据需要先使用 <code>unwarp()</code> 得到智能指针，再按照具体类型操作内部数据。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建了一个Mutex</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">score</span> = Mutex::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lock()得到Result</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">unlocked_data</span> = score.<span class=\"title function_ invoke__\">lock</span>();</span><br><span class=\"line\"><span class=\"comment\">// unwrap()得到MutexGuard</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">data</span> = unlocked_data.<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\"><span class=\"comment\">// 操作data</span></span><br><span class=\"line\">data.<span class=\"title function_ invoke__\">add_assign</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">&quot;My score is &#123;&#125;.&quot;</span>, data);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>那么，如果同时有两个线程都在申请锁，哪个线程会成功呢？</strong>我们尝试用代码还原一下场景：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;ops::AddAssign, sync::Mutex, thread::scope&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">test_mutex</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建了一个 Mutex</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">score</span> = Mutex::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里申请了锁</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">unlocked_data</span> = score.<span class=\"title function_ invoke__\">lock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">data</span> = unlocked_data.<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">    data.<span class=\"title function_ invoke__\">add_assign</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;My score is &#123;&#125;.&quot;</span>, data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放上一个锁，✨ 这里如果不释放那么下面的线程里是无法申请到锁的</span></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">drop</span>(data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">my_func</span> = || &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Thread 1 is waiting for mutex lock.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">data</span> = score.<span class=\"title function_ invoke__\">lock</span>().<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>..=<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            data.<span class=\"title function_ invoke__\">add_assign</span>(i);</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Thread 1 is adding &#123;&#125; and score is &#123;&#125;&quot;</span>, i, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">my_func2</span> = || &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Thread 2 is waiting for mutex lock.&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">data</span> = score.<span class=\"title function_ invoke__\">lock</span>().<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>..=<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            data.<span class=\"title function_ invoke__\">add_assign</span>(i);</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Thread 2 is adding &#123;&#125; and score is &#123;&#125;&quot;</span>, i, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">scope</span>(|s| &#123;</span><br><span class=\"line\">        s.<span class=\"title function_ invoke__\">spawn</span>(my_func);</span><br><span class=\"line\">        s.<span class=\"title function_ invoke__\">spawn</span>(my_func2);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The score is &#123;&#125;.&quot;</span>, score.<span class=\"title function_ invoke__\">lock</span>().<span class=\"title function_ invoke__\">unwrap</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<p><img src=\"/../images/concurrency/image-20250209020229062.png\" alt=\"image-20250209020229062\"></p>\n<p>可以看到，两个线程都在申请锁，但执行顺序一定是一个锁用完了释放了之后下一个锁才会继续。</p>\n<p>我们的目标是在多线程下实现共享一个消费者数据，除了使用 <code>Mutex</code> 互斥锁保证多线程下数据的<strong>同步访问</strong>，防止<strong>数据竞争（data racing）</strong>外，还需要使用智能指针实现数据共享，前面学习过在一条线程里我们使用 <code>Rc</code> 智能指针来实现一个资源拥有多个所有者，在多线程下是使用 <code>Arc</code> 智能指针，具体用法我们在练习部分再进行应用。</p>\n<h2 id=\"练习1\"><a href=\"#练习1\" class=\"headerlink\" title=\"练习1\"></a>练习1</h2><p><img src=\"/../images/concurrency/image-20250131212004428.png\" alt=\"image-20250131212004428\"></p>\n<ul>\n<li><p>process_file 函数：接收 file_path，打印 file_content</p>\n</li>\n<li><p>主线程：tx（发送方），假设有 10 个 file_path 要处理，遍历它们调用 clone 来创建多个生产者，模拟并发性的发送 file_path</p>\n</li>\n<li><p>子线程（工作线程）：rx（接收方&#x2F;消费者），调用 process_file 函数，按照题意需要创建多个工作线程去接受消息，即会有多个线程需要借用消费者。在工作线程内 loop 访问接收方，根据接收方结果处理消息，直到没有可获取的消息为止</p>\n</li>\n<li><p>最多同时处理 4 个文件：主线程中同时创建4个工作线程，每个工作线程都去访问消费者，处理消费者接收到的消息</p>\n</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">process_file</span>(path: &amp;<span class=\"type\">str</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">file_name</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(path);</span><br><span class=\"line\">    file_name.<span class=\"title function_ invoke__\">push_str</span>(<span class=\"string\">&quot;.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;📔 Processing file: &#123;&#125;&quot;</span>, file_name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">practice</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (tx, rx) = mpsc::<span class=\"title function_ invoke__\">channel</span>();</span><br><span class=\"line\">    <span class=\"comment\">// ✨创建多线程下共享的rx</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">rx</span> = Arc::<span class=\"title function_ invoke__\">new</span>(Mutex::<span class=\"title function_ invoke__\">new</span>(rx));</span><br><span class=\"line\">    <span class=\"comment\">// 创建10个file_path</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">file_paths</span> = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>..=<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">        file_paths.<span class=\"title function_ invoke__\">push</span>(<span class=\"built_in\">format!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// main thread 中 clone 多个 transmitter（sender）</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">path</span> <span class=\"keyword\">in</span> file_paths &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ✨按照题意：使用多线程实现文件处理的并发性，主线程作为生产者向通道发送文件路径</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">cloned_tx</span> = tx.<span class=\"title function_ invoke__\">clone</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 多生产者 multiple transmitter</span></span><br><span class=\"line\">        cloned_tx.<span class=\"title function_ invoke__\">send</span>(path.<span class=\"title function_ invoke__\">clone</span>()).<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 加点延时，看起来有效果的样子</span></span><br><span class=\"line\">        thread::<span class=\"title function_ invoke__\">sleep</span>(Duration::<span class=\"title function_ invoke__\">from_millis</span>(<span class=\"number\">100</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建多个子线程（工作线程）来处理消息</span></span><br><span class=\"line\">    <span class=\"comment\">// 处理消息：调用 process_file 函数</span></span><br><span class=\"line\">    <span class=\"comment\">// rx是接收方，是Arc智能指针包裹的Mutex互斥锁</span></span><br><span class=\"line\">    <span class=\"comment\">// 共享rx：Arc::clone(&amp;rx)</span></span><br><span class=\"line\">    <span class=\"comment\">// ✨按照题意我们需要创建多个线程去使用rx</span></span><br><span class=\"line\">    <span class=\"comment\">// 最多同时处理4个文件</span></span><br><span class=\"line\">    <span class=\"comment\">// handles用来存储创建后的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">handles</span> = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 同时创建4个线程</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">4</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;🔋 Worker thread &#123;&#125; get starting ...&quot;</span>, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建共享的接收方，Reference count +1</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">shared_receiver</span> = Arc::<span class=\"title function_ invoke__\">clone</span>(&amp;rx);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">consumer</span> = <span class=\"keyword\">move</span> || &#123;</span><br><span class=\"line\">            <span class=\"keyword\">loop</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 申请锁-&gt;访问receiver</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"variable\">unlocked_receiver</span> = shared_receiver.<span class=\"title function_ invoke__\">lock</span>();</span><br><span class=\"line\">                <span class=\"comment\">// 拿到用Mutex存储的receiver</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"variable\">receiver</span> = unlocked_receiver.<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;🔄 Attempting to receive message from channel ...&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 拿到receiver的结果</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> <span class=\"variable\">receive_result</span> = receiver.<span class=\"title function_ invoke__\">try_recv</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">match</span> receive_result &#123;</span><br><span class=\"line\">                    <span class=\"title function_ invoke__\">Ok</span>(msg) =&gt; &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 拿消息对象中的内部数据</span></span><br><span class=\"line\">                        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;✅ Consumer received: &#123;&#125;&quot;</span>, msg);</span><br><span class=\"line\">                        <span class=\"title function_ invoke__\">process_file</span>(&amp;msg);</span><br><span class=\"line\">                        <span class=\"comment\">// 加点延时，看起来有效果的样子</span></span><br><span class=\"line\">                        thread::<span class=\"title function_ invoke__\">sleep</span>(Duration::<span class=\"title function_ invoke__\">from_millis</span>(<span class=\"number\">300</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"title function_ invoke__\">Err</span>(mpsc::TryRecvError::Empty) =&gt; &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// No message received within the timeout</span></span><br><span class=\"line\">                        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;❓ Consumer: No message available immediately.&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"title function_ invoke__\">Err</span>(mpsc::TryRecvError::Disconnected) =&gt; &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Channel is disconnected, meaning all senders are dropped</span></span><br><span class=\"line\">                        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;❎ Consumer: Channel disconnected, exiting.&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 因为我们需要借用variables，我们使用scope方法处理生命周期的问题</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">handle</span> = <span class=\"title function_ invoke__\">spawn</span>(consumer);</span><br><span class=\"line\">        handles.<span class=\"title function_ invoke__\">push</span>(handle);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// blocking main thread to wait for worker thread</span></span><br><span class=\"line\">    <span class=\"comment\">// 遍历handles，手动调用join()来阻塞主线程的终结等待工作线程任务完成</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">handle</span> <span class=\"keyword\">in</span> handles &#123;</span><br><span class=\"line\">        handle.<span class=\"title function_ invoke__\">join</span>().<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;🪫 Worker thread is finished.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;✅ All files have processed.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"练习2\"><a href=\"#练习2\" class=\"headerlink\" title=\"练习2\"></a>练习2</h2><p><img src=\"/../images/concurrency/image-20250131213751832.png\" alt=\"image-20250131213751832\"></p>\n<p><img src=\"/../images/concurrency/image-20250212220857490.png\" alt=\"image-20250212220857490\"></p>\n<p>错误提示 —— 当前类型（ <code>TaskSign</code> ）需要是实现了 <code>Send</code> trait 的类型。<code>Send</code> trait 是一种标记（marker）特征，实现了该特征的类型会被编译器识别为 <strong>“线程安全的”</strong>（thread-safe），这是因为我们将标准的 <strong>“一个 receiver”</strong> 共享在多个线程之间，这个行为会被认为是不安全的（unsafe）。据查询，大部分内置类型都自动实现了 <code>Send</code> 特征，部分类型或者自定义类型需要手动加上 <code>Send</code> 特征。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;</span><br><span class=\"line\">    sync::&#123;</span><br><span class=\"line\">        mpsc::&#123;<span class=\"keyword\">self</span>, Receiver, Sender&#125;,</span><br><span class=\"line\">        Arc, Mutex,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    thread::&#123;sleep, spawn, JoinHandle&#125;,</span><br><span class=\"line\">    time::Duration,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Task</span> &#123;</span><br><span class=\"line\">    id: <span class=\"type\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Task</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(id: <span class=\"type\">usize</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        Task &#123; id &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">run</span>(&amp;<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;✅ Executing task &#123;&#125;&quot;</span>, <span class=\"keyword\">self</span>.id);</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">sleep</span>(Duration::<span class=\"title function_ invoke__\">from_secs</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Worker</span> &#123;</span><br><span class=\"line\">    id: <span class=\"type\">usize</span>,</span><br><span class=\"line\">    <span class=\"comment\">// JoinHandle&lt;T&gt;, T refers to return value type of spawn()</span></span><br><span class=\"line\">    handle: JoinHandle&lt;()&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">TaskSign</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Task</span>(Task),</span><br><span class=\"line\">    End,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">SharedReceiver</span> = Arc&lt;Mutex&lt;Receiver&lt;TaskSign&gt;&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工作线程池</span></span><br><span class=\"line\"><span class=\"comment\">// 控制内部工作线程的工作和停止</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">WorkerThreads</span> &#123;</span><br><span class=\"line\">    threads: <span class=\"type\">Vec</span>&lt;Worker&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Worker</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(id: <span class=\"type\">usize</span>, handle: JoinHandle&lt;()&gt;) <span class=\"punctuation\">-&gt;</span> <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        Worker &#123; id, handle &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">WorkerThreads</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>() <span class=\"punctuation\">-&gt;</span> <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        WorkerThreads &#123; threads: <span class=\"built_in\">vec!</span>[] &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新增一个工作线程，每个工作线程的任务是持续查询 receiver</span></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">add_worker</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, receiver: SharedReceiver) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">usize</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">index</span> = <span class=\"keyword\">self</span>.threads.<span class=\"title function_ invoke__\">len</span>();</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;🔑 New worker thread &#123;&#125;&quot;</span>, index + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">handle</span> = <span class=\"title function_ invoke__\">spawn</span>(<span class=\"keyword\">move</span> || <span class=\"keyword\">loop</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">match</span> receiver.<span class=\"title function_ invoke__\">lock</span>().<span class=\"title function_ invoke__\">unwrap</span>().<span class=\"title function_ invoke__\">recv</span>() &#123;</span><br><span class=\"line\">                <span class=\"title function_ invoke__\">Ok</span>(TaskSign::End) =&gt; &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;🚦 Worker thread &#123;&#125; getting end signal.&quot;</span>, index + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 接收到停止信号，终结循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"title function_ invoke__\">Ok</span>(TaskSign::<span class=\"title function_ invoke__\">Task</span>(task)) =&gt; &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">println!</span>(</span><br><span class=\"line\">                        <span class=\"string\">&quot;⏩ Worker thread &#123;&#125; is processing the task &#123;&#125;.&quot;</span>,</span><br><span class=\"line\">                        index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                        task.id</span><br><span class=\"line\">                    );</span><br><span class=\"line\">                    task.<span class=\"title function_ invoke__\">run</span>();</span><br><span class=\"line\">                  </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"title function_ invoke__\">Err</span>(e) =&gt; &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">eprintln!</span>(<span class=\"string\">&quot;❌ Worker thread &#123;&#125; error: &#123;&#125;&quot;</span>, index + <span class=\"number\">1</span>, e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">worker</span> = Worker::<span class=\"title function_ invoke__\">new</span>(index, handle);</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.threads.<span class=\"title function_ invoke__\">push</span>(worker);</span><br><span class=\"line\">        index</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 停止所有工作线程，向所有工作线程发送停止标志</span></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">stop</span>(&amp;<span class=\"keyword\">self</span>, transmitter: &amp;Sender&lt;TaskSign&gt;) <span class=\"punctuation\">-&gt;</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"variable\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"keyword\">self</span>.threads.<span class=\"title function_ invoke__\">len</span>() &#123;</span><br><span class=\"line\">            transmitter.<span class=\"title function_ invoke__\">send</span>(TaskSign::End).<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 工作线程池</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">worker_thread_pool</span> = WorkerThreads::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (send_tx, send_rx) = mpsc::channel::&lt;TaskSign&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">shared_rx</span> = Arc::<span class=\"title function_ invoke__\">new</span>(Mutex::<span class=\"title function_ invoke__\">new</span>(send_rx));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">4</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// create worker threads</span></span><br><span class=\"line\">        worker_thread_pool.<span class=\"title function_ invoke__\">add_worker</span>(Arc::<span class=\"title function_ invoke__\">clone</span>(&amp;shared_rx));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">id</span> = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> id == <span class=\"number\">6</span> &#123;</span><br><span class=\"line\">            WorkerThreads::<span class=\"title function_ invoke__\">stop</span>(&amp;worker_thread_pool, &amp;send_tx);</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;🎯 Main thread has sended end signal on task &#123;&#125;.&quot;</span>, id);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"variable\">task</span> = Task::<span class=\"title function_ invoke__\">new</span>(id);</span><br><span class=\"line\">            send_tx.<span class=\"title function_ invoke__\">send</span>(TaskSign::<span class=\"title function_ invoke__\">Task</span>(task)).<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;🧱 Main thread has sended task &#123;&#125;.&quot;</span>, id);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">worker</span> <span class=\"keyword\">in</span> worker_thread_pool.threads &#123;</span><br><span class=\"line\">        worker.handle.<span class=\"title function_ invoke__\">join</span>().<span class=\"title function_ invoke__\">unwrap</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;✅ All tasks are finished !!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>重点实现分析：</strong></p>\n<ol>\n<li>创建了一个工作线程池结构体，来管理子线程的创建和停止，停止意味着向所有子线程发送停止信号。</li>\n<li>子线程负责持续向 receiver 查询任务，当子线程接收到停止信号时，则终结循环。</li>\n<li>收集所有子线程返回的 joinHandle，分别调用 join() 方法以阻塞主线程，等待子线程的执行。</li>\n<li>优雅停止的秘诀：在子线程的loop循环中判断是否还能接续接收任务，若不行则跳出循环，不再接收新任务。</li>\n</ol>\n","text":"Concurrency in Rust在 Rust 中，并发（Concurrency）是一项核心功能，旨在安全高效的同时执行多个任务。 Spawning Thr...","permalink":"/post/concurrency","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"rust","slug":"rust","count":13,"path":"api/tags/rust.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Concurrency-in-Rust\"><span class=\"toc-text\">Concurrency in Rust</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spawning-Thread\"><span class=\"toc-text\">Spawning Thread</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Creating-new-thread\"><span class=\"toc-text\">Creating new thread</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#std-thread-spawn-closure\"><span class=\"toc-text\">std::thread::spawn(closure)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#join-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">join 方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Thread-variables-%E7%BA%BF%E7%A8%8B%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">Thread variables 线程变量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#move-closure-%E4%BD%BF%E7%94%A8-move-%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%86%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB%E5%88%B0%E9%97%AD%E5%8C%85%E5%86%85\"><span class=\"toc-text\">move closure 使用 move 关键字将变量的数据所有权转移到闭包内</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#std-thread-scope\"><span class=\"toc-text\">std::thread::scope</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Message-Passing-with-MPSC-channels\"><span class=\"toc-text\">Message Passing with MPSC channels</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E4%BF%A1%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">通信原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E4%B8%AA%E7%94%9F%E4%BA%A7%E8%80%85-multiple-producers\"><span class=\"toc-text\">多个生产者 multiple producers</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Sharing-data-within-multiple-threads\"><span class=\"toc-text\">Sharing data within multiple threads</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Mutex-%E4%BA%92%E6%96%A5%E9%94%81-%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">Mutex 互斥锁 是什么</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Mutex-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Mutex 怎么使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">创建</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">访问</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A01\"><span class=\"toc-text\">练习1</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%83%E4%B9%A02\"><span class=\"toc-text\">练习2</span></a></li></ol>","author":{"name":"Marnie","slug":"blog-author","avatar":"/images/favicon.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Rust Test","uid":"acc0e87b34830b962966d84f538705e6","slug":"rust-test","date":"2025-01-27T02:12:05.000Z","updated":"2025-01-27T10:59:10.090Z","comments":true,"path":"api/articles/rust-test.json","keywords":"","cover":[],"text":"Unit Test单元测试 123456789101112131415161718192021222324252627282930313233343536373...","permalink":"/post/rust-test","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"rust","slug":"rust","count":13,"path":"api/tags/rust.json"}],"author":{"name":"Marnie","slug":"blog-author","avatar":"/images/favicon.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}